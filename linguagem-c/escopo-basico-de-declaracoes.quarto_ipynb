{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Escopo básico de declarações\n",
        "\n",
        "Os códigos fonte em C permitem muitas declarações, como as de variáveis. Este capítulo trata da declaração de variáveis e onde são válidas, além de introduzir superficialmente outras declarações da linguagem.\n",
        "\n",
        "## Declarações e validade {#sec-declaracoes-e-validade}\n",
        "\n",
        "O primeiro ponto é, em princípio, bastante intuitivo: para usar uma variável é preciso declará-la antes desse uso. Portanto, a validade de uma variável depende de onde, no código fonte, sua declaração aparece.\n",
        "\n",
        "O programa seguinte pode ser considerado para exemplificar as validades.\n",
        "\n",
        "```{c} {code-line-numbers=\"true\"}\n",
        "/*\n",
        "Conversões de distância de metros para centímetros, pés, jardas e polegadas\n",
        "Requer: uma distância em metros\n",
        "Assegura: O valor equivalente em centímetros, pés, jardas e polegadas\n",
        "*/\n",
        "#include <stdio.h>\n",
        "\n",
        "int main(void) {\n",
        "    char entrada[160];\n",
        "\n",
        "    printf(\"Digite uma distância em metros: \");\n",
        "    fgets(entrada, sizeof entrada, stdin);\n",
        "    double em_metros;\n",
        "    sscanf(entrada, \"%lf\", &em_metros);\n",
        "    //TYPE(0, \"300\");\n",
        "\n",
        "    // Centímetros\n",
        "    double em_centimetros = em_metros * 100;\n",
        "    printf(\"> %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n",
        "\n",
        "    // Pés\n",
        "    double em_pes = em_metros * 3.281;\n",
        "    printf(\"> %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n",
        "\n",
        "    // Jardas\n",
        "    double em_jardas = em_metros * 1.094;\n",
        "    printf(\"> %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n",
        "\n",
        "    // Centímetros\n",
        "    double em_polegadas = em_metros * 39.37;\n",
        "    printf(\"> %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n",
        "\n",
        "    return 0;\n",
        "}\n",
        "// Fim do código fonte\n",
        "```\n",
        "\n",
        "Neste programa, a variável entrada existe desde a linha\\ 9 e é válida até a linha\\ 33. A variável `em_metros` inicia sua validade na linha\\ 13, `em_pes` na linha\\ 21, `em_jardas` na\\ 25 e `em_polegadas` na\\ 29 e, para todas, a validade termina na linha\\ 33.\n",
        "\n",
        "Note-se que, porém, que nenhuma variável é válida na linha\\ 34, depois do encerramento do bloco do `main`. As variáveis são válidas apenas dentro do bloco onde foram declaradas. E é importante destacar que um bloco de comandos é aquele iniciado por `{` e finalizado por `}`.\n",
        "\n",
        "::: {.callout-tip}\n",
        "É indicado que a declaração de uma variável seja feita o mais próximo possível de seu uso, o que promove clareza de padronização ao programa.\n",
        ":::\n",
        "\n",
        "O programa que implementa o @alg-escrita-nao-decrescente é reproduzido na sequência.\n",
        "\n",
        "```{.c code-line-numbers=\"true\"}\n",
        "/*\n",
        "Apresentação de dois valores em ordem não decrescente\n",
        "Requer: dois valores reais v1 e v2\n",
        "Assegura: v1 <= v2\n",
        "*/\n",
        "#include <stdio.h>\n",
        "\n",
        "int main(void) {\n",
        "    char entrada[160];\n",
        "\n",
        "    printf(\"Digite dois valores reais: \");\n",
        "    fgets(entrada, sizeof entrada, stdin);\n",
        "    double v1, v2;\n",
        "    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n",
        "\n",
        "    if(v2 < v1) {\n",
        "        double temporario = v1;\n",
        "        v1 = v2;\n",
        "        v2 = temporario;\n",
        "    }\n",
        "\n",
        "    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n",
        "    \n",
        "    return 0;\n",
        "}\n",
        "```\n",
        "\n",
        "O ponto de destaque desse código é a variável `temporario` usada para troca de valores. Ela é declarada dentro de um bloco de comandos, formando o comando composto condicionado pelo `if`. Sua validade é efêmera, pois é válida apenas da linha\\ 18 até a\\ 21, quando o bloco é encerrado. A tentativa de referenciar `temporario` fora do bloco do `if` gera um erro de identificador não declarado.\n",
        "\n",
        "Nesse ponto específico do programa, é relevante perceber que a utilidade de `temporario` é apenas local e não há qualquer necessidade de que seja declarada como válida em todo o bloco do `main`.\n",
        "\n",
        "::: {.callout-tip}\n",
        "Váriáveis com uso localizado devem ser declaradas apenas dentro do bloco onde são úteis, evitando que tenham validade fora dessa abrangência.\n",
        ":::\n",
        "\n",
        "### Duplicidade de identificadores\n",
        "\n",
        "Não é possível o uso do mesmo identificador no mesmo escopo de abrangência. Segue um exemplo simples que ilustra o problema.\n",
        "\n",
        "\n",
        "```{c} {intentional-problems=\"true\"}\n",
        "/*\n",
        "Exemplo de declaração repetida de um identificador no mesmo escopo\n",
        "*/\n",
        "#include <stdio.h>\n",
        "\n",
        "int main(void) {\n",
        "    int valor = 10;\n",
        "    printf(\"valor: %d.\\n\", valor);\n",
        "    \n",
        "    int valor = 100;\n",
        "    printf(\"valor: %d.\\n\", valor);\n",
        "    \n",
        "    return 0;\n",
        "}\n",
        "```\n",
        "\n",
        "Há, porém, a possibilidade de que um mesmo identificador seja usado em um novo escopo, valendo a regra que sempre a declaração \"mais local\" é a válida.\n",
        "\n",
        "\n",
        "```{c}\n",
        "/*\n",
        "Exemplo de declaração repetida de um identificador em escopos diferentes\n",
        "*/\n",
        "#include <stdio.h>\n",
        "\n",
        "int main(void) {\n",
        "    int valor = 10;\n",
        "    printf(\"valor: %d (antes do if).\\n\", valor);\n",
        "    \n",
        "    if (valor == 10){\n",
        "        int valor = 100;\n",
        "        printf(\"valor: %d (dentro do if).\\n\", valor);\n",
        "    }\n",
        "\n",
        "    printf(\"valor: %d (depois do if).\\n\", valor);\n",
        "\n",
        "    return 0;\n",
        "}\n",
        "```\n",
        "\n",
        "\n",
        "Nesse programa, uma variável chamada `valor` é criada dentro do bloco de comandos do condicional `if` e sua validade é apenas local, apesar de uma declaração mais externa de `valor` existir. Dentro do bloco, apenas a variável `valor` interna pode ser utilizada, apesar de `valor` externo continuar existindo. Declarações mais locais obscurecem a visão de identificadores mais externos com mesmo nome.\n",
        "\n",
        "Apesar de isso ser possível de ser feito, não é uma boa prática redeclarar identificadores, visto que a clareza fica severamente comprometida.\n",
        "\n",
        "::: {.callout-tip}\n",
        "O uso não justificado de um mesmo identificador em escopos diferentes, porém próximos, dificulta a compreensão do código e pode levar a erros difíceis de serem localizados e corrigidos.\n",
        "\n",
        "O uso de identificadores iguais, porém, é válido e será usado em contextos nos quais a multiplicidade de um mesmo nome seja favorável à clareza ao invés de prejudicial.\n",
        ":::\n",
        "\n",
        "\n",
        "Como outro exemplo, o programa seguinte replica a necessidade de escrever dois valores em ordem não decrescente, porém havendo dois valores inteiros e dois valores reais.\n",
        "\n",
        "\n",
        "```{c}\n",
        "/*\n",
        "Apresentação de dois valores em ordem não decrescente\n",
        "Requer:  dois valores inteiros vi1 e vi2 e dois valores reais vr1 e vr2\n",
        "Assegura: vi1 <= vi2 e vr1 <= vr2\n",
        "*/\n",
        "#include <stdio.h>\n",
        "\n",
        "int main(void) {\n",
        "    char entrada[160];\n",
        "\n",
        "    // Obtenção dos valores\n",
        "    printf(\"Digite dois valores inteiros: \");\n",
        "    fgets(entrada, sizeof entrada, stdin);\n",
        "    int v_int_1, v_int_2;\n",
        "    sscanf(entrada, \"%d%d\", &v_int_1, &v_int_2);\n",
        "    //TYPE(0, \"300 200\");\n",
        "\n",
        "    printf(\"Digite dois valores reais: \");\n",
        "    fgets(entrada, sizeof entrada, stdin);\n",
        "    double v_real_1, v_real_2;\n",
        "    sscanf(entrada, \"%lf%lf\", &v_real_1, &v_real_2);\n",
        "    //TYPE(0, \"118.2 302.75\");\n",
        "\n",
        "    // Verificação da ordem\n",
        "    if (v_int_2 < v_int_1) {\n",
        "        int temporario = v_int_1;\n",
        "        v_int_1 = v_int_2;\n",
        "        v_int_2 = temporario;\n",
        "    }\n",
        "\n",
        "    if (v_real_2 < v_real_1) {\n",
        "        double temporario = v_real_1;\n",
        "        v_real_1 = v_real_2;\n",
        "        v_real_2 = temporario;\n",
        "    }\n",
        "\n",
        "    // Apresentação de resultados\n",
        "    printf(\"Valores inteiros em ordem não decrescente: %d e %d.\\n\",\n",
        "           v_int_1, v_int_2);\n",
        "    printf(\"Valores reais em ordem não decrescente: %g e %g.\\n\",\n",
        "           v_real_1, v_real_2);\n",
        "\n",
        "    return 0;\n",
        "}\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "É interessante observar que há duas variáveis chamadas `temporario` existindo em momentos distintos do programa. Não há, porém, problemas com essa duplicidade de uso, uma vez que suas existências são muito localizadas e não se misturam. Naturalmente cabe ao programador optar ou não por usar nomes distintos.\n",
        "\n",
        "\n",
        "\n",
        "## Outras declarações da linguagem\n",
        "\n",
        "Um programa não declara apenas variáveis. A própria linha `int main(void)` dos programas é uma declaração da função `main`. Sem essa declaração, o sistema operacional não teria como saber por qual instrução começar a execução. Além disso, dentro de `stdio.h`, por exemplo, estão declarados protótipos das funções `printf`, `sscanf`, `fgets` e etc. Desta forma, depois do `#include` essas funções passam a ser conhecidas e podem ser corretamente usadas.\n",
        "\n",
        "Uma visão completa de declarações e regras de escopo é tratada no @sec-regras-de-escopo-com-modularizacao.\n",
        "\n",
        "Este programa seguinte ilustra uma das grandes vantagens das declarações locais suplantarem as declarações mais externas existentes. \n",
        "\n",
        "\n",
        "```{c}\n",
        "/*\n",
        "Exemplo de declaração de uma variável lógica\n",
        "*/\n",
        "#include <stdio.h>\n",
        "#include <stdbool.h>\n",
        "\n",
        "int main(void) {\n",
        "    bool remove = false;\n",
        "    printf(\"Vai remover? %s!\\n\", remove ? \"SIM\" : \"NÃO\");\n",
        "\n",
        "    return 0;\n",
        "}\n",
        "```\n",
        "\n",
        "\n",
        "A declaração deste código cria uma variável lógica chamada `remove`, a qual é usada sem erros. Porém, em `stdlib.h` é declarada uma função `remove` (em inglês, do verbo _to remove_) que pode ser usada para apagar um arquivo. A sobreposição dos identificadores permite ter um código simples, funcional e claro sem conflito com outras declarações preexistentes. "
      ],
      "id": "39654ff7"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}