[
  {
    "objectID": "referencias.html",
    "href": "referencias.html",
    "title": "Bibliografia",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nBibliografia"
  },
  {
    "objectID": "algoritmos/cadeias-de-caracteres.html",
    "href": "algoritmos/cadeias-de-caracteres.html",
    "title": "algoritmos-cadeias-de-caracteres.qmd",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nalgoritmos-cadeias-de-caracteres.qmd"
  },
  {
    "objectID": "algoritmos/equacao-segundo-grau.html",
    "href": "algoritmos/equacao-segundo-grau.html",
    "title": "Algoritmos & Programação",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\n\nAlgoritmo 1: Pseudocódigo para o cálculo e apresentação das raízes reais de uma equação de segundo grau."
  },
  {
    "objectID": "algoritmos/manipulacao-de-arquivos-de-registros.html",
    "href": "algoritmos/manipulacao-de-arquivos-de-registros.html",
    "title": "Algoritmos: Manipulação de arquivos de registros",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/manipulacao-de-arquivos-de-registros.html#arquivos-de-registros-de-comprimento-fixo",
    "href": "algoritmos/manipulacao-de-arquivos-de-registros.html#arquivos-de-registros-de-comprimento-fixo",
    "title": "Algoritmos: Manipulação de arquivos de registros",
    "section": "Arquivos de registros de comprimento fixo",
    "text": "Arquivos de registros de comprimento fixo"
  },
  {
    "objectID": "algoritmos/manipulacao-de-arquivos-de-registros.html#operações-em-arquivos",
    "href": "algoritmos/manipulacao-de-arquivos-de-registros.html#operações-em-arquivos",
    "title": "Algoritmos: Manipulação de arquivos de registros",
    "section": "Operações em arquivos",
    "text": "Operações em arquivos"
  },
  {
    "objectID": "algoritmos/processamento-basico-de-sequencias-de-dados.html",
    "href": "algoritmos/processamento-basico-de-sequencias-de-dados.html",
    "title": "Estruturas algorítmicas básicas para processamento de sequências de dados",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/processamento-basico-de-sequencias-de-dados.html#sequências-de-dados",
    "href": "algoritmos/processamento-basico-de-sequencias-de-dados.html#sequências-de-dados",
    "title": "Estruturas algorítmicas básicas para processamento de sequências de dados",
    "section": "Sequências de dados",
    "text": "Sequências de dados\nUma sequência de dados ocorre quando, por exemplo, quando há uma coleção relativamente grande de dados a serem considerados por um algoritmo.\nPara exemplificar, inicialmente é considerado um problema simples: determinar o valor máximo entre três valores reais. Uma solução é dada no Algoritmo 1.\n\n\nAlgoritmo 1: Determinação do máximo entre três valores reais.\n\n\n\nHá um volume de dados pequeno para esse problema, com apenas três valores. Supondo agora que o problema abordasse não apenas uma trinca de valores, mas uma dezena deles. O Algoritmo 2 apresenta uma solução para esse novo problema, seguindo a mesma linha de raciocínio da solução anterior.\n\n\nAlgoritmo 2: Determinação do máximo entre dez valores reais.\n\n\n\nVisivelmente é uma solução longa, embora não seja complexa. Entretanto, escrever uma solução similar para 20, 30 ou 100 valores usando essa estratégia é até factível, porém nada prática.\nUma estrutura de organização alternativa para esse problema poderia ser como a apresentada no Algoritmo 3.\n\n\nAlgoritmo 3: Determinação do máximo entre dez valores reais (versão 2).\n\n\n\nPara uma quantidade grande de valores, a solução pode ser ampliada apenas pelo acréscimo de novas variáveis \\(v_i\\) e novas verificações. Não é elegante, mas certamente mais prática, e talvez mais clara, que no Algoritmo 2.\nUm ponto interessante do Algoritmo 3 é que, feita a entrada de uma variável e confrontado seu valor com o máximo, ela não é mais usada. Isso leva a uma nova versão: o Algoritmo 4, na qual cada nova obtenção de valor reusa a mesma variável, substituindo seu valor por um novo da sequência de entrada.\n\n\nAlgoritmo 4: Determinação do máximo entre dez valores reais (versão 3).\n\n\n\nPara essa versão, aumentar a quantidade de itens a serem processados pode ser feita apenas acrescentando-se novas leituras e novas comparações, algo como um “copia-e-colar”. Entretanto, ainda a solução não é minimamente elegante, mesmo sendo mais prática que as anteriores.\nUma estrutura de repetição é uma ferramenta usada no pseudocódigo para indicar que algumas ações serão executadas várias vezes. Assim, A versão algorítmica final para o problema do máximo entre 10 valores pode ser dada pelo Algoritmo 5.\n\n\nAlgoritmo 5: Determinação do máximo entre dez valores reais (versão 4).\n\n\n\nA alteração desse algoritmo para processar, por exemplo, uma sequência de 1000 valores, requer apenas que a linha que indica “do segundo até o décimo” seja reescrita “do segundo até do milésimo”, contemplando uma solução para um novo problema, que é bem maior que os anteriores."
  },
  {
    "objectID": "algoritmos/processamento-basico-de-sequencias-de-dados.html#sec-caracterizacao-das-sequencias-de-dados",
    "href": "algoritmos/processamento-basico-de-sequencias-de-dados.html#sec-caracterizacao-das-sequencias-de-dados",
    "title": "Estruturas algorítmicas básicas para processamento de sequências de dados",
    "section": "Caracterização das sequências",
    "text": "Caracterização das sequências\nNos problemas computacionais, as sequências se apresentam de algumas formas bem características. Conquanto não sendo as únicas apresentações com que sequências podem assumir, estas são as mais comuns:\n\nas que simplesmente acabam;\nas com indicação de término com um valor especial (sentinela);\nas de comprimento previamente conhecido;\nas prefixadas com a quantidade de itens.\n\nSupondo que haja dados armazenados em um arquivo, a serem processados um a um, eles se caracterizam como uma sequência que, processado o último dado, a repetição sobre eles se encerra. Assim, os dados são processados até que não haja mais nada a processar. Naturalmente, essa perspectiva vale não somente para arquivos, mas também para dados digitados diretamente em um terminal.\n Uma alternativa para a organização dos dados é ter um dado especial que indique que a sequência terminou. Isso ocorre, por exemplo, na representação de cadeias de caracteres na linguagem C, sendo usado um caractere nulo (\\0) para indicar que os bytes da cadeia terminaram. Essa alternativa pode ser empregada para entrada de dados via terminal, quando valores são digitados e um valor especial (como zero, por exemplo), significa que a entrada terminou. Esta forma de representação de sequências requer a escolha de um valor especial, conhecido geralmente como sentinela, o qual não pode fazer parte da sequência.\nAlgumas sequências possuem comprimento conhecido. Se dados são colhidos diariamente, haverá uma sequência de 365 (ou 366) dados em um ano. Para o processamento, sabe-se previamente quantos dados existem e controlar uma repetição para processá-los pode ser feita mais facilmente.\nSendo uma forma bastante comum, uma sequência pode ser precedida da quantidade de itens que ela contém. Na linguagem Pascal, uma cadeia de caracteres é precedida por um byte que indica seu comprimento. No processamento deste tipo de sequência, o controle da repetição para o processamento é conhecido logo no início. A título de exemplo, este seria o caso de um polígono qualquer, descrito pelas coordenadas de seus vértices, ser precedido da quantidade de vértices, com triângulos precedidos por um 3 e pentágonos, por um 5.\n As duas primeiras caracterizações de sequências, as que acabam e as que possuem sentinela, são chamadas repetições indefinidas ou abertas. Nelas, não é conhecido previamente quantas vezes as ações de processamento serão repetidas. Em contraposição, quando o comprimento da sequência é fixo ou precedido de um valor indicando quantos itens são, a repetição se caracteriza como definida, sabendo-se quantas vezes as ações serão executadas.\nDado o universo de dados existentes, estas possibilidades não contemplam, é claro, todas as sequências, mas restringem nichos de grande relevância neste contexto."
  },
  {
    "objectID": "algoritmos/processamento-basico-de-sequencias-de-dados.html#fluxo-de-execução-com-repetições",
    "href": "algoritmos/processamento-basico-de-sequencias-de-dados.html#fluxo-de-execução-com-repetições",
    "title": "Estruturas algorítmicas básicas para processamento de sequências de dados",
    "section": "Fluxo de execução com repetições",
    "text": "Fluxo de execução com repetições\nNos algoritmos escritos com pseudocódigo há três estruturas clássicas para indicar a repetição, embora não sejam as únicas. Elas são representadas por enquanto, repita e para.\nQuando as repetições são indefinidas quanto ao número de vezes, as estruturas enquanto e repita são empregadas. Repetições sobre sequências de dados para as quais se sabe antecipadamente o número de iterações, ou seja, para as repetições definidas, a estrutura para é utilizada.\n\nFluxo com enquanto\nO enquanto é uma estrutura que indica uma repetição. Ela se apresenta como apresentado na sequência.\n\n\n\n\n\nA lógica que define o fluxo de execução com a estrutura enquanto é baseada em uma condição, a qual pode ser avaliada como verdadeira ou falsa. Se a condição for verdadeira, todas as instruções condicionadas da estrutura são executadas uma vez. Ao final da execução, a condição é avaliada novamente e nova execução das ações internas pode ou não ser feita, a depender do resultado.\nComo consequência, a estrutura indica que as instruções condicionadas podem ser executadas uma quantidade indefinida de vezes, que pode ser zero ou mais. É, assim, importante destacar que, sendo a condição falsa já na primeira verificação, nenhuma instrução interna é executada.\nPara que a estrutura tenha sentido prático, é esperado que as instruções alterem de alguma forma dos dados para que, eventualmente, a condição se torne falsa e a repetição se encerre.\nO processamento de sequências de dados cuja quantidade de itens não seja previamente conhecida é bastante comum e, assim, uma repetição de obtenção de valores com enquanto é bastante apropriada. O Algoritmo 6 é um exemplo dessa necessidade. Ele apresenta uma solução para, dadas várias idades de pessoas (podendo não haver nenhuma), determinar quantas delas são maiores ou iguais a 18.\n\n\nAlgoritmo 6: Determinação da quantidade de pessoas com maioridade legal.\n\n\n\nO enquanto verifica se há dados disponíveis como entrada e, havendo, obtém o dado (uma idade) e, sendo maior ou igual a 18 anos, conta essa ocorrência. Quando não houver mais dados na entrada, a repetição se encerra e a contagem é apresentada. Para o caso da entrada ser vazia, a condição do enquanto já é falsa logo no início e, assim, nenhuma leitura é feita, situação em que o contador permanece com valor zero.\nO uso do sentinela de dados também é viável de ter sua lógica organizada como enquanto. Um exemplo simples é a soma de uma série de números reais, todos maiores que zero. O sentinela será o número zero, que não faz parte dos dados válidos. Uma solução para esse problema é apresentada no Algoritmo 7.\n\n\nAlgoritmo 7: Soma de uma sequência de números reais com sentinela.\n\n\n\nA estratégia é fazer, antes da repetição, uma primeira leitura, que pode ser um valor válido ou o próprio sentinela (quando sequência de números está vazia). Antes de somar esse valor, é feita a comparação com o sentinela. Sendo o valor zero, nenhuma repetição é efetuada e a soma zero é o resultado apresentado. Caso seja um valor válido, ele é somado e, antes de nova verificação, o próximo valor da sequência de entrada é obtido, fechando um ciclo.\n\n\nFluxo com repita\nA estrutura repita também se aplica a repetições indefinidas. Sua estrutura é como se apresenta a seguir.\n\n\n\n\n\nO repita é uma estrutura que possui uma condição a ser verifica e sua avaliação é feita depois da execução dos comandos condicionados. Dessa forma, todos os comandos internos são executados e, então, a condição é verificada; resultando em falso, uma nova repetição é feita, sendo verdadeira, repetição se encerra.\nPor sua estrutura, os comandos internos do repita são executados pelo menos uma vez.\nPara exemplificar, pode ser considerado o problema da verificação da senha digitada por um usuário para acesso ao sistema, cujas regras são: se a senha digitada for correta, o acesso é dado; caso haja dez erros consecutivos, uma penalização de tempo (“aguarde cinco minutos para tentar novamente”) é aplicada. A quantidade de senhas que serão verificadas é desconhecido: se houver a inserção correta da senha logo no início há apenas uma verificação; se houver senhas inválidas, outras verificações serão necessárias.\nO Algoritmo 8 ilustra como essa questão pode ser abordada.\n\n\nAlgoritmo 8: Verificação de senha para acesso a um sistema.\n\n\n\nNessa solução, a repetição somente se encerra com a digitação da senha correta, o que pode levar uma eternidade. O algoritmo não detalha como a senha é efetivamente verificada, o que não é, porém, relevante no momento.\nSequências de dados com valor sentinela também podem ser processadas usando-se a estrutura repita. O problema resolvido pelo Algoritmo 7, que usa -enquanto, tem sua versão com repita apresentada no Algoritmo 9.\n\n\nAlgoritmo 9: Soma de uma sequência de números reais com sentinela (versão 2).\n\n\n\nNessa solução, a cada repetição é obtido um valor da entrada e a soma é feita apenas para os valores que não sejam iguais ao sentinela. Quando o valor sentinela é obtido da entrada, ele é ignorado e, em seguida, a repetição se encerra e o resultado final é apresentado. Caso não haja valores para serem somados, o resultado zero é apresentado.\n\n\nFluxo com para\nO para é indicado para repetições definidas, ou seja, para aquelas em que a quantidade de repetições é conhecida de antemão. A seguir é apresenta a estrutura do para.\n\n\n\n\n\nHá muitas variações comuns para a repetição com para. Elas são apresentadas a seguir.\nA versão mais comum para um para é com o uso de um iterador (normalmente uma variável genérica i estabelecendo o valor inicial e o final. Seguem exemplos.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nO uso do for é considerado sempre crescente1. Assim, uma repetição de 1 até 1 é feita apenas uma vez e para de 0 até -10 não há nenhuma repetição. Neste livro, portanto, essa é a interpretação consistentemente seguida.\nComo exemplo, a repetição seguinte pode ser considerada.\n\n\n\n\n\nNela, se \\({\\Id{final} &gt; \\Id{inicial}}\\), a repetição vai de inicial até final de 1 em 1, em um total de \\({\\Id{final} - \\Id{inicial} + 1}\\) vezes. Caso inicial\\(\\,=\\,\\)final as instruções internas são executadas uma única vez. Finalmente, se \\({\\Id{inicial} &gt; \\Id{final}}\\), não há nenhuma execução.\n\nRepetições regressivas\nAs repetições com para são, em princípio, crescentes. Para especificar uma repetição decrescente é necessário que ela se torne evidente e não requeira interpretações que podem variar entre diferentes pessoas.\nNeste livro há duas formas de indicar “contagens regressivas”: explicitamente na instrução ou alterando o passo com que a variável de controle da repetição é atualizado.\n\n\n\n\n\n\n\n\n\n\n\n\nRepetições com passo diferente de 1\nConforme apresentado nos demais exemplos deste capítulo, assume-se por padrão que os incrementos (ou decrementos com regressivo até) seja sempre unitários. Ainda assim é possível indicar iterações com passos diferentes.\nSeguem alguns exemplos.\n\n\n\n\n\n\n\n\n\n\nEmbora incomuns2, repetições com para que usem valores reais também podem ser usadas"
  },
  {
    "objectID": "algoritmos/processamento-basico-de-sequencias-de-dados.html#footnotes",
    "href": "algoritmos/processamento-basico-de-sequencias-de-dados.html#footnotes",
    "title": "Estruturas algorítmicas básicas para processamento de sequências de dados",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nNa realidade, nem sempre, mas é a forma de interpretação mais segura, a não ser que haja uma ressalva junto com o algoritmo.↩︎\nHá uma preferência geral de que repetições que não usem iteradores inteiros sejam escritas com enquanto ou repita.↩︎"
  },
  {
    "objectID": "algoritmos/modularizacao.html",
    "href": "algoritmos/modularizacao.html",
    "title": "Algoritmos: modularização",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/modularizacao.html#funções-e-valor-de-retorno",
    "href": "algoritmos/modularizacao.html#funções-e-valor-de-retorno",
    "title": "Algoritmos: modularização",
    "section": "Funções e valor de retorno",
    "text": "Funções e valor de retorno"
  },
  {
    "objectID": "algoritmos/modularizacao.html#procedimentos",
    "href": "algoritmos/modularizacao.html#procedimentos",
    "title": "Algoritmos: modularização",
    "section": "Procedimentos",
    "text": "Procedimentos"
  },
  {
    "objectID": "algoritmos/modularizacao.html#parâmetros-formais",
    "href": "algoritmos/modularizacao.html#parâmetros-formais",
    "title": "Algoritmos: modularização",
    "section": "Parâmetros formais",
    "text": "Parâmetros formais"
  },
  {
    "objectID": "algoritmos/modularizacao.html#parâmetros-por-valor-ou-por-referência",
    "href": "algoritmos/modularizacao.html#parâmetros-por-valor-ou-por-referência",
    "title": "Algoritmos: modularização",
    "section": "Parâmetros por valor ou por referência",
    "text": "Parâmetros por valor ou por referência"
  },
  {
    "objectID": "algoritmos/modularizacao.html#exemplos-e-exercícios",
    "href": "algoritmos/modularizacao.html#exemplos-e-exercícios",
    "title": "Algoritmos: modularização",
    "section": "Exemplos e exercícios",
    "text": "Exemplos e exercícios"
  },
  {
    "objectID": "algoritmos/desenvolvimento-basico-e-codificacao.html",
    "href": "algoritmos/desenvolvimento-basico-e-codificacao.html",
    "title": "Algoritmos: desenvolvimento básico e codificação",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/desenvolvimento-basico-e-codificacao.html#estrutura-de-algoritmos-simples",
    "href": "algoritmos/desenvolvimento-basico-e-codificacao.html#estrutura-de-algoritmos-simples",
    "title": "Algoritmos: desenvolvimento básico e codificação",
    "section": "Estrutura de algoritmos simples",
    "text": "Estrutura de algoritmos simples"
  },
  {
    "objectID": "algoritmos/desenvolvimento-basico-e-codificacao.html#exemplos-de-desenvolvimento-e-codificação",
    "href": "algoritmos/desenvolvimento-basico-e-codificacao.html#exemplos-de-desenvolvimento-e-codificação",
    "title": "Algoritmos: desenvolvimento básico e codificação",
    "section": "Exemplos de desenvolvimento e codificação",
    "text": "Exemplos de desenvolvimento e codificação"
  },
  {
    "objectID": "algoritmos/testes-de-mesa.html",
    "href": "algoritmos/testes-de-mesa.html",
    "title": "Algoritmos: testes de mesa",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/testes-de-mesa.html#testes-de-mesa-com-nível-alto-de-abstração",
    "href": "algoritmos/testes-de-mesa.html#testes-de-mesa-com-nível-alto-de-abstração",
    "title": "Algoritmos: testes de mesa",
    "section": "Testes de mesa com nível alto de abstração",
    "text": "Testes de mesa com nível alto de abstração"
  },
  {
    "objectID": "algoritmos/testes-de-mesa.html#testes-de-mesa-com-nível-baixo-de-abstração",
    "href": "algoritmos/testes-de-mesa.html#testes-de-mesa-com-nível-baixo-de-abstração",
    "title": "Algoritmos: testes de mesa",
    "section": "Testes de mesa com nível baixo de abstração",
    "text": "Testes de mesa com nível baixo de abstração"
  },
  {
    "objectID": "algoritmos/desenvolvimento-com-condicionais-e-codificacao.html",
    "href": "algoritmos/desenvolvimento-com-condicionais-e-codificacao.html",
    "title": "Algoritmos: desenvolvimento com condicionais e codificação",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/desenvolvimento-com-condicionais-e-codificacao.html#desenvolvimento-com-condicionais",
    "href": "algoritmos/desenvolvimento-com-condicionais-e-codificacao.html#desenvolvimento-com-condicionais",
    "title": "Algoritmos: desenvolvimento com condicionais e codificação",
    "section": "Desenvolvimento com condicionais",
    "text": "Desenvolvimento com condicionais"
  },
  {
    "objectID": "algoritmos/desenvolvimento-com-condicionais-e-codificacao.html#codificação",
    "href": "algoritmos/desenvolvimento-com-condicionais-e-codificacao.html#codificação",
    "title": "Algoritmos: desenvolvimento com condicionais e codificação",
    "section": "Codificação",
    "text": "Codificação"
  },
  {
    "objectID": "algoritmos/dados-compostos-vetores.html",
    "href": "algoritmos/dados-compostos-vetores.html",
    "title": "Algoritmos: dados compostos (vetores)",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/dados-compostos-vetores.html#vetores-e-indexação",
    "href": "algoritmos/dados-compostos-vetores.html#vetores-e-indexação",
    "title": "Algoritmos: dados compostos (vetores)",
    "section": "Vetores e indexação",
    "text": "Vetores e indexação"
  },
  {
    "objectID": "algoritmos/dados-compostos-vetores.html#propósito-de-vetores",
    "href": "algoritmos/dados-compostos-vetores.html#propósito-de-vetores",
    "title": "Algoritmos: dados compostos (vetores)",
    "section": "Propósito de vetores",
    "text": "Propósito de vetores"
  },
  {
    "objectID": "algoritmos/dados-compostos-vetores.html#exemplos",
    "href": "algoritmos/dados-compostos-vetores.html#exemplos",
    "title": "Algoritmos: dados compostos (vetores)",
    "section": "Exemplos",
    "text": "Exemplos"
  },
  {
    "objectID": "algoritmos/dados-compostos-vetores.html#desenvolvimento-com-vetores",
    "href": "algoritmos/dados-compostos-vetores.html#desenvolvimento-com-vetores",
    "title": "Algoritmos: dados compostos (vetores)",
    "section": "Desenvolvimento com vetores",
    "text": "Desenvolvimento com vetores"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Algoritmos & Programação",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEste site é dedicado ao ensino para a construção de algoritmos e para o básico da programação na linguagem C.\n\n\n\n\n\n\nAviso\n\n\n\nHouve uma reformulação da estrutura do site e ainda há ajustes a serem feitos.\nNotadamente, ainda há muitas referências cruzadas entre as páginas que precisam ser corrigidas. Isso será feito com o tempo…"
  },
  {
    "objectID": "sobre.html",
    "href": "sobre.html",
    "title": "Sobre…",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "sobre.html#sobre-o-material",
    "href": "sobre.html#sobre-o-material",
    "title": "Sobre…",
    "section": "Sobre o material",
    "text": "Sobre o material\nA escrita desse material é uma decorrência do conteúdo abordado na disciplina Construção de Algoritmos e Programação, CAP, oferecida pelo Departamento de Computação da Universidade Federal de São Carlos."
  },
  {
    "objectID": "sobre.html#sobre-mim",
    "href": "sobre.html#sobre-mim",
    "title": "Sobre…",
    "section": "Sobre mim",
    "text": "Sobre mim\nJander Moreira é docente na Universidade Federal de São Carlos."
  },
  {
    "objectID": "linguagem-c/parametros-de-funcoes.html",
    "href": "linguagem-c/parametros-de-funcoes.html",
    "title": "Parâmetros das funções",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nNeste capítulo são retomados os conceitos de parâmetros de funções, detalhando seu funcionamento interno e dando alternativas para algumas necessidades reais dos programas.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Parâmetros das funções"
    ]
  },
  {
    "objectID": "linguagem-c/parametros-de-funcoes.html#cadeias-de-caracteres-são-sempre-passagem-por-referência",
    "href": "linguagem-c/parametros-de-funcoes.html#cadeias-de-caracteres-são-sempre-passagem-por-referência",
    "title": "Parâmetros das funções",
    "section": "Cadeias de caracteres são sempre passagem por referência",
    "text": "Cadeias de caracteres são sempre passagem por referência\nPara as variáveis que armazenam cadeias de caracteres, tem-se que seu identificador já representa seu endereço. Em consequência, quando a função fgets é usada, seu primeiro parâmetro é uma passagem da referência. Isso é ilustrado a seguir.\nchar texto[100];\nfgets(texto, sizeof texto, stdin);  // o parâmetro texto é o endereço onde\n                                    // os dados da variável são guardados\nDessa forma a função fgets consegue, por meio do ponteiro passado, modificar o conteúdo da variável texto. A declaração de fgets é equivalente à apresentada na sequência1.\nchar *fgets(char s*, int size, FILE *stream);\nO primeiro parâmetro da função espera que seja passado um endereço de um char, que é para onde os bytes lidos serão transferidos.\nA consequência é que, na linguagem C, sempre são passadas as referências (endereços) das cadeias de caracteres.\n\n\n\n\n\n\nDica\n\n\n\nQuando se desejar passar uma cadeia de caracteres por valor (o que não é tecnicamente possível), pode-se contornar o problema especificando que a função não tem autorização para mudar o conteúdo da variável. O valor passado como parâmetro continua sendo a referência, mas o compilador gerará um erro caso o programador tente modificar o valor.\nSegue um exemplo simples.\n/*\n * Exemplo de erro ao tentar mudar uma cadeia de caracteres\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Apresenta uma mensagem na tela\n * @param mensagem: texto a ser apresentado\n */\nvoid apresente_mensagem(char const *mensagem);\n\n/*\n * Main\n */\nint main(void) {\n    char minha_mensagem[] = \"Olá a todos!\";\n    apresente_mensagem(minha_mensagem);\n\n    return 0;\n}\n\n// Apresenta a mensagem \nvoid apresente_mensagem(const char *mensagem) {\n    mensagem[0] = 'X';  // tentativa de alteração\n    printf(\"%s\\n\", mensagem);\n}\nmain.c: In function ‘apresente_mensagem’:\nmain.c:24:17: error: assignment of read-only location ‘*mensagem’\n   24 |     mensagem[0] = 'X';  // tentativa de alteração\n      |                 ^\nO modificador const adicionado ao parâmetro alerta o compilador que o identificador mensagem (parâmetro) não pode ser usado para alterar o valor.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Parâmetros das funções"
    ]
  },
  {
    "objectID": "linguagem-c/parametros-de-funcoes.html#já-usei-passagem-por-referência-muitas-vezes",
    "href": "linguagem-c/parametros-de-funcoes.html#já-usei-passagem-por-referência-muitas-vezes",
    "title": "Parâmetros das funções",
    "section": "“Já usei passagem por referência muitas vezes”",
    "text": "“Já usei passagem por referência muitas vezes”\nAo longo dos inúmeros exemplos usados neste livro, a passagem por referência já vinha sendo utilizada. Por exemplo, na leitura de um valor real, a conversão é feita pelo sscanf, que pode ter o formato seguinte.\nsscanf(entrada, \"%lf\", &valor);\nÉ importante notar que o endereço da variável valor foi passado para sscanf. Depois de interpretar a cadeia de caracteres em entrada procurando por um %lf presente, o resultado dessa conversão é guardado como um double na posição de memória passada, ou seja, exatamente onde está a variável valor.\nSem o operador &, a função sscanf não conseguiria ter acesso à variável valor, que tem escopo externo a ela, e usa seu endereço para conseguir modificá-la.\nE, naturalmente, também fgets usa referência para fazer a leitura.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Parâmetros das funções"
    ]
  },
  {
    "objectID": "linguagem-c/parametros-de-funcoes.html#simplificação-de-números-racionais",
    "href": "linguagem-c/parametros-de-funcoes.html#simplificação-de-números-racionais",
    "title": "Parâmetros das funções",
    "section": "Simplificação de números racionais",
    "text": "Simplificação de números racionais\nUm número racional (\\(\\mathbb{Q}\\)) é aquele que pode ser escrito na forma \\(a/b\\), sendo \\(a \\in \\mathbb{Z}\\) com \\(b \\in \\mathbb{Z}^*\\). O Algoritmo 1 apresenta uma solução de como fazer a simplificação de um valor racional, padronizando sua apresentação.\nA seguir é apresentada uma versão de implementação desse algoritmo, agora com o emprego de um procedimento para fazer a simplificação.\n/*\n * Leitura e escrita de um número racional na forma de fração\n * Requer: a digitação de um valor a/b, a,b inteiros, a, b != 0\n * Assegura: apresentação do mesmo valor em forma simplificada e padronizada\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Simplificação de um número racional dados numerador e denominador\n * @param numerador: numerador\n * @param denominador: denominador (não nulo)\n */\nvoid simplifique_racional(int *numerador, int *denominador);\n\n/*!\n * Retorna o MDC de dois inteiros quaisquer (máximo divisor comum).\n * @param n1: primeiro valor\n * @param n2: segundo valor\n * @return MDC(n1, n2)\n */\nunsigned int mdc(int n1, int n2);\n\n/*!\n * Retorna o valor absoluto de um inteiro\n * @param n: valor inteiro\n * @return o valor absoluto do número, |n|\n */\nint valor_absoluto(int n);\n\n/*\n * Main\n */\nint main() {\n    // Leitura\n    printf(\"Digite um número racional a/b (a e b inteiros e b não nulo): \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    int numerador, denominador;\n    sscanf(entrada, \"%d/%d\", &numerador, &denominador);\n\n    // Simplificação e apresentação da razão\n    simplifique_racional(&numerador, &denominador);\n    printf(\"O racional digitado foi: %d/%d.\\n\", numerador, denominador);\n\n    return 0;\n}\n\n// Máximo divisor comum: MDC(n1, n2)\nunsigned int mdc(int n1, int n2) {\n    // Converte n1 e n2 para valores positivos\n    n1 = valor_absoluto(n1);\n    n2 = valor_absoluto(n2);\n\n    // Resolução pelo método de Euclides\n    int resto;\n    do {\n        resto = n1 % n2;\n        n1 = n2;\n        n2 = resto;\n    } while (resto != 0);\n\n    return (unsigned int)n1;  // Contém o MDC no final\n}\n\n// Valor absoluto de um inteiro\nint valor_absoluto(int n) {\n    return (n &gt;= 0) ? n : -n;\n}\n\n// Simplificação de um racional\nvoid simplifique_racional(int *numerador, int *denominador) {\n    if (*numerador == 0) {\n        *denominador = 1;  // padroniza zero para 0/1\n    }\n    else {\n        int sinal_da_fracao = ((double)*numerador / *denominador &gt;= 0) ? 1 : -1;\n        int fator_divisao = (int)mdc(*numerador, *denominador);\n        *numerador = valor_absoluto(*numerador);\n        *denominador = valor_absoluto(*denominador);\n        *numerador /= sinal_da_fracao * fator_divisao;\n        *denominador /= fator_divisao;\n    }\n}\nDigite um número racional a/b (a e b inteiros e b não nulo): 18/-26\nO racional digitado foi: -9/13.\nA função simplifique_racional determina o sinal (-1 ou 1, o qual será associado ao numerador) e qual o MDC entre o numerador e o denominador. Como são passadas referências às variáveis que estão em main, dentro da função são usados *numerador e *denominador para acesso às variáveis externas. A chamada para a simplificação, também, requer que os endereços das variáveis sejam passados.\nsimplifique_racional(&numerador, &denominador);  // endereços das variáveis\nUm ponto positivo de ter funções para realizar as diversas tarefas é que a função main fica mais simples e mais legível.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Parâmetros das funções"
    ]
  },
  {
    "objectID": "linguagem-c/parametros-de-funcoes.html#footnotes",
    "href": "linguagem-c/parametros-de-funcoes.html#footnotes",
    "title": "Parâmetros das funções",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nA declaração foi levemente modificada para maior clareza, porém mantendo a equivalência.↩︎",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Parâmetros das funções"
    ]
  },
  {
    "objectID": "linguagem-c/guia-de-estilo.html",
    "href": "linguagem-c/guia-de-estilo.html",
    "title": "Guia de estilo",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/guia-de-estilo.html#o-que-são-os-guias-de-estilo",
    "href": "linguagem-c/guia-de-estilo.html#o-que-são-os-guias-de-estilo",
    "title": "Guia de estilo",
    "section": "O que são os guias de estilo",
    "text": "O que são os guias de estilo"
  },
  {
    "objectID": "linguagem-c/guia-de-estilo.html#guia-de-estilo-adotado-neste-texto",
    "href": "linguagem-c/guia-de-estilo.html#guia-de-estilo-adotado-neste-texto",
    "title": "Guia de estilo",
    "section": "Guia de estilo adotado neste texto",
    "text": "Guia de estilo adotado neste texto\n\nIdentificadores\nNão há uma regra específica para como escrever identificadores. Há algumas estilos conhecidos e populares que estão apresentados na Tabela 1.\nNo chamado flat case (achatado), todas as letras são escritas em minúsculas. O mesmo recurso é usado do camel case (camelo), mas quando o identificador é composto por mais de uma palavra, cada palavra seguinte é iniciada com maiúscula, dando visibilidade a cada palavra individual. Uma variação do camel case é o upper camel case (maiúsculo), quando todas as palavras individuais\n\n\n\nTabela 1: Estilos de caso para escrita de identificadores.\n\n\n\n\n\nEstilo\nExemplo nome simples\nExemplo nome composto\n\n\n\n\nflat case\ntemperatura\ntemperaturacelsius\n\n\ncamel case\ntemperatura\ntemperaturaCelsius\n\n\nupper camel case\nTemperatura\nTemperaturaCelsius\n\n\nsnake case\ntemperatura\ntemperatura_celsius\n\n\nscreaming case\nTEMPERATURA\nTEMPERATURACELSIUS\n\n\n\n\n\n\n\n\nIndentação\nA disposição dos elementos que formam um código fonte em C é, em grande parte, irrelevante. Isso quer dizer que a organização visual do código fonte é voltada para o programador, não para o compilador. Quando o programa está bem estruturado visualmente,\n\n\nEspaçamentos\n\n\nDocumentação"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte-complemento.html",
    "href": "linguagem-c/organizacao-do-codigo-fonte-complemento.html",
    "title": "Organização do código fonte: complemento",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#padronização-de-identificadores",
    "href": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#padronização-de-identificadores",
    "title": "Organização do código fonte: complemento",
    "section": "Padronização de identificadores",
    "text": "Padronização de identificadores\nOs identificadores usados para as variáveis e demais elementos da linguagem devem ser significativos. Além disso, também devem seguir um mesmo padrão ao longo do código.\nO entendimento de um programa pode ser prejudicado se houver uma variável chamada salario_inicial e o salário final for indicado por outra com nome s_final. O uso de salario_final é, sem dúvidas, mais consistente.\nDa mesma forma, em um mesmo programa há variáveis como taxa_juros, montante_final e saldo_atual juntamente com outras como tx_br, tx_liq, sf e p, por exemplo. As abreviações excessivas não estabelecem um padrão minimamente compatível em contraposição aos nomes mais explícitos.\nNada disso implica em que não possa haver abreviações, desde que atendem à legibilidade. Se em um aplicação há variáveis para diversas taxas diferentes, o uso de tx_inicial e tx_inercial são razoáveis para o contexto. Porém todas devem prefixadas com tx_, sem misturas o prefixo taxas_."
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#localização-da-declaração-de-variáveis",
    "href": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#localização-da-declaração-de-variáveis",
    "title": "Organização do código fonte: complemento",
    "section": "Localização da declaração de variáveis",
    "text": "Localização da declaração de variáveis\nEmbora uma variável possa ser declarada em inúmeras localizações dentro de um código fonte e ainda mantê-lo correto e coerente, é preciso reforçar que o local em que as declarações ocorrem favorecem o entendimento do propósito do programa e de sua lógica. Este tema é abordado de maneira rápida na ?@sec-declaracoes-e-validade.\nPor hábitos “ancestrais”, de quando a linguagem C não admitia a mistura entre declarações e código, ainda persiste a prática de declarar todas as variáveis juntas no início do bloco. Assim, nas versões iniciais da linguagem os programas deveriam necessariamente declarar todas suas variáveis antes da primeira linha que tivesse um comando ou chamada de função. Segue um exemplo.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    double em_metros, em_centimetros, em_pes, em_jardas, em_polegadas;\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    em_centimetros = em_metros * 100;\n    em_pes = em_metros * 3.281;\n    em_jardas = em_metros * 1.094;\n    em_polegadas = em_metros * 39.37;\n\n \n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nDigite uma distância em metros: 1.0\n&gt; 1.0m = 100.0cm\n&gt; 1.0m = 3.3 pés\n&gt; 1.0m = 1.1 jardas\n&gt; 1.0m = 39.4 polegadas\nO impacto para programas simples não é, em geral, grande. À medida que o número de linhas cresce, juntamente à complexidade da solução implementada, o “amontoado” de declarações no começo do programa prejudica a legibilidade. Muitas vezes, por exemplo, é preciso verificar se uma variável tem o tipo necessário e fazer as adequações pode trazer impactos não previstos. Por exemplo, ao alterar uma declaração de int para long int pode afetar não somente a variável de interesse, mas outras declaradas juntas."
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#alinhamento-dos-finais-de-bloco",
    "href": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#alinhamento-dos-finais-de-bloco",
    "title": "Organização do código fonte: complemento",
    "section": "Alinhamento dos finais de bloco",
    "text": "Alinhamento dos finais de bloco\nAs chaves da função main estabelecem o bloco da função principal e inclui as declarações e os comandos que formam o programa. Um bloco de comandos, na forma de um comando composto, é muitas vezes necessário para incluir mais que um comando dentro de um condicional, por exemplo.\nNão é incomum que, em programas em C, venha uma sequência de vários fechamentos de bloco, ou seja, vários }. Segue um programa que calcula as raízes de uma equação \\({ax^2 + bx + c = 0}\\) (\\({\\forall a, b, c}\\)), mesmo que a equação se reduza a forma linear.\n/*\nDeterminação das raízes reais de uma equação ax^2 + bx + c = 0, sem restrições\n    aos coeficientes a, b, ou c\nPré-condições: Os valores dos coeficientes a, b e C\nPós-condições: uma ou duas raízes reais ou mensagem indicando que não há\n    raízes reais\n\nQuando a é zero, a equação é tratada como linear; caso contrário, é\nquadrática. Divisões por zero são tratadas pela divisão de double, ou\nseja, podendo resultar em 'not a number' ou +-inf.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Considere uma equação ax^2 + bx + c = 0.\\n\"\n           \"Digite os valores a, b e c da equação: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double a, b, c;\n    sscanf(entrada, \"%lf%lf%lf\", &a, &b, &c);\n\n    if (a == 0) {\n        // Equação do primeiro grau\n        double x = -c / b;  \n        printf(\"Raiz: %g.\\n\", x);\n    }\n    else {\n        // Equação do segundo grau\n        double discriminante = pow(b, 2) - 4 * a * c;\n\n        // Determina o número de raízes reais\n        if (discriminante &lt; 0)\n            printf(\"Não há raízes reais.\\n\");\n        else if (discriminante &lt; 1e-5) {  // quase zero\n            // Raíz única\n            double x = -b / (2 * a);\n            printf(\"Raíz: %g.\\n\", x);\n        }\n        else {\n            // Duas raízes distintas\n            double x1 = (-b - sqrt(discriminante)) / (2 * a);\n            double x2 = (-b + sqrt(discriminante)) / (2 * a);\n            if (x2 &lt; x1) { // ordem não decrescente\n                double temporario = x1;\n                x1 = x2;\n                x2 = temporario;\n            }\n            printf(\"Raízes: %g e %g.\\n\", x1, x2);\n        }\n    }\n\n    return 0;\n}\nConsidere uma equação ax^2 + bx + c = 0.\nDigite os valores a, b e c da equação: -6 5 28\nRaízes: -1.7834 e 2.61673.\nÉ necessário que todos os fechamentos de bloco sejam, de alguma forma, alinhados a sua abertura. Esse alinhamento é essencial para localizar, por exemplo, um } que foi esquecido.\nNos programas apresentados neste livro, os blocos de comandos compostos são sempre iniciados na linha da estrutura que o utiliza, como um if, por exemplo.\nif(a &gt; 0) {\n    // Instruções...\n}\nelse {\n    // Outras instruções...\n}\nDesta forma, o fim do bloco fica com a mesma indentação da estrutura que o iniciou.\nPor questões de estilo (?@sec-guia-de-estilo), há programadores que preferem que as chaves sejam abertas na linha consecutiva. Isso naturalmente não é um problema, desde que o padrão seja mantido para todo o código. Na sequência são apresentadas variações do posicionamento das chaves, porém em todas o alinhamento de indentação é mantido.\nif(a &gt; 0)\n{\n    // Instruções...\n}\nelse\n{\n    // Outras instruções...\n}\nif(a &gt; 0) {\n    // Instruções...\n} else {\n    // Outras instruções...\n}\nComo contra exemplo, na sequência é apresentado o programa anterior usando uma “indentação alternativa”, que alinha o } com seu respectivo }, qualquer que seja sua posição. É preciso observer que o resultado quebra a visualização do código e dificulta exatamente saber onde termina cada bloco.\n/*\nDeterminação das raízes reais de uma equação ax^2 + bx + c = 0, sem restrições\n    aos coeficientes a, b, ou c\nPré-condições: Os valores dos coeficientes a, b e C\nPós-condições: uma ou duas raízes reais ou mensagem indicando que não há\n    raízes reais\n\nQuando a é zero, a equação é tratada como linear; caso contrário, é\nquadrática. Divisões por zero são tratadas pela divisão de double, ou\nseja, podendo resultar em 'not a number' ou +-inf.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Considere uma equação ax^2 + bx + c = 0.\\n\"\n           \"Digite os valores a, b e c da equação: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double a, b, c;\n    sscanf(entrada, \"%lf%lf%lf\", &a, &b, &c);\n\n    if (a == 0) {\n        // Equação do primeiro grau\n        double x = -c / b;  \n        printf(\"Raiz: %g.\\n\", x);\n                }\n    else {\n        // Equação do segundo grau\n        double discriminante = pow(b, 2) - 4 * a * c;\n\n        // Determina o número de raízes reais\n        if (discriminante &lt; 0) \n            printf(\"Não há raízes reais.\\n\");\n        else if (discriminante &lt; 1e-5) {  // quase zero\n            // Raíz única\n            double x = -b / (2 * a);\n            printf(\"Raíz: %g.\\n\", x);\n                                       }\n        else {\n            // Duas raízes distintas\n            double x1 = (-b - sqrt(discriminante)) / (2 * a);\n            double x2 = (-b + sqrt(discriminante)) / (2 * a);\n            if (x2 &lt; x1) { // ordem não decrescente\n                double temporario = x1;\n                x1 = x2;\n                x2 = temporario;\n                         }\n            printf(\"Raízes: %g e %g.\\n\", x1, x2);\n             }\n         }\n\n    return 0;\n               }\nConsidere uma equação ax^2 + bx + c = 0.\nDigite os valores a, b e c da equação: -6 5 28\nRaízes: -1.7834 e 2.61673.\n\n\n\n\n\n\nDica\n\n\n\nA maioria dos editores de programas atualmente já provê, ao digitar, uma alinhamento adequado das chaves, o que facilita a digitação. É preciso cuidar para que a própria edição do código não acabe com o alinhamento inadvertidamente.\n\n\n\n\n\n\n\n\nDica\n\n\n\nO auto-formatador é um recurso muito comum aos IDEs de programação. O uso desse recurso pode ser amplamente empregado!"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#comentários",
    "href": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#comentários",
    "title": "Organização do código fonte: complemento",
    "section": "Comentários",
    "text": "Comentários\nComentários devem ser esparsos e minimalistas no programa. Um programa que precisa de muitos comentário é porque o código não está bem escrito. A versão seguinte do programa do peso ideal inclui apenas dois comentários considerados pertinentes. Eles apenas guiam o humano que lê o código para que localize facilmente o significado dos dois cálculos.\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\ne sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    char sexo;\n    double altura;\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    double massa_ideal;\n    if(sexo == 'F')\n        massa_ideal = 62.1 * altura - 44.7;  // feminino\n    else\n        massa_ideal = 72.7 * altura - 58;  // masculino\n\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);\n\n    return 0;\n}\nEmbora a comparação sexo == 'F' seja suficiente, não custa nem atrapalha indicar a diferença entre as duas fórmulas.\nEm nível próximo ao exagero, considerando-se um programa curto como esse, ainda é possível ter comentários indicando a razão dos agrupamentos de comandos.\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\ne sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção de sexo biológico e altura\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    char sexo;\n    double altura;\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    // Cálculo da massa ideal\n    double massa_ideal;\n    if(sexo == 'F')\n        massa_ideal = 62.1 * altura - 44.7;  // feminino\n    else\n        massa_ideal = 72.7 * altura - 58;  // masculino\n\n    // Apresentação do resultado\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);\n\n    return 0;\n}\n\n\n\n\n\n\nCuidado\n\n\n\nÉ importante não “supercomentar” um programa. O excesso de comentários tende a tornar o código ilegível.\nO exemplo seguinte pertence à classe “não faça assim”.\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\ne sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n\n// Inclusão dos arquivos de cabeçalho\n#include &lt;stdio.h&gt;  // funções de entrada e saída\n\n// Programa principal\nint main(void) {\n    // Variável para a leitura da linha\n    char entrada[160];\n\n    // Obtenção de sexo biológico e altura\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);  // leitura da linha digitada\n    // Declaração das variáveis de entrada\n    char sexo;  // para o sexo biológico\n    double altura;  // para a altura da pessoa\n    // Conversão da linha para obtenção dos valores\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    // Declaração da massa ideal\n    double massa_ideal;\n\n    // Verificação do cálculo conforme feminino ou masculino\n    // (se o sexo for diferente de 'F', assume que seja 'M')\n    if(sexo == 'F')\n        // Realização do cálculo para o sexo feminino\n        massa_ideal = 62.1 * altura - 44.7;\n    else\n        // Realização do cálculo para o sexto masculino\n        massa_ideal = 72.7 * altura - 58;\n\n    // Apresentação do resultado\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);  // massa ideal em kg\n\n    // Indicação de término do programa com sucesso\n    return 0;\n}\nNesta versão, há comentários óbvios (como em double altura;  // para a altura da pessoa) e até a visualização da estrutura do if, que é simples, fica um tanto comprometida com o excesso de informações."
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#organização-consistente-do-código",
    "href": "linguagem-c/organizacao-do-codigo-fonte-complemento.html#organização-consistente-do-código",
    "title": "Organização do código fonte: complemento",
    "section": "Organização consistente do código",
    "text": "Organização consistente do código\nA organização do código deve ser consistente. As conversões de distância podem usar um programa correto, porém inconsistente quanto a sua organização. Essa é uma situação que deve ser firmemente evitada.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    double em_centimetros;\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    em_centimetros = em_metros * 100;\n    double em_pes = em_metros * 3.281;\n \n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n\n    double em_jardas = em_metros * 1.094, em_polegadas;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n\n    em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nDigite uma distância em metros: 10\n&gt; 10.0m = 1000.0cm\n&gt; 10.0m = 32.8 pés\n&gt; 10.0m = 10.9 jardas\n&gt; 10.0m = 393.7 polegadas\nNeste programa pode ser até complicado localizar em que momento houve a declaração da variável em_polegadas, por exemplo."
  },
  {
    "objectID": "linguagem-c/manipulacao-de-dados-textuais.html",
    "href": "linguagem-c/manipulacao-de-dados-textuais.html",
    "title": "Manipulação de dados textuais",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nO uso de variáveis para guardar valores textuais tem sido usado em praticamente todos os programas até o momento e seu uso para leitura está descrito na ?@sec-leitura-de-valores-textuais. Este capítulo apresenta com mais detalhes as cadeias de caracteres e introduz recursos para sua manipulação.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Manipulação de dados textuais"
    ]
  },
  {
    "objectID": "linguagem-c/manipulacao-de-dados-textuais.html#comprimento-de-cadeias-de-caracteres",
    "href": "linguagem-c/manipulacao-de-dados-textuais.html#comprimento-de-cadeias-de-caracteres",
    "title": "Manipulação de dados textuais",
    "section": "Comprimento de cadeias de caracteres",
    "text": "Comprimento de cadeias de caracteres\nUma função que já foi usada anteriormente em diversos programas é a strlen (string length), que retorna o comprimento da cadeia de caracteres sem o \\0 final.\n/*\nComprimento de cadeias de caracteres\nAssegura: a apresentação de textos e respectivos comprimentos\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char *texto1 = \"C: a linguagem\";\n    printf(\"\\\"%s\\\" tem comprimento %zu.\\n\", texto1, strlen(texto1));\n\n    char *texto2 = \"\";\n    printf(\"\\\"%s\\\" tem comprimento %zu.\\n\", texto2, strlen(texto2));\n\n    char *texto3 = \"Programas estruturados\";\n    printf(\"\\\"%s\\\" tem comprimento %zu.\\n\", texto3, strlen(texto3));\n\n    return 0;\n}\n\"C: a linguagem\" tem comprimento 14.\n\"\" tem comprimento 0.\n\"Programas estruturados\" tem comprimento 22.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Manipulação de dados textuais"
    ]
  },
  {
    "objectID": "linguagem-c/manipulacao-de-dados-textuais.html#atribuições-de-cadeias-de-caracteres",
    "href": "linguagem-c/manipulacao-de-dados-textuais.html#atribuições-de-cadeias-de-caracteres",
    "title": "Manipulação de dados textuais",
    "section": "Atribuições de cadeias de caracteres",
    "text": "Atribuições de cadeias de caracteres\nO programa seguinte foca na questão da atribuição. Porém, esse código serve apenas para mostrar o que não funciona.\n/*\nTentativa malsucedida de atribuir um valor a uma variável\nAssegura: absolutamente nada (infelizmente)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char texto[50];\n\n    texto = \"Bom dia!\";\n    printf(\"%s\\n\", texto);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:10:11: error: assignment to expression with array type\n   10 |     texto = \"Bom dia!\";\n      |           ^\nO humilde autor desse texto tem convicção que praticamente a totalidade dos programadores C do planeta desejariam que esse programa funcionasse. A realidade, porém, não é essa: o erro principal do código é exatamente a atribuição. Basicamente, texto é o nome para a coleção de caracteres e, na linguagem, não faz sentido armazenar nela uma constante.\nO programa seguinte mostra como a função strncpy (string copy) pode ser usada para obter o mesmo efeito da atribuição.\n/*\nAtribuição e apresentação de valor textual\nAssegura: apresentação do valor guardado em uma string\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char texto[50];\n\n    strncpy(texto, \"Bom dia!\", sizeof texto - 1);\n    printf(\"%s\\n\", texto);\n\n    return 0;\n}\nBom dia!\nO processo da atribuição é copiar um dado valor para uma variável.\nstrncpy(texto, \"Bom dia!\", sizeof texto - 1);\nO primeiro parâmetro de strncpy é a variável que receberá o valor. O segundo parâmetro é o valor que será atribuído, que pode ser uma constante ou outra variável. Há, ainda, um terceiro parâmetro, que é o tamanho da variável, que é importante para garantir que o limite de espaço reservado para a variável será respeitado. Ultrapassar o tamanho da variável pode trazer consequências imprevisíveis à execução.\n\n\n\n\n\n\nDica\n\n\n\nExistem funções de manipulação de cadeias de caracteres que não verificam o tamanho da variável destino. É importante nunca usá-las.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Manipulação de dados textuais"
    ]
  },
  {
    "objectID": "linguagem-c/manipulacao-de-dados-textuais.html#concatenação-de-cadeias-de-caracteres",
    "href": "linguagem-c/manipulacao-de-dados-textuais.html#concatenação-de-cadeias-de-caracteres",
    "title": "Manipulação de dados textuais",
    "section": "Concatenação de cadeias de caracteres",
    "text": "Concatenação de cadeias de caracteres\nAlém da cópia de uma sequência de caracteres para uma variável, é possível estender seu conteúdo, fazendo a concatenação. A função strncat (string catenation) faz a cópia de uma cadeia anexando-a a outra.\n/*\nCriação de uma única linha a partir de leituras separadas\nRequer: Uma sequência de linhas de texto\nAssegura: apresentação da concatenação de todas as linhas em uma só\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char texto[160];\n    char linha_unica[5000];\n\n    // Inicia uma cadeia vazia\n    strncpy(linha_unica, \"\", sizeof linha_unica - 1);\n\n    // Acrescenta cada linha digitada à linha única\n    printf(\"Digite linhas, usando Ctrl-D para encerrar:\\n\");\n    bool primeira_palavra = true;\n    while (fgets(texto, sizeof texto, stdin) != NULL) {\n\n        texto[strlen(texto) - 1] = '\\0';\n        if (primeira_palavra)\n            primeira_palavra = false;\n        else\n            strncat(linha_unica, \" \",\n                    sizeof linha_unica - strlen(linha_unica) - 1);\n\n        strncat(linha_unica, texto,\n                sizeof linha_unica - strlen(linha_unica) - 1);\n    }\n\n    // Texto total\n    printf(\"\\n\\\"%s\\\"\\n\", linha_unica);\n\n    return 0;\n}\nDigite linhas, usando Ctrl-D para encerrar:\nEra\numa\nvez\numa linda menina\nque possuia uma capa vermelha com\ncapuz.\n\n\"Era uma vez uma linda menina que possuia uma capa vermelha com capuz.\"\nA função de concatenação acrescenta à variável do primeiro parâmetro (linha_unica) uma cópia dos caracteres contidos no segundo parâmetro (texto). O terceiro parâmetro é a quantidade máxima de caracteres a serem copiados, a qual é usada para respeitar o tamanho do espaço da variável destino. No código, a quantidade máxima para cada concatenação corresponde ao cálculo do espaço livre existente em linha_unica, respeitando um byte para ter espaço para o \\0 final.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Manipulação de dados textuais"
    ]
  },
  {
    "objectID": "linguagem-c/manipulacao-de-dados-textuais.html#sec-comparacao-strings",
    "href": "linguagem-c/manipulacao-de-dados-textuais.html#sec-comparacao-strings",
    "title": "Manipulação de dados textuais",
    "section": "Comparações de cadeias de caracteres",
    "text": "Comparações de cadeias de caracteres\nA comparação entre duas cadeias de caracteres é feita no sentido alfabético usual, sempre comparando os primeiros caracteres das duas cadeias e, sendo iguais, passando para os segundos, terceiros e assim por diante. Nas funções de string.h, a função strncmp (string comparison) tem a finalidade realizar as comparações.\nA função strncmp retorna sempre um valor inteiro, como apresentado na Tabela 1.\n\n\n\nTabela 1: Resultados possíveis para a função strncmp.\n\n\n\n\n\nResultado\nSignificado\n\n\n\n\nzero\nIguais\n\n\nmenor que zero\nAnterior\n\n\nmaior que zero\nPosterior\n\n\n\n\n\n\nSegue um programa ilustrando o uso de strncmp.\n/*\nComparações de cadeias de caracteres\nRequer: a digitação de pares de palavras em cada linha\nAssegura: a apresentação da comparação entre as palavras de cada par\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char linha[160];\n    printf(\"Digite duas palavras por linha, usando Ctrl-D para encerrar:\\n\");\n    while (fgets(linha, sizeof linha, stdin) != NULL) {\n        char palavra1[80], palavra2[80];\n        sscanf(linha, \"%79s%79s\", palavra1, palavra2);  // palavras simples\n\n        if (strncmp(palavra1, palavra2, sizeof palavra1) == 0)\n            printf(\"%s é igual a %s.\\n\", palavra1, palavra2);\n        else if (strncmp(palavra1, palavra2, sizeof palavra1) &lt; 0)\n            printf(\"%s é anterior a %s.\\n\", palavra1, palavra2);\n        else\n            printf(\"%s é posterior a %s.\\n\", palavra1, palavra2);\n    }\n\n    return 0;\n}\nDigite duas palavras por linha, usando Ctrl-D para encerrar:\nabacaxi abacaxi\nabacaxi é igual a abacaxi.\nmarca marcas\nmarca é anterior a marcas.\nvermelho azul\nvermelho é posterior a azul.\nazul vermelho\nazul é anterior a vermelho.\ncontraponto contraindicado\ncontraponto é posterior a contraindicado.\nUma discussão sobre comparações de palavras acentuadas é apesentada na Seção 5.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Manipulação de dados textuais"
    ]
  },
  {
    "objectID": "linguagem-c/manipulacao-de-dados-textuais.html#a-remoção-do-n-incluído-pelo-fgets",
    "href": "linguagem-c/manipulacao-de-dados-textuais.html#a-remoção-do-n-incluído-pelo-fgets",
    "title": "Manipulação de dados textuais",
    "section": "A remoção do \\n incluído pelo fgets",
    "text": "A remoção do \\n incluído pelo fgets\nUma ação bastante comum quando a leitura de um valor textual é feito com a função fgets é a remoção do \\n que ela deixa na cadeia de caracteres lida. Essa remoção é importante para ficar somente com o texto digitado. Em mais detalhes, essa remoção parte de dois princípios: primeiro, que a leitura com o fgets sempre terá um \\n no seu final e, segundo, que tudo que estiver na variável a partir do \\0 é ignorado.\nDessa forma, a eliminação do \\n é feita pela simples atribuição do \\0 sobre ele. Como consequência, a cadeia de caracteres contém um novo final.\ntexto[strlen(texto) - 1] = '\\0';  // elimina o último caractere sobrepondo\n                                  // a ele um novo terminador de cadeia\nO programa seguinte tem o objetivo de apresentar essa remoção em detalhes, mostrando o conteúdo da variável antes e depois da eliminação do \\n.\n/*\nApresentação de todos os valores contidos em uma variável literal\nRequer: um texto de até 24 caracteres digitados pelo usuário\nAssegura: apresentação detalhada do texto posição a posição antes e\n    depois da remoção do \\n remanescente do fgets\n*/\n#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    // Leitura do texto\n    char texto[25];\n    printf(\"Digite um texto qualquer:\\n\");\n    fgets(texto, sizeof texto, stdin);\n\n    // Apresentação do vetor inteiro\n    printf(\"\\nAntes:\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++)\n        printf(\"%3d\", i);\n    printf(\"\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++) {\n        if (texto[i] == '\\0')\n            printf(\" \\\\0\");\n        else if (texto[i] == '\\n')\n            printf(\" \\\\n\");\n        else if (texto[i] == ' ')\n            printf(\"   \");\n        else if (isprint(texto[i]))\n            printf(\"%3c\", texto[i]);\n        else\n            printf(\" ??\");\n    }\n    printf(\"\\n\");\n\n    // Remoção do \\n final\n    texto[strlen(texto) - 1] = '\\0';  // remoção do \\n\n\n    // Reapresentação do vetor depois da alteração\n    printf(\"\\nDepois:\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++)\n        printf(\"%3d\", i);\n    printf(\"\\n\");\n    for (int i = 0; i &lt; (int)sizeof texto; i++) {\n        if (texto[i] == '\\0')\n            printf(\" \\\\0\");\n        else if (texto[i] == '\\n')\n            printf(\" \\\\n\");\n        else if (texto[i] == ' ')\n            printf(\"   \");\n        else if (isprint(texto[i]))\n            printf(\"%3c\", texto[i]);\n        else\n            printf(\" ??\");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\nDigite um texto qualquer:\nTeste\n\nAntes:\n  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n  T  e  s  t  e \\n \\0  ~  ) ?? ?? ??  @ ?? ?? \\0  | ??  T ?? ?? \\0 ?? ??  v\n\nDepois:\n  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n  T  e  s  t  e \\0 \\0  ~  ) ?? ?? ??  @ ?? ?? \\0  | ??  T ?? ?? \\0 ?? ??  v\nO objetivo desse programa é apresentar todas as posições da variável, incluindo as inválidas depois do \\0 final. Na saída, os valores \\n e \\0 são verificados para serem apresentados de forma coerente, enquanto quaisquer caracteres não imprimíveis são apresentados como ??. Para visualização, o vetor foi definido com tamanho 25. Tudo que está depois do \\0 é, naturalmente, lixo.\nPode-se observar que depois da leitura, a posição 5 contém o \\n e a 6 o \\0 final. Depois da eliminação do \\n, há um \\0 na posição 5, fazendo com que o conteúdo válido seja somente as posições de 0 a 4.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Manipulação de dados textuais"
    ]
  },
  {
    "objectID": "linguagem-c/conversoes-de-dados-textuais.html",
    "href": "linguagem-c/conversoes-de-dados-textuais.html",
    "title": "Conversões de dados textuais",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/conversoes-de-dados-textuais.html#sscanf-e-sprintf",
    "href": "linguagem-c/conversoes-de-dados-textuais.html#sscanf-e-sprintf",
    "title": "Conversões de dados textuais",
    "section": "sscanf e sprintf",
    "text": "sscanf e sprintf"
  },
  {
    "objectID": "linguagem-c/conversoes-de-dados-textuais.html#outras-funções-de-conversão",
    "href": "linguagem-c/conversoes-de-dados-textuais.html#outras-funções-de-conversão",
    "title": "Conversões de dados textuais",
    "section": "Outras funções de conversão",
    "text": "Outras funções de conversão"
  },
  {
    "objectID": "linguagem-c/regras-de-escopo-com-modularizacao.html",
    "href": "linguagem-c/regras-de-escopo-com-modularizacao.html",
    "title": "Regras de escopo com a modularização",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEste capítulo estende os conceitos de escopo de validade das declarações na linguagem C. A ?@sec-declaracoes-e-validade abordou as declarações de variáveis internas (locais) a main, enquanto na ?@sec-escopo-da-declaracao-de-funcoes. Esses assuntos são revisitados e integrados.\nAlém de variáveis e funções, há outros elementos em C que podem ser declarados. Esses não serão cobertos diretamente neste texto e, em grande parte, a discussão exposta aqui também se aplica a eles.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Regras de escopo com a modularização"
    ]
  },
  {
    "objectID": "linguagem-c/regras-de-escopo-com-modularizacao.html#local-times-global",
    "href": "linguagem-c/regras-de-escopo-com-modularizacao.html#local-times-global",
    "title": "Regras de escopo com a modularização",
    "section": "Local \\(\\times\\) global",
    "text": "Local \\(\\times\\) global\nUm código fonte escrito em C contém declarações, sejam de funções ou de variáveis. Esse código fonte está contido em um arquivo texto, usualmente com extensão .c.\nQualquer função declarada no arquivo tem escopo global, o que quer dizer que sua validade vai desde a linha em que ocorre a declaração até a última linha do arquivo. Em outras palavras, essa função é conhecida e pode ser usada dentro de seu escopo de declaração. Essa regra aplica-se tanto à declaração simples, na forma de protótipo de função, quanto às implementações sem o protótipo (?@sec-escopo-da-declaracao-de-funcoes).\nOutra forma de olhar para essa questão é considerar global qualquer declaração feita fora de uma função.\nComo existe o conceito de “fora de uma função”, também há o de “dentro de uma função”. Assim, variáveis declaradas no corpo da implementação de uma função estão dentro da função e são chamadas de declarações locais. O termo se aplica também aos parâmetros formais da função.\n\nValidade das declarações globais e locais\nPara exemplificar tanto declarações globais quanto locais quanto suas validades, segue um programa para simplificação de números racionais, o qual emprega uma função para o cálculo do máximo divisor comum (MDC) entre dois números inteiros e outra para o cálculo do valor absoluto (módulo, \\(\\lvert n\\rvert\\)) de um inteiro. O objetivo do programa é simplificar um número racional, lembrando que \\(q \\in \\mathbb{Q}\\) é um valor expresso na forma \\(a/b\\), sendo \\(a \\in \\mathbb{Z}\\) com \\(b \\in \\mathbb{Z}^*\\).\nA lógica de modificação do número racional é apresentada no Algoritmo 1.\n\n\nAlgoritmo 1: Leitura e apresentação de números racionais.\n\n\n\nA codificação em C é apresentada na sequência.\n/*\n * Leitura e escrita de um número racional na forma de fração\n * Requer: a digitação de um valor a/b, a,b inteiros, b != 0\n * Assegura: apresentação do mesmo valor em forma simplificada e padronizada\n */\n#include &lt;stdio.h&gt;\n\n/*!\n * Retorna o MDC de dois inteiros quaisquer (máximo divisor comum).\n * @param n1: primeiro valor\n * @param n2: segundo valor\n * @return MDC(n1, n2)\n */\nunsigned int mdc(int n1, int n2);\n\n/*!\n * Retorna o valor absoluto de um inteiro\n * @param n: valor inteiro\n * @return o valor absoluto do número, |n|\n */\nint valor_absoluto(int n);\n\n/*\n * Main\n */\nint main() {\n    // Leitura\n    printf(\"Digite um número racional a/b (a e b inteiros e b não nulo): \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    int numerador, denominador;\n    sscanf(entrada, \"%d/%d\", &numerador, &denominador);\n\n    // Simplificação da fração e colocação do sinal no numerador\n    if (numerador == 0)\n        denominador = 1;  // o valor zero é padronizado para 0/1\n    else {\n        int fator_divisao = mdc(numerador, denominador);\n        int sinal_da_fracao = ((double)numerador / denominador &gt;= 0) ? 1 : -1;\n        numerador = valor_absoluto(numerador);\n        denominador = valor_absoluto(denominador);\n        numerador /= sinal_da_fracao * fator_divisao;\n        denominador /= fator_divisao;\n    }\n\n    // Resultado\n    printf(\"O racional digitado foi: %d/%d.\\n\", numerador, denominador);\n\n    return 0;\n}\n\n// Máximo divisor comum: MDC(n1, n2)\nunsigned int mdc(int n1, int n2) {\n    // Converte n1 e n2 para valores positivos\n    n1 = valor_absoluto(n1);\n    n2 = valor_absoluto(n2);\n\n    // Resolução pelo método de Euclides\n    int resto;\n    do {\n        resto = n1 % n2;\n        n1 = n2;\n        n2 = resto;\n    } while (resto != 0);\n\n    return n1;  // Contém o MDC no final\n}\n\n// Valor absoluto de um inteiro\nint valor_absoluto(int n) {\n    return (n &gt;= 0) ? n : -n;\n}\nDigite um número racional a/b (a e b inteiros e b não nulo): -3553/-627\nO racional digitado foi: 17/3.\nPara esse programa, há declarações tanto de variáveis quanto de funções. A Tabela 1 apresenta as declarações de interesse no programa e destaca o escopo e validade (linhas do código) de cada uma.\n\n\n\nTabela 1: Declarações relevantes feitas no programa de apresentação de números racionais, seu tipo, escopo e linhas em que são válidas.\n\n\n\n\n\n\n\n\n\n\n\n\nDeclaração\nTipo\nEscopo\nInício\nFim\n\n\n\n\nmdc\nfunção\nglobal\n14\n68\n\n\nvalor_absoluto\nfunção\nglobal\n21\n68\n\n\nentrada\nvariável\nlocal (main)\n29\n46\n\n\nnumerador, denominador\nvariável\nlocal (main)\n31\n46\n\n\nfator_divisao\nvariável\nlocal (main)\n35\n46\n\n\nsinal_da_fracao\nvariável\nlocal (main)\n36\n46\n\n\nn1, n2\nparâmetro\nlocal (mdc)\n49\n63\n\n\nresto\nvariável\nlocal (mdc)\n55\n63\n\n\nn\nparâmetro\nlocal (valor_absoluto)\n66\n68\n\n\n\n\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nÉ interessante apontar que n1 e n2 na linha 14, assim como n na linha 21 do programa apresentado não possuem validade, pois o protótipo de uma função é apenas sua declaração e, como tal, seus parâmetros não são realmente criados, mas apenas informados ao compilador.\nNa prática, a linha 14 do código do programa poderia ser escrita como segue, mas com o prejuízo de reduzir as informações de documentação do programa ao não informar semanticamente a que cada parâmetro se refere.\nunsigned int mdc(int, int);  // o nome dos parâmetros é irrelevante, mas sua\n                             // omissão prejudica a documentação e legibilidade",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Regras de escopo com a modularização"
    ]
  },
  {
    "objectID": "linguagem-c/regras-de-escopo-com-modularizacao.html#reuso-de-identificadores",
    "href": "linguagem-c/regras-de-escopo-com-modularizacao.html#reuso-de-identificadores",
    "title": "Regras de escopo com a modularização",
    "section": "Reuso de identificadores",
    "text": "Reuso de identificadores\nNos programa em C é possível usar um mesmo identificador desde que eles suas declarações atendam escopos diferentes. Dessa forma, um identificador p pode ser parâmetro para diversas funções diferentes. Da mesma forma, uma variável local a uma função não conflita com qualquer outra declaração. O compilador reclamará, assim, apenas de duas declarações globais com mesmo identificador ou então o uso de um mesmo nome em duplicidade no mesmo contexto local.\nA seguir é apresentado um código fonte genérico, não realiza qualquer processamento útil, O objetivo é indicar como identificadores iguais são tratados.\n/*\n * Programa exemplo de declarações\n */\n#include &lt;stdio.h&gt;\n\nint f1(int a, int b);\n\ndouble f2(double a);\n\nint f3(double f1, double f2);\n\nint main(void) {\n    int a, b, c;\n    double d = 1.25;\n\n    a = (int)f2(d);\n    b = f3(d, 0.5 * a);\n    c = f1(a, b);\n\n    printf(\"%d %d %d %g\\n\", a, b, c, d);\n\n    return 0;\n}\n\nint f1(int a, int b) {\n    int n = f3(a, b);\n    return a + b + n;\n}\n\ndouble f2(double a) {\n    int n = 1;\n    double b = f1(a, n);\n    return b;\n}\n\nint f3(double f1, double f2) {\n    int main = (int)f1 + (int)f2;\n    return main;\n}\n4 3 14 1.25\nOs pontos que requerem atenção neste programa são os seguintes:\n\nAs funções f1, f2 e f3 têm validade em praticamente todo o programa;\nAmbas as funções f1 e f2 possuem parâmetro com identificador a, mas eles são independentes pois estão em escopos diferentes;\nA função principal main também possui variáveis locais a e b, também disjuntas dos parâmetros e outras declarações locais;\nTanto f1 quanto f2 possuem variáveis locais chamadas n, sendo elas completamente separadas dado seu escopo local diferente;\nA função f1 chama f3, que é conhecida dado o escopo global, sendo que o mesmo ocorre com a chamada de f1 em f2;\nf3 possui parâmetros f1 e f2, cujos nomes se sobrepõem às funções globais f1 e f2, significando que, dentro de f3, essas funções não estão acessíveis pois são obscurecidas pelas declarações locais;\nf3 possui uma variável local main, que não conflita com a função global com mesmo nome.\n\nDessa forma, seguem algumas orientações gerais de escopo:\n\nDeclarações globais valem em todo o código fonte a partir de sua declaração;\nParâmetros e declarações em funções são locais, têm apenas validade no escopo da função e são independentes de qualquer outra declaração com mesmo nome em escopo maior;\nDeclarações locais podem se sobrepor e ocultar declarações globais;\nBlocos de comandos podem ter declarações cujo escopo é o próprio bloco apenas (?@sec-declaracoes-e-validade).",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Regras de escopo com a modularização"
    ]
  },
  {
    "objectID": "linguagem-c/regras-de-escopo-com-modularizacao.html#variáveis-globais",
    "href": "linguagem-c/regras-de-escopo-com-modularizacao.html#variáveis-globais",
    "title": "Regras de escopo com a modularização",
    "section": "Variáveis globais",
    "text": "Variáveis globais\nAssim como funções, também variáveis podem ser globais. Uma variável declarada fora do escopo de qualquer função é uma variável global e, como tal, tem sua validade definida e conhecida desde a linha em que é declarada até o final do arquivo.\nVariáveis declaradas como globais possuem duas diferenças importantes em relação às locais, sejam variáveis ou parâmetros de funções:\n\nLocal e momento de criação;\nIniciação automática.\n\nA primeira diferença, portanto, é que as variáveis globais são criadas juntamente com a execução do programa e possuem um espaço de memória específico para elas. As variáveis locais e os parâmetros são criados apenas no momento em que a função é chamada e, dependendo de quando isso ocorre, podem ser criadas em diferentes locais da memória dependendo da chamada.\nVariáveis globais são consideradas estáticas enquanto as locais são criadas dinamicamente em função do momento em que as funções são chamadas\nO segundo ponto é que as variáveis locais nunca possuem lixo, ou seja, são sempre iniciadas com valores nulos. Assim, se uma variável global int i é criada sem atribuição, seu valor será necessariamente zero. Caso exista um double d global, o valor de d será 0,0, exceto se houver outro valor inicial. De forma similar, se uma cadeia de caracteres for criada em escopo global com char s[100], ela terá comprimento zero, pois todas suas posições terão \\0.\n\nDeclaração de variáveis globais\nPara que uma variável seja global, basta que sua declaração seja feita fora de uma função. Segue um exemplo simples em que foi criado um contador global para monitorar o número de vezes que uma\n/*\n * Programa exemplo com variável global\n * O código cria duas funções, volta_igual e volta_negativo, mantendo\n *      controle sobre o número de vezes que elas são chamadas\n * Assegura: apresentações diversas do uso da função e do número de vezes\n *      em que foram chamadas\n */\n#include &lt;stdio.h&gt;\n\n//! Contador para uso global\nint numero_chamadas;\n\n/*!\n * Retorna igual ao que foi passado\n * @param n\n * @return n\n */\nint volta_igual(int n);\n\n/*!\n * Retorna o oposto do que foi passado\n * @param n\n * @return -n\n */\nint volta_negativo(int n);\n\n/*\n * Main\n */\nint main(void) {\n    printf(\"%d = %d.\\n\", 10, volta_igual(10));\n    printf(\"%d = -1 * %d.\\n\\n\", -10, volta_negativo(-10));\n    for (int n = -5; n &lt;= 5; n++)\n        printf(\"%d = %d = -1 * %d.\\n\", n, volta_igual(n), volta_negativo(n));\n\n    printf(\"\\nAs funções volta_igual e volta_negativo foram chamadas %d \"\n           \"vezes no total.\\n\", numero_chamadas);\n    return 0;\n}\n\n// Retorna igual\nint volta_igual(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return n;\n}\n\n// Retorna negativo\nint volta_negativo(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return -n;\n}\n10 = 10.\n-10 = -1 * 10.\n\n-5 = -5 = -1 * 5.\n-4 = -4 = -1 * 4.\n-3 = -3 = -1 * 3.\n-2 = -2 = -1 * 2.\n-1 = -1 = -1 * 1.\n0 = 0 = -1 * 0.\n1 = 1 = -1 * -1.\n2 = 2 = -1 * -2.\n3 = 3 = -1 * -3.\n4 = 4 = -1 * -4.\n5 = 5 = -1 * -5.\n\nAs funções volta_igual e volta_negativo foram chamadas 24 vezes no total.\nA variável numero_chamadas é global e seu escopo de validade se inicia na linha de declaração, de forma que ela pode ser usada em todas as funções seguintes, incluindo main. Como ela é global e não há iniciação explícita, seu valor inicial é zero. Cada vez que as funções volta_igual e volta_negativo são chamadas, essa variável é incrementada.\n\n\nQuando usar variáveis globais?\nA resposta rápida e curta para a pergunta do título da seção é simples: nunca. Claro que “nunca” é um exagero, pois há exceções. O ponto é sempre que qualquer variável global deve ser evitada, pois pode induzir a erros no código extremamente difíceis de serem localizados.\nO exemplo do contador de chamadas pode, talvez, ser caracterizado como uma exceção. O programa é pequeno e o uso da variável global para o contador oculta a contagem separando-a do uso da função. Se outro programador fizer modificações no programa, ele poderia até ignorar a contagem e usar as duas funções definidas sem problemas.\nO problema do uso de variáveis locais, entretanto, é exatamente alguém fazer uma modificação no programa e, por um descuido simples, interferir inadvertidamente no valor de uma variável que ele nem sabia que existia.\nPara exemplificar, suponha que seja solicitado a outro programador uma pequena modificação na função main: a inclusão de uma série de exemplos de chamadas à função volta_negativo antes dos exemplos já existentes. O programa seguinte mostra a solução feita rapidamente pelo novo programador.\n/*\n * Programa exemplo com variável global\n * O código cria duas funções, volta_igual e volta_negativo, mantendo\n *      controle sobre o número de vezes que elas são chamadas\n * Assegura: apresentações diversas do uso da função e do número de vezes\n *      em que foram chamadas\n */\n#include &lt;stdio.h&gt;\n\n//! Contador para uso global\nint numero_chamadas;\n\n/*!\n * Retorna igual ao que foi passado\n * @param n\n * @return n\n */\nint volta_igual(int n);\n\n/*!\n * Retorna o oposto do que foi passado\n * @param n\n * @return -n\n */\nint volta_negativo(int n);\n\n/*\n * Main\n */\nint main(void) {\n    // Exemplos novos para volta_negativo\n    int numero_chamadas;\n    for (numero_chamadas = 10; numero_chamadas &gt;= 0; numero_chamadas--)\n        printf(\"&gt; volta_negativo(%d) = %d.\\n\", numero_chamadas,\n               volta_negativo(numero_chamadas));\n\n    // Código com os exemplos orginais\n    printf(\"%d = %d.\\n\", 10, volta_igual(10));\n    printf(\"%d = -1 * %d.\\n\\n\", -10, volta_negativo(-10));\n    for (int n = -5; n &lt;= 5; n++)\n        printf(\"%d = %d = -1 * %d.\\n\", n, volta_igual(n), volta_negativo(n));\n\n    printf(\"\\nAs funções volta_igual e volta_negativo foram chamadas %d \"\n           \"vezes no total.\\n\", numero_chamadas);\n    return 0;\n}\n\n// Retorna igual\nint volta_igual(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return n;\n}\n\n// Retorna negativo\nint volta_negativo(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return -n;\n}\n&gt; volta_negativo(10) = -10.\n&gt; volta_negativo(9) = -9.\n&gt; volta_negativo(8) = -8.\n&gt; volta_negativo(7) = -7.\n&gt; volta_negativo(6) = -6.\n&gt; volta_negativo(5) = -5.\n&gt; volta_negativo(4) = -4.\n&gt; volta_negativo(3) = -3.\n&gt; volta_negativo(2) = -2.\n&gt; volta_negativo(1) = -1.\n&gt; volta_negativo(0) = 0.\n10 = 10.\n-10 = -1 * 10.\n\n-5 = -5 = -1 * 5.\n-4 = -4 = -1 * 4.\n-3 = -3 = -1 * 3.\n-2 = -2 = -1 * 2.\n-1 = -1 = -1 * 1.\n0 = 0 = -1 * 0.\n1 = 1 = -1 * -1.\n2 = 2 = -1 * -2.\n3 = 3 = -1 * -3.\n4 = 4 = -1 * -4.\n5 = 5 = -1 * -5.\n\nAs funções volta_igual e volta_negativo foram chamadas -1 vezes no total.\nO programa foi compilado com sucesso, sem erros e sem avisos. Porém o resultado agora está incorreto. Uma vez criada a variável local numero_chamadas, ela se sobrepõe à global. No último printf, o valor mostrado para a contagem é o da nova variável local e não mais o do contador global, produzindo um resultado inconsistente, provavelmente de fácil detecção, já que o novo resultado é incongruente.\nUm erro mais sutil poderia ser introduzido, gerando uma situação em que o programa afirma que 11 = -10.\n/*\n * Programa exemplo com variável global\n * O código cria duas funções, volta_igual e volta_negativo, mantendo\n *      controle sobre o número de vezes que elas são chamadas\n * Assegura: apresentações diversas do uso da função e do número de vezes\n *      em que foram chamadas\n */\n#include &lt;stdio.h&gt;\n\n//! Contador para uso global\nint numero_chamadas;\n\n/*!\n * Retorna igual ao que foi passado\n * @param n\n * @return n\n */\nint volta_igual(int n);\n\n/*!\n * Retorna o oposto do que foi passado\n * @param n\n * @return -n\n */\nint volta_negativo(int n);\n\n/*\n * Main\n */\nint main(void) {\n    // Exemplo adicional \n    numero_chamadas = 10;\n    printf(\"&gt; volta_negativo(%d) = %d.\\n\", numero_chamadas,\n           volta_negativo(numero_chamadas));\n\n    // Código com os exemplos originais\n    printf(\"%d = %d.\\n\", 10, volta_igual(10));\n    printf(\"%d = -1 * %d.\\n\\n\", -10, volta_negativo(-10));\n    for (int n = -5; n &lt;= 5; n++)\n        printf(\"%d = %d = -1 * %d.\\n\", n, volta_igual(n), volta_negativo(n));\n\n    printf(\"\\nAs funções volta_igual e volta_negativo foram chamadas %d \"\n           \"vezes no total.\\n\", numero_chamadas);\n    return 0;\n}\n\n// Retorna igual\nint volta_igual(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return n;\n}\n\n// Retorna negativo\nint volta_negativo(int n) {\n    numero_chamadas++;  // conta a chamada à função\n    return -n;\n}\n&gt; volta_negativo(11) = -10.\n10 = 10.\n-10 = -1 * 10.\n\n-5 = -5 = -1 * 5.\n-4 = -4 = -1 * 4.\n-3 = -3 = -1 * 3.\n-2 = -2 = -1 * 2.\n-1 = -1 = -1 * 1.\n0 = 0 = -1 * 0.\n1 = 1 = -1 * -1.\n2 = 2 = -1 * -2.\n3 = 3 = -1 * -3.\n4 = 4 = -1 * -4.\n5 = 5 = -1 * -5.\n\nAs funções volta_igual e volta_negativo foram chamadas 35 vezes no total.\nEm programas mais longos, mais complexos e com muitas funções, diagnosticar problemas com variáveis globais pode ser uma tarefa árdua e desmotivante.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Regras de escopo com a modularização"
    ]
  },
  {
    "objectID": "linguagem-c/recursividade.html",
    "href": "linguagem-c/recursividade.html",
    "title": "c-recursividade.qmd",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nc-recursividade.qmd\nEm construção…"
  },
  {
    "objectID": "linguagem-c/modularizacao-com-struct.html",
    "href": "linguagem-c/modularizacao-com-struct.html",
    "title": "Modularização com struct",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/modularizacao-com-struct.html#registros-como-parâmetros",
    "href": "linguagem-c/modularizacao-com-struct.html#registros-como-parâmetros",
    "title": "Modularização com struct",
    "section": "Registros como parâmetros",
    "text": "Registros como parâmetros"
  },
  {
    "objectID": "linguagem-c/modularizacao-com-struct.html#registros-como-tipo-de-retorno",
    "href": "linguagem-c/modularizacao-com-struct.html#registros-como-tipo-de-retorno",
    "title": "Modularização com struct",
    "section": "Registros como tipo de retorno",
    "text": "Registros como tipo de retorno"
  },
  {
    "objectID": "linguagem-c/index.html",
    "href": "linguagem-c/index.html",
    "title": "Introdução à linguagem C",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nNeste tópico é feita a apresentação da linguagem C, um pouco de suas origens e a evolução de sua especificação. Juntamente a essa introdução, a compilação e os conceitos de código fonte, objeto e executável também são tratados.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#sec-padronizacao-da-linguagem",
    "href": "linguagem-c/index.html#sec-padronizacao-da-linguagem",
    "title": "Introdução à linguagem C",
    "section": "Padronização da linguagem",
    "text": "Padronização da linguagem\nSem uma padronização de facto da linguagem C nos anos seguintes a sua criação, havia uma liberdade grande demais na implementação dos diversos compiladores que apareceram. A especificação conhecida por K&R C era, na ocasião, a única disponível.\nDe 1983 a 1989, o American National Standards Institute (ANSI) formou um grupo de trabalho para a padronização da linguagem, estabelecendo, ao final o padrão conhecido por C89 ou ANSI C. Esse mesmo padrão foi reeditado em 1990, com o rótulo C90, porém sem modificações relevantes na especificação.\nUma extensão foi incorporada à especificação em 1995, com novas definições e adições à biblioteca padrão. Este padrão foi chamado de C95.\nModificações significativas na linguagem foram introduzidas no padrão C99, finalizado em 1999 e adotado a partir do ano 2000. Merecem destaque novos tipos de dados, como long long e _Bool, a incorporação de arranjos de comprimento definido durante a execução, a inclusão de novos cabeçalhos de bibliotecas, a possibilidade de comentários com //, a mistura de declarações e código e funções inline.\nEm 2011 foi publicada a especificação C11, a qual provê suporte a caracteres Unicode, expressões com tipos genéricos (_Generic) e execução paralela multi-plataforma com threads.h.\nO padrão atual para a linguagem C, no momento da escrita deste texto, é o C17, publicado em 2018. O C17 não acrescenta novos recursos à linguagem, porém corrige falhas na versão C11. A especificação C17 também é referenciada como C18.\nNeste ano de 2023 é esperada a próxima edição do padrão da linguagem C, informalmente designado C23.\nA especificação K&R C foi descrita em Ritchie et al. (1978); as demais especificações estão apropriadamente descritas em Wikipedia (2023).",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#sec-programa-minimo",
    "href": "linguagem-c/index.html#sec-programa-minimo",
    "title": "Introdução à linguagem C",
    "section": "Primeiro programa: um programa mínimo (e inútil)",
    "text": "Primeiro programa: um programa mínimo (e inútil)\nPara começar diferente, o primeiro programa exemplo não será o Hello, world!, amplamente utilizado na literatura e em tutoriais. Ele será o código mínimo na linguagem que é válido e coerente. Por ser mínimo, porém, não faz nada útil.\nint main(void) {\n    return 0;\n}\nMesmo sendo minimalista, este código contém vários elementos interessantes:\n\nA função main e seu bloco de comandos\nO comando return\n\nUm bloco de comandos é uma coleção de comandos delimitados por chaves. O nome main é associado a esse bloco de comandos, que contém apenas um comando simples (o return 0;) neste caso. Os tipos int e void indicados não são relevantes neste momento. Chamar o bloco de comandos de main (principal) é obrigatório, pois indica onde a execução do programa começa.\nNeste exemplo, há um único comando dentro de main: return 0;. Este comando indica que, ao ser terminado, o programa devolve ao sistema operacional um valor inteiro, que é um indicador que indica em que condições o programa encerrou sua execução. Por convenção, o valor zero significa que a execução se encerrou sem erros.\nAo ser compilado e executado, este programa apenas indica ao sistema operacional que terminou sem erros.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#segundo-programa-hello-world",
    "href": "linguagem-c/index.html#segundo-programa-hello-world",
    "title": "Introdução à linguagem C",
    "section": "Segundo programa: Hello, world!",
    "text": "Segundo programa: Hello, world!\nO segundo exemplo expande o código anterior, agora para apresentar uma mensagem na tela. Para isso, ele usa uma função chamada printf, responsável por apresentar uma saída formatada.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\nHello, world!\nEste programa, além do printf, também usa a linha #include &lt;stdio.h&gt;. O arquivo stdio.h é um arquivo de cabeçalho (stdio significa standard input and output e .h indica header) e contém informações sobre como o printf deve ser processado pelo compilador. Este arquivo de cabeçalho descreve uma série de funções para entradas e saídas feitas pelos programas.\nO argumento do printf é o texto Hello, world!. Em C, textos são sempre especificados entre aspas duplas. No exemplo, \\n é um indicador para mudar para a linha seguinte.\nUm outro detalhe no código ainda pode ser destacado: cada comando simples é terminado com um ponto e vírgula, que é o caso tanto do printf quanto do return.\nNa sequência é apresentada a versão definitiva do código do Hello, world!.\n/*\nPrograma \"Hello, world\": código exemplo do clássico primeiro programa em C\n    que apenas apresenta uma mensagem de saudação na tela\nAssegura: a apresentação da mensagem padrão \"Hello, world\"\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\nHello, world!\nEsta versão acrescenta a documentação do código. Qualquer texto colocado entre /* e */ é um comentário e é ignorado completamente pelo compilador ao analisar o código fonte. Os comentários não são para o compilador, mas para humanos que lerão o código do programa.\nNeste caso específico, o comentário tem a função de documentar o propósito do código. Ele fornece uma descrição do propósito do código e dá informações relevantes. O grau de detalhe depende sempre do contexto; códigos simples podem ter documentação mais simples, enquanto programas que fazem parte de um projeto compartilhado entre vários desenvolvedores deve conter as informações necessárias para que todos da equipe os compreendam.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#comandos-simples",
    "href": "linguagem-c/index.html#comandos-simples",
    "title": "Introdução à linguagem C",
    "section": "Comandos simples",
    "text": "Comandos simples\n Um componente estrutural da linguagem é o chamado comando simples. Esse comando de caracteriza por uma instrução individual no código do programa.\nOs comandos simples seguem uma sintaxe também simples.\n\n\n\n\n\n\nComando simples\n\n\n\ninstrução ;\n\n\nNos exemplos dados, cada printf usado para apresentar uma informação e também o return 0 são comandos simples e, desta forma, obrigatoriamente terminados com um ponto e vírgula. A execução do printf é uma instrução, assim como o término da execução indicado pelo return.\nSegue um exemplo simples de programa com alguns comandos simples.\n/*\nApresentação de uma série de mensagens na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bom dia! \");\n    printf(\"Este é um exemplo de \");\n    printf(\"vários comandos simples.\\n\");\n    printf(\"Todos são execuções do printf e todos são finalizados com ';'.\\n\");\n    printf(\"O 'return 0', naturalmente, também é um comando simples.\\n\");\n\n    return 0;\n}\nBom dia! Este é um exemplo de vários comandos simples.\nTodos são execuções do printf e todos são finalizados com ';'.\nO 'return 0', naturalmente, também é um comando simples.\n\n\n\n\n\n\nDica\n\n\n\nEmbora a linguagem C não tenha objeções quando a escrever dois comandos simples em uma única linha do programa, sugere-se forntemente que cada comando tenha sua própria linha.\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nEm C, existe a possibilidade de que o comando simples seja vazio. Para especificá-lo, bastar inserir o ponto e vírgula.\n    printf(\"Um!\");\n    ;  // comando vazio que não faz nada...\n    printf(\"Dois!\");\nResta pensar quando um comando que não faz nada pode ser útil.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#compilação-com-o-gcc",
    "href": "linguagem-c/index.html#compilação-com-o-gcc",
    "title": "Introdução à linguagem C",
    "section": "Compilação com o gcc",
    "text": "Compilação com o gcc\nHá uma diversidade de compiladores para a linguagem C, além de diversos IDEs2 com diferentes facilidades para escrever códigos fonte. Há IDEs que podem ser instalados, como Visual Studio Code3, Code::Blocks4, Visual Studio5 ou Eclipse6, por exemplo, além das disponíveis online, como GDB7 ou Programiz8.\n\n\nNeste livro os programas foram compilados invocando no terminal o compilador GNU GCC9 na versão mais recente disponível no repositório oficial do Debian.\n$ gcc --version\ngcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nAs opções -Wall e -pedantic são incluídas automaticamente e ativam uma vasta gama de mensagens de erro e avisos importantes, dando maior controle sobre o código executável que está sendo gerado. A especificação C17 da linguagem C é adotada com a opção -std=c17 (Seção 1.1).\nalias gcc='gcc -Wall -pedantic -std=c17'\n\nPara exemplificar, considere um arquivo com nome bom_dia.c com código fonte seguinte.\n/*\nApresentação um bom dia!\nAssegura: uma mensagem de bom dia apresentada na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bom dia! Que seu dia seja ótimo!\\n\");\n\n    return 0;\n}\nUsando o comando file é possível ver (ou tentar ver) o tipo de informação guardada em um arquivo. Para o caso do código fonte, o arquivo é identificado como C source code, ou seja, código fonte em C.\n$ file bom_dia.c\nbom_dia.c: C source, Unicode text, UTF-8 text\nA compilação pode ser feita com o comando apresentado. A opção -o permite nomear o arquivo executável que é criado.\n$ gcc -Wall -pedantic -std=c17 bom_dia.c -o bom_dia\nEsse comando compila bom_dia.c e gera o arquivo executável bom_dia. No caso de sucesso na compilação, o gcc não apresenta saídas; apenas eventuais problemas são apresentados na tela.\n$ file bom_dia\nbom_dia: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically \nlinked, interpreter /lib64/ld-linux-x86-64.so.2, \nBuildID[sha1]=87d67e99709397eb27df650972aaab8300baf796, for GNU/Linux 3.2.0, \nnot stripped\nA execução de file, nesse caso, apresenta muita informação. A relevante, neste momento, é que o arquivo contém um ELF 64-bit LSB pie executable, o que quer dizer que é um programa executável.\nNa sequência é apresentada a execução do programa bom_dia.\n$ ./bom_dia\nBom dia! Que seu dia seja ótimo!",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#erros-de-sintaxe",
    "href": "linguagem-c/index.html#erros-de-sintaxe",
    "title": "Introdução à linguagem C",
    "section": "Erros de sintaxe",
    "text": "Erros de sintaxe\nSendo uma linguagem de programação, os comandos são sempre analisados de forma rígida. A falta de um parêntese, um espaço no lugar errado ou uma grafia errada (como prinft, por exemplo) já dá margem para o compilador reclamar que algo está errado e se recusar a gerar o executável. Esses são os erros de sintaxe e é função do compilador encontrá-los.\nO programador deve aprender a ler as mensagens de erro produzidas pelo compilador e interpretá-las, permitindo a remoção dos erros sintáticos.\nComo exemplo, segue uma versão incorreta do programa exemplo. Nela, “acidentalmente” o ponto e vírgula foi esquecido.\n/*\nPrograma \"Hello, world\": código exemplo do clássico primeiro programa em C\n    que apenas apresenta uma mensagem de saudação na tela\nAssegura: a apresentação da mensagem padrão \"Hello, world\"\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n\")\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:9:30: error: expected ‘;’ before ‘return’\n    9 |     printf(\"Hello, world!\\n\")\n      |                              ^\n      |                              ;\n   10 |     return 0;\n      |     ~~~~~~                    \nA mensagem de erro aponta em que linha e coluna deveria haver um ponto e vírgula.\nOs erros são apresentados conforme o compilador consegue detectar, apresentando mensagens tão boas quanto possível. Além disso, uma única falha pode desencadear uma sequência de erros, como no exemplo seguinte, na qual apenas faltou fechar as aspas no argumento da função printf.\n/*\nPrograma \"Hello, world\": código exemplo do clássico primeiro programa em C\n    que apenas apresenta uma mensagem de saudação na tela\nAssegura: a apresentação da mensagem padrão \"Hello, world\"\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello, world!\\n);\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:9:12: warning: missing terminating \" character\n    9 |     printf(\"Hello, world!\\n);\n      |            ^\nmain.c:9:12: error: missing terminating \" character\n    9 |     printf(\"Hello, world!\\n);\n      |            ^~~~~~~~~~~~~~~~~~\nmain.c:10:5: error: expected expression before ‘return’\n   10 |     return 0;\n      |     ^~~~~~\nmain.c:10:14: error: expected ‘;’ before ‘}’ token\n   10 |     return 0;\n      |              ^\n      |              ;\n   11 | }\n      | ~",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#erros-de-lógica",
    "href": "linguagem-c/index.html#erros-de-lógica",
    "title": "Introdução à linguagem C",
    "section": "Erros de lógica",
    "text": "Erros de lógica\nUm programa pode ser compilado e gerar o executável sem erros ou qualquer tipo de aviso que o compilador esteja ajustado para dar. Mas apesar disso, a execução não produz o resultado desejado. Neste caso, mesmo com a sintaxe correta, as instruções contém um erro (uma falha de cálculo, uma comparação equivocada) que invalida o programa. Esse são os erros de lógica e, desta vez, cabe ao programador encontrá-los e corrigi-los.\nA evitação de erros de lógica é considerada ao longo de todo o livro.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/index.html#footnotes",
    "href": "linguagem-c/index.html#footnotes",
    "title": "Introdução à linguagem C",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nComo diria Chicó, em Auto da Compadecida, peça de teatro de Ariano Suassuna também retratada em uma minissérie de televisão.↩︎\nUm ambiente de desenvolvimento integrado, ou integrated development environment (IDE), é um programa que dá suporte para escrever programas, provendo um editor de texto dedicado, destaque de sintaxe (diferentes elementos do programa aparecem em cores diferenciadas), acesso ao compilador com o clique de um botão ou uma combinação simples no teclado.↩︎\nVisual Studio Code: https://code.visualstudio.com.↩︎\nCode::Blocks: https://www.codeblocks.org.↩︎\nVisual Studio: https://visualstudio.microsoft.com.↩︎\nEclipse: https://www.eclipse.org.↩︎\nGDB Online: https://www.onlinegdb.com.↩︎\nProgramiz: https://www.programiz.com.↩︎\nGnu Compiler Collection: https://gcc.gnu.org.↩︎",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Introdução à linguagem C"
    ]
  },
  {
    "objectID": "linguagem-c/tipos-de-dados.html",
    "href": "linguagem-c/tipos-de-dados.html",
    "title": "Tipos de dados primitivos",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nQualquer linguagem de programação, dentre as milhares existentes, têm como premissa a manipulação e a transformação de dados. Esta parte do texto trata de como dados são representados em computação e faz uma apresentação dos principais tipos de dados usados na linguagem C.\nA ilustração dos tipos de dados, suas limitações e principais características envolvem, adicionamente, a apresentação da função printf, responsável por apresentar os dados do programa para o usuário.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Tipos de dados primitivos"
    ]
  },
  {
    "objectID": "linguagem-c/tipos-de-dados.html#footnotes",
    "href": "linguagem-c/tipos-de-dados.html#footnotes",
    "title": "Tipos de dados primitivos",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nExistem outras estratégias para representação de caracteres, principalmente para incorporar acentuações (como ñ do espanhol), caracteres particulares (ß do alemão) ou ainda caracteres como os japoneses e hebraicos.↩︎",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Tipos de dados primitivos"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html",
    "title": "Organização do código fonte",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nAbelson e Sussman (1996) escreveram uma vez que “programas devem ser escritos para que humanos os leiam e para que, somente como consequência, máquinas os executem”1. Em outras palavras, compiladores não ligam para como os programas são escritos, para os nomes das variáveis nem para o bom ou mau gosto do programador. Programas apenas são compilados e executados.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html#documentação",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html#documentação",
    "title": "Organização do código fonte",
    "section": "Documentação",
    "text": "Documentação\nA primeira etapa para se ter um bom código fonte passa longe do código C em si. Ela consiste em ter, no início do código, um comentário com a descrição do conteúdo do arquivo.\n Esse comentário estabelece a documentação do código e deve conter uma descrição de seu propósito e de seu contexto, bem como as condições necessárias para sua utilização e execução. Seguem, a título de exemplo, documentações encontradas no Github2.\nArquivo sysctl.c3:\n/*\n * sysctl wrapper for library version of Linux kernel\n * Copyright (c) 2015 INRIA, Hajime Tazaki\n *\n * Author: Mathieu Lacage &lt;mathieu.lacage@gmail.com&gt;\n *         Hajime Tazaki &lt;tazaki@sfc.wide.ad.jp&gt;\n */\nArquivo ubsan.c4\n// SPDX-License-Identifier: GPL-2.0-only\n/*\n * UBSAN error reporting functions\n *\n * Copyright (c) 2014 Samsung Electronics Co., Ltd.\n * Author: Andrey Ryabinin &lt;ryabinin.a.a@gmail.com&gt;\n */\nArquivo seg6.py5:\n/*\n *  SR-IPv6 implementation\n *\n *  Author:\n *  David Lebrun &lt;david.lebrun@uclouvain.be&gt;\n *\n *\n *  This program is free software; you can redistribute it and/or\n *    modify it under the terms of the GNU General Public License\n *    as published by the Free Software Foundation; either version\n *    2 of the License, or (at your option) any later version.\n */\nArquivo writing_a_custom_training_loop_in_tensorflow.py6 (em Python):\n\"\"\"\nTitle: Writing a training loop from scratch in TensorFlow\nAuthor: [fchollet](https://twitter.com/fchollet)\nDate created: 2019/03/01\nLast modified: 2023/06/25\nDescription: Writing low-level training & evaluation loops in TensorFlow.\nAccelerator: None\n\"\"\"\nO conteúdo e o nível de detalhe de cada comentário depende do programador, das regras da empresa em que trabalha ou da equipe envolvida, entre outros muitos fatores.\nNeste livro, os programas são sempre precedidos por um comentário contendo:\n\nO propósito do programa;\nAs pré e pós-condições a que o código atende.\n\nSegue um exemplo simples desta forma de documentação.\n/*\nCálculo de juros compostos\nRequer: o capital investido, a taxa de juros (a.m.) e o tempo\n    de investimento em meses\nAssegura: o montante final da transação\n*/\nCom base nessa descrição, que é relativamente simples, não é necessário olhar os comandos do programa para se saber a que ele se propõe, o que ele requer para ser executado e qual o resultado que apresentará ao final.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html#organização-visual",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html#organização-visual",
    "title": "Organização do código fonte",
    "section": "Organização visual",
    "text": "Organização visual\nO código fonte de um programa é escrito para que outros programadores (ou seja, pessoas) leiam e entendam os comandos e a intenção do programador.\nSegue um programa em C válido. Sua qualidade, entretanto, é discutível e é apenas uma nova versão do código que implementa o Algoritmo 1.\n/*\nCálculo e apresentação das raízes reais de uma equação de segundo grau na\n    forma ax^2 + bx + c = 0\nRequer: Os coeficientes a, b e c da equação\nAssegura: as raízes reais da equação; ou mensagem que a equação é\n    inválida; ou mensagem que não há raízes reais\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main(void) { char entrada[160];printf(\n\"Digite os valores de a, b e c da equação: \"); fgets(entrada, sizeof\nentrada\n\n, stdin); double a, b,           c; sscanf(entrada\n,    \"%lf%lf%lf\" , &    a, &b, &\nc);\nif(a == 0) printf(             \"Não é equação do segundo grau (a = 0).\\n\"    )\n\n; else { double discriminante = pow\n(\nb\n                                                                             ,\n2) - 4 * a * c; if(discriminante &lt;\n0) printf(\"A equação não possui raízes reais.\\n\");\nelse\nif\n(discriminante &lt; 1.0e-10) {  double x = -b / (2*    a\n            ); printf(\"Uma raiz: %g.\\n\", x); } else { double x1 = (-b -\n            sqrt(discriminante)) / (2 * a); double x2 = (-b + \nsqrt(discriminante))\n            / (2 * a); printf(\"Raízes reais: %g e %g.\\n\", x1\n\n,\n \n x2);}}return\n 0;}\nDigite os valores de a, b e c da equação: -2 10 13\nRaízes reais: 6.07071 e -1.07071.\nPara ilustrar a dificuldade que o código, mesmo correto na sua lógica e sintaxe, proporciona quando é mal escrito, considere o problema de localizar a vírgula na expressão pow(b, 2) que calcula \\(b^2\\) para o discriminante.\nSe a ordem dos comandos estiver correta, o compilador entende o que tem que ser feito e gera o código executável sem problemas ou dificuldades. Porém, caso o compilador aponte um erro como seguinte, qual seria a dificuldade de encontrar o problema?\nmain.c: In function ‘main’:\nmain.c:28:62: warning: unused variable ‘x1’ [-Wunused-variable]\n   28 |             ); printf(\"Uma raiz: %g.\\n\", x); } else { double x1 = (-b -\n      |                                                              ^~\nmain.c:31:59: error: ‘x1’ undeclared (first use in this function);\n      |              did you mean ‘x2’?\n   31 |             / (2 * a); printf(\"Raízes reais: %g e %g.\\n\", x1\n      |                                                           ^~\n      |                                                           x2\nmain.c:31:59: note: each undeclared identifier is reported only once for each\n                    function it appears in\nmain.c: At top level:\nmain.c:35:8: error: expected identifier or ‘(’ before ‘return’\n   35 |  x2);}}return\n      |        ^~~~~~\nmain.c:36:4: error: expected identifier or ‘(’ before ‘}’ token\n   36 |  0;}\n      |    ^\nO erro acima foi causado apenas por um } inserido no lugar errado. Todas as outras mensagens são decorrentes desta falha na interpretação, a qual impede a sequência da análise e gera uma cascata de erros.\nEm suma, os programas são para as pessoas lerem.\nNo ?@sec-guia-de-estilo são apresentadas as orientações de escrita seguidas neste livro, mas as seções seguintes introduzem os pontos iniciais, justificando suas importâncias.\nA escrita de um bom programa em C recai, necessariamente, na organização visual do código, ou seja, pela disposição espacial dos comandos, instruções e pontuações ao longo do código.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html#indentação",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html#indentação",
    "title": "Organização do código fonte",
    "section": "Indentação",
    "text": "Indentação\nA indentação é o espaço dado da margem esquerda até o comando e ela serve para indicar a hierarquia dos comandos. Esse recurso visual é essencial para um bom programa e tem sido consistentemente usado em todos os exemplos de programas dados.\nSegue o exemplo simples de um programa que faz conversões de unidades de distância.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\nchar entrada[160];\nprintf(\"Digite uma distância em metros: \");\nfgets(entrada, sizeof entrada, stdin);\ndouble em_metros;\nsscanf(entrada, \"%lf\", &em_metros);\ndouble em_centimetros = em_metros * 100;\nprintf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\ndouble em_pes = em_metros * 3.281;\nprintf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\ndouble em_jardas = em_metros * 1.094;\nprintf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\ndouble em_polegadas = em_metros * 39.37;\nprintf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\nreturn 0;\n}\nO código acima é apresentando sem indentações e isso dificulta enxergar os comandos e até a abrangência do main. O acréscimo da indentação indica um nível para os comandos contidos no bloco da função principal e isso leva à versão seguinte do programa.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\n    char entrada[160];\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n    double em_centimetros = em_metros * 100;\n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    double em_pes = em_metros * 3.281;\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n    double em_jardas = em_metros * 1.094;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n    double em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n    return 0;\n}\nA indentação tem que ser constante para um mesmo nível de comandos, o que leva a que comandos de mesmo nível sempre se iniciem na mesma coluna.\nNo exemplo seguinte há problemas com a declaração da variável entrada, que deveria estar indentada, e também com o conjunto de comandos que realizam as conversões. Neste último caso, estes comandos parecem estar de alguma forma “subordinados” aos comandos anteriores, o que não o caso.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\nchar entrada[160];\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n        double em_centimetros = em_metros * 100;\n        printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n        double em_pes = em_metros * 3.281;\n        printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n        double em_jardas = em_metros * 1.094;\n        printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n        double em_polegadas = em_metros * 39.37;\n        printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n    return 0;\n}\nSegue, por fim, um último péssimo exemplo de indentação, no qual transparece o desleixo do programador.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\nint main(void) {\n char entrada[160];\n    printf(\"Digite uma distância em metros: \");\n   fgets(entrada, sizeof entrada, stdin);\n  double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n        double em_centimetros = em_metros * 100;\n       printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n       double em_pes = em_metros * 3.281;\n       printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n          double em_jardas = em_metros * 1.094;\n        printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n     double em_polegadas = em_metros * 39.37;\n        printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n  return 0;\n}",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html#linhas-de-espaçamento",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html#linhas-de-espaçamento",
    "title": "Organização do código fonte",
    "section": "Linhas de espaçamento",
    "text": "Linhas de espaçamento\nOutro ponto que auxilia uma melhor visualização do código é o uso de linhas em branco, cuja função é separar as diferentes tarefas que o programa tem que cumprir.\nÉ apresentado na sequência o programa de conversão de unidades de distância com o acréscimo de linhas em branco.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    double em_centimetros = em_metros * 100;\n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n\n    double em_pes = em_metros * 3.281;\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n\n    double em_jardas = em_metros * 1.094;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n\n    double em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nUma linha em branco deve ser incluída para separar as linhas com #include do início da função main, o que dá destaque a esta função.\nForam introduzidas linhas em branco dentro do main para isolar, primeiramente, os comandos que fazem a leitura da distância em metros, incluindo mensagem, leitura, declaração da variável e conversão para double. Todos estes comandos são, em essência, “obtenha a distância em metros”.\nOutros blocos que são agrupados são os de cada uma das conversões, com declaração de variável e a escrita do resultado.\nPor último aparece o indicador de sucesso da execução: return 0, também destacado dos demais comandos.\n\n\n\n\n\n\nDica\n\n\n\nAs linhas em branco devem ser, via de regra, apenas uma, devendo ser evitadas duas ou mais linhas separando os grupos de comandos.\n\n\nO agrupamento de comandos depende do programador, de forma que o mesmo código possa ter sua organização conforme o exemplo seguinte.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    double em_centimetros = em_metros * 100;\n    double em_pes = em_metros * 3.281;\n    double em_jardas = em_metros * 1.094;\n    double em_polegadas = em_metros * 39.37;\n \n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nNeste caso, o agrupamento se refere à leitura, seguida pelos cálculos e finalizada pelas apresentações dos resultados.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html#um-comando-por-linha",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html#um-comando-por-linha",
    "title": "Organização do código fonte",
    "section": "Um comando por linha",
    "text": "Um comando por linha\nUma regra básica de clareza é separar os comandos de forma que cada um fique em sua própria linha.\nComo exemplo, o programa de conversão de distâncias foi reescrito de forma a violar essa regra e é apresentado na sequência.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \"); fgets(entrada,\n          sizeof entrada, stdin);\n    double em_metros; sscanf(entrada, \"%lf\", &em_metros);\n\n    double em_centimetros = em_metros * 100; double em_pes = em_metros *\n        3.281; double em_jardas = em_metros * 1.094; double em_polegadas\n        = em_metros * 39.37;\n\n    printf(\"&gt; %.1lfm = %.1fcm\\n&gt; %.1lfm = %.1f pés\\n\", em_metros,\n           em_centimetros, em_metros, em_pes);\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas); printf(\n        \"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\nEssa versão coloca alguns comandos e declarações individuas em uma mesma linha, o que está sintaticamente correto, mas dificulta a visão dos limites entre os diversos elementos.\nÉ importante lembrar que quando os problemas se tornam mais complexos, o código será mais longo e com mais nuances, assim como terá maior número de variáveis. Nesta situação, mais preciosa essa recomendação se torna.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-fonte.html#footnotes",
    "href": "linguagem-c/organizacao-do-codigo-fonte.html#footnotes",
    "title": "Organização do código fonte",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nTradução livre de “programs must be written for people to read, and only incidentally for machines to execute”.↩︎\nGithub: https://github.com.↩︎\nhttps://github.com/libos-nuse/net-next-nuse/blob/46e2206969943ba3fb87441dee0b433624daf35c/arch/lib/sysctl.c.↩︎\nhttps://github.com/KSPP/linux/blob/e0756cfc7d7cd08c98a53b6009c091a3f6a50be6/lib/ubsan.c.↩︎\nhttps://github.com/linux-wpan/linux-wpan-next/blob/107bc0aa95ca572df42da43c30a2079266e992e4/net/ipv6/seg6.c.↩︎\nhttps://github.com/keras-team/keras/blob/419973ee15ecd0e2d085e077399ce3bd5437df15/guides/writing_a_custom_training_loop_in_tensorflow.py.↩︎",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Organização do código fonte"
    ]
  },
  {
    "objectID": "linguagem-c/modularizacao-com-matrizes.html",
    "href": "linguagem-c/modularizacao-com-matrizes.html",
    "title": "Modularização com matrizes",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/modularizacao-com-matrizes.html#matrizes-como-parâmetros",
    "href": "linguagem-c/modularizacao-com-matrizes.html#matrizes-como-parâmetros",
    "title": "Modularização com matrizes",
    "section": "Matrizes como parâmetros",
    "text": "Matrizes como parâmetros"
  },
  {
    "objectID": "linguagem-c/procedimentos.html",
    "href": "linguagem-c/procedimentos.html",
    "title": "Procedimentos",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA modularização envolve as funções, como apresentado no ?@sec-funcoes. Há casos, porém, em que há necessidades de um módulo para realizar uma ação, mas ele não precisa retornar um valor. Módulos que não retornam valores são chamados procedimentos e, em C, são funções que não voltam valor.\nEste capítulo trata das funções sem retorno de valor.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Procedimentos"
    ]
  },
  {
    "objectID": "linguagem-c/procedimentos.html#footnotes",
    "href": "linguagem-c/procedimentos.html#footnotes",
    "title": "Procedimentos",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nA função bzero, embora seja um bom exemplo para este texto, é obsoleta e não deve ser usada.↩︎",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Procedimentos"
    ]
  },
  {
    "objectID": "linguagem-c/define.html",
    "href": "linguagem-c/define.html",
    "title": "Noções do uso do #define",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nNoções do uso do #define\nEm construção…"
  },
  {
    "objectID": "linguagem-c/funcoes.html",
    "href": "linguagem-c/funcoes.html",
    "title": "Funções",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nAs funções são parte essencial do desenvolvimento de qualquer código. Não somente evitam que trabalho extra tenha que ser feito mas também melhoram a qualidade geral do código como um todo. As estruturas e estratégias das funções serão abordadas ao longo deste capítulo.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/funcoes.html#declaração-e-implementação-de-funções-próprias",
    "href": "linguagem-c/funcoes.html#declaração-e-implementação-de-funções-próprias",
    "title": "Funções",
    "section": "Declaração e implementação de funções próprias",
    "text": "Declaração e implementação de funções próprias\nO programador tem como uma grande vantagem poder escrever suas próprias funções e, para isso, precisa fazer sua declaração.\n\n\n\n\n\n\nDeclaração de função\n\n\n\ntipo_de_retorno nome_da_função ( lista_de_parâmetros) ;\n\n\nAs funções precisam ter um nome_da_função (identificador válido), especificar seu tipo_de_retorno e seus parâmetros (lista_de_parâmetros). Declarações de função nesse formato são conhecidos como protótipos da função.\nOs conceitos envolvidos na escrita de funções podem ser ilustrados por uma sequência de tentativas de escrever um programa que usa uma função. Esse programa tem o objetivo de ler um texto qualquer e apresentar o número de vogais presentes (ignorando acentuações).\nSegue a versão do programa sem nenhuma função.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (texto[i] == 'a' || texto[i] == 'e' || texto[i] == 'i' ||\n             texto[i] == 'o' || texto[i] == 'u' || texto[i] == 'A' ||\n             texto[i] == 'E' || texto[i] == 'I' || texto[i] == 'O' ||\n             texto[i] == 'U')\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\nDigite um texto: Comece pelo começo, disse a Rainha a Alice\n\"Comece pelo começo, disse a Rainha a Alice\" possui 18 vogais.\nA linguagem provê funções de verificação do tipo dos caracteres, como isdigit ou isspace (?@tbl-funcoes-para-caractere), entre outras. Porém, entre elas não se inclui uma que verifica as vogais.\nAssim, o objetivo do programa é ter uma função para verificar se um dado caractere é ou não uma vogal. Essa função será nomeada eh_vogal. O código seguinte tenta usar essa função, que até o momento não existe.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:17:13: warning: implicit declaration of function ‘eh_vogal’ \n[-Wimplicit-function-declaration]\n   17 |         if (eh_vogal(texto[i]))\n      |             ^~~~~~~~\n/usr/bin/ld: /tmp/ccixIDte.o: na função \"main\":\nmain.c:(.text+0x99): undefined reference to `eh_vogal'\ncollect2: error: ld returned 1 exit status\nHá dois problemas dignos de destaque no resultado da compilação. O primeiro se refere ao uso de eh_vogal, dando um alerta (warning) de declaração implícita, o que significa que a função não possui declaração e o compilador assumiu um formato padrão. O segundo ponto é o que diz “referência não definida para eh_vogal”, que significa que a função não foi implementada e não existe nenhum código para ela.\nO primeiro ponto a se resolver, portanto, é declarar a função antes de ela ser usada, o que é feito antes da função main. Essa nova versão do programa é a que segue.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\nbool eh_vogal(char caractere);\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\n/usr/bin/ld: /tmp/cch18lvV.o: na função \"main\":\nmain.c:(.text+0x94): undefined reference to `eh_vogal'\ncollect2: error: ld returned 1 exit status\nA declaração é feita por meio de seu protótipo, que indica o tipo, o nome e os parâmetros que a função possui. A prototipagem da função requereu também incluir stdbool.h para poder especificar o tipo de retorno bool.\nbool eh_vogal(char caractere);  // protótipo da função\nVale observar que a compilação do programa foi bem sucedida e todo o código objeto para ele foi criado com êxito. O problema que persiste é que, ao criar o executável, notou-se a ausência da implementação.\nEsse é o problema que a versão final do programa resolve.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\nbool eh_vogal(char caractere);\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\n\n/*!\n * Verificação se um caractere é uma vogal (maiúscula ou minúscula).\n * @param caractere: caractere simples a ser verificado\n * @return true se for vogal, false caso contrário\n */\nbool eh_vogal(char caractere) {\n    bool se_eh_vogal =\n            (caractere == 'a' || caractere == 'e' || caractere == 'i' ||\n             caractere == 'o' || caractere == 'u' || caractere == 'A' ||\n             caractere == 'E' || caractere == 'I' || caractere == 'O' ||\n             caractere == 'U');\n\n    return se_eh_vogal;\n}\nDigite um texto: Comece pelo começo, disse a Rainha a Alice\n\"Comece pelo começo, disse a Rainha a Alice\" possui 18 vogais.\nA função declarada é lógica, retornando um valor bool, o nome escolhido para ela é eh_vogal e ela tem um único parâmetro que é um char denominado caractere.\nPara sua implementação, a função define uma variável booliana local se_eh_vogal que recebe true ou false conforme o resultado da comparação. O valor resultante da função é determinado pela instrução return que, nesse caso, volta o valor booliano. Sempre que return é executado, a função é encerrada e comandos escritos depois dele nunca serão executados.\nO uso da variável local se_eh_vogal é meramente didático pois estabelece dois passos: o cálculo do resultado da função e o retorno desse resultado. Na prática, é mais interessante escrever essa função conforme se segue, sem o uso da variável local e já retornando o valor da expressão.\n/*!\n * Verificação se um caractere é uma vogal (maiúscula ou minúscula).\n * @param caractere: (char) caractere a ser verificado\n * @return true se for vogal, false caso contrário\n */\nbool eh_vogal(char caractere) {\n    return (caractere == 'a' || caractere == 'e' || caractere == 'i' ||\n            caractere == 'o' || caractere == 'u' || caractere == 'A' ||\n            caractere == 'E' || caractere == 'I' || caractere == 'O' ||\n            caractere == 'U');\n}\nPara concluir esta seção é preciso rever dois pontos importantes:\n\nToda função tem que ser declarada antes de ser usada;\nA implementação da função (seu código) tem que ter sido escrito para que executável possa ser criado.\n\nAssim, para o exemplo do contador de vogais, a declaração foi feita na forma de um protótipo, o qual indica para o compilador o tipo de retorno e os parâmetros e respectivos tipos. Com essas informações, as devidas verificações de consistência podem ser realizadas durante a compilação, como verificar se o tipo do parâmetro passado é compatível com o tipo indicado na declaração. A implementação, por sua vez, foi inserida no código fonte logo abaixo de main, fornecendo condições para que eh_vogal possuísse sua implementação e viabilizasse o que se deseja: o executável completo.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/funcoes.html#onde-declarar-a-função",
    "href": "linguagem-c/funcoes.html#onde-declarar-a-função",
    "title": "Funções",
    "section": "Onde declarar a função?",
    "text": "Onde declarar a função?\nHá duas estratégias usuais para declarar funções em C. A primeira é usando protótipos para a declaração e ter a implementação feita posterioriormente. Outra forma é pela inserção direta da implementação, a qual tanto implementa quanto declara a função ao mesmo tempo.\nA segunda forma é apresentada na sequência, como uma versão alternativa do mesmo programa de contagem de vogais.\n/*\nDeterminação da quantidade de vogais em um texto digitado pelo usuário\nRequer: um texto qualquer\nAssegura: apresentação do número de vogais contidas no texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n\n/*!\n * Verificação se um caractere é uma vogal (maiúscula ou minúscula).\n * @param caractere: (char) caractere a ser verificado\n * @return true se for vogal, false caso contrário\n */\nbool eh_vogal(char caractere) {\n    return (caractere == 'a' || caractere == 'e' || caractere == 'i' ||\n            caractere == 'o' || caractere == 'u' || caractere == 'A' ||\n            caractere == 'E' || caractere == 'I' || caractere == 'O' ||\n            caractere == 'U');\n}\n\nint main(void) {\n    printf(\"Digite um texto: \");\n    char texto[160];\n    fgets(texto, sizeof texto, stdin);\n    texto[strlen(texto) - 1] = '\\0';\n\n    int numero_vogais = 0;\n    for (int i = 0; i &lt; (int)strlen(texto); i++)\n        if (eh_vogal(texto[i]))\n            numero_vogais++;\n\n    printf(\"\\\"%s\\\" possui %d %s.\\n\", texto, numero_vogais,\n           numero_vogais &gt; 1 ? \"vogais\" : \"vogal\");\n\n    return 0;\n}\nDigite um texto: Comece pelo começo, disse a Rainha a Alice\n\"Comece pelo começo, disse a Rainha a Alice\" possui 18 vogais.\nNão há uma regra para usar uma forma ou outra, sendo assim uma opção pessoal (exceto quando a empresa ou o cliente possuírem regras específicas).\n\nComo regra geral, este livro adota o uso das declarações de função com protótipos e cuja implementação fica posterior à função main quando estiverem no mesmo arquivo.\n\n\n\n\n\n\nCuriosidade\n\n\n\nÉ interessante notar que, embora a implementação da função eh_vogal tenha sido feita no mesmo arquivo em que estava a função main, ela poderia estar em outro arquivo.\nQuando programas se tornam maiores, é uma prática comum e muito positiva separar as implementações de funções em arquivos separados. Assim, se um programa deve lidar com o processamento de um texto, pode haver um arquivo para as funções que manipulam arquivos, outro para as que manipulam as cadeias de caracteres e assim por diante. Tudo se reflete em organização.\nEsse assunto é abordado no ?@sec-organizacao-do-codigo-separado.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/funcoes.html#sec-escopo-da-declaracao-de-funcoes",
    "href": "linguagem-c/funcoes.html#sec-escopo-da-declaracao-de-funcoes",
    "title": "Funções",
    "section": "Escopo da declaração das funções",
    "text": "Escopo da declaração das funções\nUma discussão prévia sobre declarações e escopo está apresentada na ?@sec-declaracoes-e-validade, tratando da validade de cada variável em um programa. Com a introdução do assunto da modularização, o conceito de escopo se amplia. Qualquer variável usada nos diversos programas possuem sua validade definida internamente a main, ou seja, são locais à função principal e não existem fora dela.\nAo se criar uma nova função, ela é declarada fora da função main e não é, portanto, local. As declarações das funções são sempre globais. A consequência para esse tipo de declaração é que ela é válida da linha do protótipo (ou do cabeçalho de uma função implementada) até o fim do arquivo do código fonte.\nO programa seguinte é apenas um exemplo para o qual comentários pertinentes sobre escopo serão apresentados. Nenhuma função é comentada, visto que são apenas exemplos simples (documentação de funções está na Seção 2.5).\n/*\nPrograma exemplo com funções simples\n*/\n#include &lt;stdio.h&gt;\n\ndouble dobro(double valor);\n\ndouble maximo(double valor1, double valor2);\n\nint somatorio(int n);\n\ndouble um_double(void);\n\nint um_int(void);\n\nint main(void) {\n    printf(\"Quádruplo de 1.77 = %.2lf.\\n\", dobro(dobro(1.77)));\n    printf(\"max(1.2, 7.8) = %.1lf.\\n\", maximo(1.2, 7.8));\n    printf(\"Somatório de 1 até 100 = %d.\\n\", somatorio(100));\n    printf(\"Um: %d e %.1f.\\n\", um_int(), um_double());\n\n    return 0;\n}\n\ndouble dobro(double valor) {\n    double valor_dobrado = 2 * valor;\n\n    return valor_dobrado;\n}\n\ndouble maximo(double valor1, double valor2) {\n    return (valor1 &gt; valor2) ? valor1 : valor2;\n}\n\nint somatorio(int n) {\n    int soma = 0;\n    for (int i = 1; i &lt;= n; i++)\n        soma += i;\n\n    return soma;\n}\n\ndouble um_double(void) {\n    return (double)um_int();\n}\n\nint um_int(void) {\n    return 1;\n}\nQuádruplo de 1.77 = 7.08.\nmax(1.2, 7.8) = 7.8.\nSomatório de 1 até 100 = 5050.\nUm: 1 e 1.0.\nNo programa exemplificado há cinco funções definidas pelo programador: dobro, maximo, somatorio, um_int e um_double. Cada uma delas é declarada por seu respectivo protótipo e, em consequência, possuem validade da linha em que houve a declaração até o final do arquivo do código fonte. Como exemplos, a função dobro é conhecida e pode ser usada da linha 6 até a 49, enquanto somatorio tem validade a partir da linha 10 e também encerrando na linha 49.\nAssim, toda função pode ser usada a partir da linha de sua declaração. Quando se chega à função main, todas as funções já são conhecidas e seu uso é perfeitamente possível.\nUm destaque relevante vai para as funções um_double e um_int, que apenas retornam o valor unitário, um do tipo double, outro do tipo int. No exemplo, a função um_double retorna uma chamada para um_int, a qual já foi declarada por seu protótipo.\nSegue um exemplo para o caso em que as funções têm suas declarações sem prototipagem, ou seja, são declaradas e implementadas antes da função main. A regra de escopo aqui é a mesma e, a título de exemplo, maximo é declarado na linha 12 e pode ser usado desta linha até a 39.\n/*\nPrograma exemplo com funções simples\n*/\n#include &lt;stdio.h&gt;\n\ndouble dobro(double valor) {\n    double valor_dobrado = 2 * valor;\n\n    return valor_dobrado;\n}\n\ndouble maximo(double valor1, double valor2) {\n    return (valor1 &gt; valor2) ? valor1 : valor2;\n}\n\nint somatorio(int n) {\n    int soma = 0;\n    for (int i = 1; i &lt;= n; i++)\n        soma += i;\n\n    return soma;\n}\n\nint um_int(void) {\n    return 1;\n}\n\ndouble um_double(void) {\n    return (double)um_int();\n}\n\nint main(void) {\n    printf(\"Quádruplo de 1.77 = %.2lf.\\n\", dobro(dobro(1.77)));\n    printf(\"max(1.2, 7.8) = %.1lf.\\n\", maximo(1.2, 7.8));\n    printf(\"Somatório de 1 até 100 = %d.\\n\", somatorio(100));\n    printf(\"Um: %d e %.1f.\\n\", um_int(), um_double());\n\n    return 0;\n}\nQuádruplo de 1.77 = 7.08.\nmax(1.2, 7.8) = 7.8.\nSomatório de 1 até 100 = 5050.\nUm: 1 e 1.0.\nUma ressalva importante é feita à função um_double, a qual necessariamente tem que ser declarada depois de um_int, pois essa inversão implicaria no problema de uma função ser desconhecida antes de ser usada. Nesses casos ou a correta ordenação ou a inclusão de um protótipo são soluções válidas.\n\n\n\n\n\n\nCuidado\n\n\n\nA especificação da linguagem C não admite que funções sejam declaradas dentro de outras funções, o chamado aninhamento de declarações. Uma vantagem dessa estratégia é ter uma função que é reconhecida e usada apenas dentro de outra função.\nMuitos compiladores dão, porém, suporte a esse recurso e, assim, torna-se importante ressaltar que o código fonte pode não ser compatível com outros compiladores, outros sistemas ou mesmo com versões futuras.\nAderir aos recursos padronizados oficiais da linguagem é sempre uma boa opção de conduta.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/funcoes.html#funções-com-vários-parâmetros",
    "href": "linguagem-c/funcoes.html#funções-com-vários-parâmetros",
    "title": "Funções",
    "section": "Funções com vários parâmetros",
    "text": "Funções com vários parâmetros\nNão é incomum que uma função precise de mais que um único parâmetro. Por exemplo, pode-se ter uma função que calcule o peso (massa) ideal de uma pessoa conforme seu sexo biológico e sua altura. Essa função poderia ser escrita com a declaração seguinte.\n/*!\n * Determina a massa ideal a partir do sexo biológico e da altura de um\n * indivíduo.\n * @param sexo: o sexo biológio ('F' para feminino, 'M' para masculino) \n * @param altura: a altura da pessoa em metros\n * @return a massa ideal em quilogramas\n */\ndouble massa_ideal(char sexo, double altura);\nQuando há mais que um parâmetro, eles são separados por vírgulas. Na sequência, são apresentadas declarações genéricas e suas interpretações.\ndouble funcao(int a, double b);  // a é int, b é double; retorna double\ndouble funcao(int a, int b);  // a e b são int; retorna double\nbool funcao(bool a, bool b, bool c);  // a, b e c são bool; retorna bool\nint funcao(char *a, char *b, int c, int d);  // a e b são strings; c e d são\n                                             // int; retorna int\n\n\n\n\n\n\nCuidado\n\n\n\nCada um dos parâmetros devem ter seu tipo especificado. Um exemplo interessante é uma função declarada como na sequência.\ndouble funcao(double a, b, c);\nNessa função, o parâmetro a é do tipo double. Porém b e c não possuem tipo e, em consequência, haverá um erro de compilação.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/funcoes.html#sec-documentacao-funcoes",
    "href": "linguagem-c/funcoes.html#sec-documentacao-funcoes",
    "title": "Funções",
    "section": "Documentação",
    "text": "Documentação\nNeste livro as funções são documentadas usando um padrão de formato aceito pelo Doxygen2, que é uma ferramenta para gerar documentação para grandes projetos. No caso dos programas e funções apresentados como exemplos ao longo do texto, o termo “grande projeto”, entretanto, não se aplica, nem tampouco é necessária uma ferramenta para gerar a documentação. Apesar disso, o formato escolhido para a documentação é simples e atende às necessidades.\nA documentação de uma função envolve:\n\nA descrição do que ela faz;\nA apresentação contextualizada dos parâmetros;\nO que a função retorna como resultado.\n\nComo exemplo, segue a declaração da função para o cálculo do fatorial de um valor inteiro.\n/*!\n * Retorna, para um dado n, o valor de n!\n * @param n: valor para o qual seu fatorial é calculado, n &gt;= 0\n * @return n!\n */\nunsigned long int fatorial(unsigned int n);\nNessa declaração, a descrição cobre o que a função faz: retorna o fatorial de um valor \\(n\\) indicado. na lista de parâmetros há um só, denominado n, além de indicar que a função atende corretamente apenas valores naturais. O retorno da função, por sua vez, é o que a função promete devolver, ou seja, \\(n!\\). Os tipos envolvidos tanto no parâmetro quanto para o retorno estão indicados no cabeçalho da função.\nQuando se escreve a documentação, é importante que esteja indicado o que função faz e não como ela o faz. Por exemplo, a descrição não deve conter algo como “por meio de multiplicações sucessivas”, pois isso já se refere ao como. A descrição pode ser curta ou longa, dependendo da necessidade, sempre com foco de indicar como outro programador poderá usar essa função corretamente. Para os parâmetros formais, ou seja, os que ficam entre os parênteses, todos devem ser elencados dentro do contexto da função (indicados com @param). Assim, para o fatorial de um \\({n \\in \\mathbb{N}}\\), o único parâmetro é o \\(n\\) a ser usado, sendo que n &gt;= 0 deixa claro para quais valores a função funciona corretamente[^ressalva-dominio-incorreto]. Para o retorno da função (@return), é indicado tão claramente quanto possível o que é resultado da função.\nA documentação de uma uma função é sempre um elemento importante. Entretanto, documentar absolutamente todas as funções pode ter um efeito inverso ao de proporcionar clareza a um dado código. Funções extremamente simples, que sejam praticamente autoexplicativas, podem ficar sem uma documentação explícita. O mesmo ocorre para funções que são apenas auxiliares para outras funções e não são destinadas para que outros programadores as usem. Nessa última categoria, é interessante ver que sscanf é uma função importante e, portanto, deva ter sua documentação bem estabelecida (o que é verdade, pois possui sua página de manual), mas é possível supor que ela chame outras funções menores para cada conversão de texto para um determinado tipo; essas funções não requerem, necessariamente, uma documentação, já que não foram feitas para serem usadas abertamente.\nNos exemplos dados ao longo deste texto, é possível que funções simples ou auxiliares deixem de ter documentação explícita.\nOs IDEs em geral reconhecem a documentação das funções e auxiliam o programador durante a codificação. Na Figura 1 há um exemplo de como a documentação é mostrada quando se posiciona o mouse sobre o nome da função eh_vogal. Outros auxílios, como verificações dos tipos dos parâmetros também são recursos comuns.\n\n\n\n\n\n\nFigura 1: Auxílio ao programador em IDEs quando as funções são devidamente documentadas. IDE: CLion.",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/funcoes.html#footnotes",
    "href": "linguagem-c/funcoes.html#footnotes",
    "title": "Funções",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nAs funções, tanto matemáticas quanto computacionais, podem ter mais que um argumento (funções de múltiplas variáveis).↩︎\nDoxygen: https://www.doxygen.nl.↩︎\nEmbora 20\\(!\\) não pareça muito, vale lembrar seu valor é 2.432.902.008.176.640.000, ou seja, aproximadamente 2,4 \\(\\times\\) 1018.↩︎",
    "crumbs": [
      "Linguagem C",
      "Modularização e memória",
      "Funções"
    ]
  },
  {
    "objectID": "linguagem-c/alocacao-dinamica-de-memoria-matrizes.html",
    "href": "linguagem-c/alocacao-dinamica-de-memoria-matrizes.html",
    "title": "Alocação dinâmica de matrizes em C",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nAlocação dinâmica de matrizes em C"
  },
  {
    "objectID": "linguagem-c/dados-textuais.html",
    "href": "linguagem-c/dados-textuais.html",
    "title": "Dados textuais em C",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA linguagem C não é uma linguagem simples para trabalhar com cadeias de caracteres, as chamadas strings. O suporte para textos na linguagem é feito por constantes inseridas diretamente no código ou manipuladas em variáveis simples ou compostas do tipo char.\nEste capítulo apresenta uma visão inicial das constantes textuais da linguagem e como fazer referências a essas constantes.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Dados textuais em C"
    ]
  },
  {
    "objectID": "linguagem-c/dados-textuais.html#sec-caracteres-acentuados",
    "href": "linguagem-c/dados-textuais.html#sec-caracteres-acentuados",
    "title": "Dados textuais em C",
    "section": "Caracteres acentuados",
    "text": "Caracteres acentuados\nNa década de 1960 cada sistema computacional usava sua própria tabela para associar um dado caractere a um valor numérico. Para que os diferentes sistemas pudessem trocar informações, foi elaborada em 1964 uma codificação padronizada denominada American Standard Code for Information Interchange, ou tabela ASCII. Essa tabela definia tanto os caracteres de controle (\\n ou \\t, por exemplo) quanto os caracteres legíveis (letras, dígitos e pontuação).\nNa prática, tanto os caracteres de controle quanto os símbolos legíveis significativos poderiam ser representados com apenas sete bits. Em sistemas com palavras de oito bits, o primeiro bit era usualmente zero, de forma que praticamente metade dos bytes não tinham uso. O ponto em questão é que o conjunto de caracteres era baseado na lingua inglesa, na qual acentuações ou outros símbolos de outras línguas não eram incluídos, como á, ã, Ç, ß (alemão) ou č (esloveno). Os bytes não usados na codificação ASCII (aqueles cujos bits começavam com 1) eram usados para esse fim, cada sistema usando uma codificação específica e particular para atender suas necessidades.\n Em grande parte dos sistemas atuais é empregado o Unicode1, que se propõe a ter representações para todas as línguas do planeta e usa com frequência a codificação UTF-8 para representar os símbolos (letras, ideogramas, emojis) em bytes. Como exemplo, o símbolo monetário do Euro é designado por U+20AC no Unicode e usa a sequência de bytes E282AC para representação em UTF-8.\n\nO problema que surge dessa representação é que UTF-8 usa uma quantidade de bytes variável conforme o símbolo. Os caracteres ASCII usam um único byte e possuem representação igual, o que mantém a compatibilidade. Outros símbolos, porém usam dois, três ou até quatro bytes, o que torna impossível armazená-los em uma variável char.\n/*\nIncompatibilidade de símbolos Unicode/UTF-8\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 'é';\n    printf(\"c = %c.\\n\", c);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:7:14: warning: multi-character character constant [-Wmultichar]\n    7 |     char c = 'é';\n      |              ^~~\nmain.c:7:14: warning: overflow in conversion from ‘int’ to ‘char’ \nchanges value from ‘50089’ to ‘-87’ [-Woverflow]\nc = �.\nA falha na compilação acima é que o caractere é (U+00E9) é codificado em dois bytes, C3 e A9, dos quais apenas o valor A9 (decimal 169) é guardado na variável c. Esse valor 169, sozinho, não representa um caractere UTF-8 válido.\nEsse código fonte, armazenado no arquivo acentuacao.c, está codificado com UTF-8, como se indica com o comando file.\n$ file acentuacao.c\nacentuacao.c: C source, Unicode text, UTF-8 text\nExiste a codificação de caracteres ISO-8859, conhecida como latin1, que inclui os caracteres latinos acentuados e que usa apenas um byte por caractere. O comando iconv pode ser usado para criar um novo arquivo fonte (acentuacao-latin1.c) com essa codificação, conforme segue.\n$ iconv -f utf8 -t latin1 acentuacao.c &gt; acentuacao-latin1.c\n$ file acentuacao-latin1.c\nacentuacao-latin1.c: C source, ISO-8859 text\nComo o caractere é usado no código fonte agora possui um único byte, ele pode ser guardado em um char e a compilação ocorre sem problemas.\n$ gcc -Wall -pedantic -std=c17 acentuacao-latin1.c\nAo executar o programa, como a saída produzida é ISO-8859, ela tem que ser convertida de volta para UTF-8 para que o terminal a exiba corretamente.\n$ ./a.out | iconv -f latin1 -t utf8\nc = é.\n\n\nNos programas exemplificados neste texto, simplesmente são evitados os casos em que um char armazenará um caractere Unicode com mais que um byte, pois todas as codificações de caractere usam UTF-8. Para efetivamente usar caracteres de múltiplos bytes, C disponibiliza uma série de funções em wchar.c, as quais lidam com os “caracteres largos” (wide characters). Porém, o uso dessas funções não é tratado neste livro.",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Dados textuais em C"
    ]
  },
  {
    "objectID": "linguagem-c/dados-textuais.html#footnotes",
    "href": "linguagem-c/dados-textuais.html#footnotes",
    "title": "Dados textuais em C",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nUnicode Consortium: https://home.unicode.org.↩︎\nEsse tema é tratado em mais detalhes no ?@sec-enderecamento-de-memoria-e-ponteiros.↩︎",
    "crumbs": [
      "Linguagem C",
      "Cadeias de caracteres",
      "Dados textuais em C"
    ]
  },
  {
    "objectID": "linguagem-c/alocacao-dinamica-de-memoria.html",
    "href": "linguagem-c/alocacao-dinamica-de-memoria.html",
    "title": "Alocação dinâmica de memória",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEm construção…\n\nmalloc e free\n\n\ncalloc e realloc\n\n\nAlocação em conjunto com modularização\n\n\nOutras alocações\ngetline aloca automaticamente e precisa de free.\n\n\nBoas práticas\n\nVerificação de sucesso na alocação.\nUso mandatório de desalocação.\nCuidado com vazamentos de memória.\nEvitação do uso de memória já desalocada.\nVerificar sucesso e movimentação de dados no realloc.\nCuidado para evitar alocação excessiva (e.g., em repetições).\nCuidado com a aritmética de ponteiros.\nCuidado com o acesso a posições fora do bloco alocado."
  },
  {
    "objectID": "linguagem-c/introducao.html",
    "href": "linguagem-c/introducao.html",
    "title": "Introdução",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nNoções gerais da linguagem C"
  },
  {
    "objectID": "linguagem-c/escopo-basico-de-declaracoes.html",
    "href": "linguagem-c/escopo-basico-de-declaracoes.html",
    "title": "Escopo básico de declarações",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nOs códigos fonte em C permitem muitas declarações, como as de variáveis. Este capítulo trata da declaração de variáveis e onde são válidas, além de introduzir superficialmente outras declarações da linguagem.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Escopo básico de declarações"
    ]
  },
  {
    "objectID": "linguagem-c/escopo-basico-de-declaracoes.html#sec-declaracoes-e-validade",
    "href": "linguagem-c/escopo-basico-de-declaracoes.html#sec-declaracoes-e-validade",
    "title": "Escopo básico de declarações",
    "section": "Declarações e validade",
    "text": "Declarações e validade\nO primeiro ponto é, em princípio, bastante intuitivo: para usar uma variável é preciso declará-la antes desse uso. Portanto, a validade de uma variável depende de onde, no código fonte, sua declaração aparece.\nO programa seguinte pode ser considerado para exemplificar as validades.\n/*\nConversões de distância de metros para centímetros, pés, jardas e polegadas\nRequer: uma distância em metros\nAssegura: O valor equivalente em centímetros, pés, jardas e polegadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma distância em metros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double em_metros;\n    sscanf(entrada, \"%lf\", &em_metros);\n\n    // Centímetros\n    double em_centimetros = em_metros * 100;\n    printf(\"&gt; %.1lfm = %.1fcm\\n\", em_metros, em_centimetros);\n\n    // Pés\n    double em_pes = em_metros * 3.281;\n    printf(\"&gt; %.1lfm = %.1f pés\\n\", em_metros, em_pes);\n\n    // Jardas\n    double em_jardas = em_metros * 1.094;\n    printf(\"&gt; %.1lfm = %.1f jardas\\n\", em_metros, em_jardas);\n\n    // Centímetros\n    double em_polegadas = em_metros * 39.37;\n    printf(\"&gt; %.1lfm = %.1f polegadas\\n\", em_metros, em_polegadas);\n\n    return 0;\n}\n// Fim do código fonte\nDigite uma distância em metros: 300\n&gt; 300.0m = 30000.0cm\n&gt; 300.0m = 984.3 pés\n&gt; 300.0m = 328.2 jardas\n&gt; 300.0m = 11811.0 polegadas\nNeste programa, a variável entrada existe desde a linha 9 e é válida até a linha 33. A variável em_metros inicia sua validade na linha 13, em_pes na linha 21, em_jardas na 25 e em_polegadas na 29 e, para todas, a validade termina na linha 33.\nNote-se que, porém, que nenhuma variável é válida na linha 34, depois do encerramento do bloco do main. As variáveis são válidas apenas dentro do bloco onde foram declaradas. E é importante destacar que um bloco de comandos é aquele iniciado por { e finalizado por }.\n\n\n\n\n\n\nDica\n\n\n\nÉ indicado que a declaração de uma variável seja feita o mais próximo possível de seu uso, o que promove clareza de padronização ao programa.\n\n\nO programa que implementa o Algoritmo 1 é reproduzido na sequência.\n/*\nApresentação de dois valores em ordem não decrescente\nRequer: dois valores reais v1 e v2\nAssegura: v1 &lt;= v2\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v1, v2;\n    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n\n    if(v2 &lt; v1) {\n        double temporario = v1;\n        v1 = v2;\n        v2 = temporario;\n    }\n\n    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n    \n    return 0;\n}\nO ponto de destaque desse código é a variável temporario usada para troca de valores. Ela é declarada dentro de um bloco de comandos, formando o comando composto condicionado pelo if. Sua validade é efêmera, pois é válida apenas da linha 18 até a 21, quando o bloco é encerrado. A tentativa de referenciar temporario fora do bloco do if gera um erro de identificador não declarado.\nNesse ponto específico do programa, é relevante perceber que a utilidade de temporario é apenas local e não há qualquer necessidade de que seja declarada como válida em todo o bloco do main.\n\n\n\n\n\n\nDica\n\n\n\nVáriáveis com uso localizado devem ser declaradas apenas dentro do bloco onde são úteis, evitando que tenham validade fora dessa abrangência.\n\n\n\nDuplicidade de identificadores\nNão é possível o uso do mesmo identificador no mesmo escopo de abrangência. Segue um exemplo simples que ilustra o problema.\n/*\nExemplo de declaração repetida de um identificador no mesmo escopo\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int valor = 10;\n    printf(\"valor: %d.\\n\", valor);\n    \n    int valor = 100;\n    printf(\"valor: %d.\\n\", valor);\n    \n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:10:9: error: redefinition of ‘valor’\n   10 |     int valor = 100;\n      |         ^~~~~\nmain.c:7:9: note: previous definition of ‘valor’ with type ‘int’\n    7 |     int valor = 10;\n      |         ^~~~~\nHá, porém, a possibilidade de que um mesmo identificador seja usado em um novo escopo, valendo a regra que sempre a declaração “mais local” é a válida.\n/*\nExemplo de declaração repetida de um identificador em escopos diferentes\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int valor = 10;\n    printf(\"valor: %d (antes do if).\\n\", valor);\n    \n    if (valor == 10){\n        int valor = 100;\n        printf(\"valor: %d (dentro do if).\\n\", valor);\n    }\n\n    printf(\"valor: %d (depois do if).\\n\", valor);\n\n    return 0;\n}\nvalor: 10 (antes do if).\nvalor: 100 (dentro do if).\nvalor: 10 (depois do if).\nNesse programa, uma variável chamada valor é criada dentro do bloco de comandos do condicional if e sua validade é apenas local, apesar de uma declaração mais externa de valor existir. Dentro do bloco, apenas a variável valor interna pode ser utilizada, apesar de valor externo continuar existindo. Declarações mais locais obscurecem a visão de identificadores mais externos com mesmo nome.\nApesar de isso ser possível de ser feito, não é uma boa prática redeclarar identificadores, visto que a clareza fica severamente comprometida.\n\n\n\n\n\n\nDica\n\n\n\nO uso não justificado de um mesmo identificador em escopos diferentes, porém próximos, dificulta a compreensão do código e pode levar a erros difíceis de serem localizados e corrigidos.\nO uso de identificadores iguais, porém, é válido e será usado em contextos nos quais a multiplicidade de um mesmo nome seja favorável à clareza ao invés de prejudicial.\n\n\nComo outro exemplo, o programa seguinte replica a necessidade de escrever dois valores em ordem não decrescente, porém havendo dois valores inteiros e dois valores reais.\n/*\nApresentação de dois valores em ordem não decrescente\nRequer:  dois valores inteiros vi1 e vi2 e dois valores reais vr1 e vr2\nAssegura: vi1 &lt;= vi2 e vr1 &lt;= vr2\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção dos valores\n    printf(\"Digite dois valores inteiros: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int v_int_1, v_int_2;\n    sscanf(entrada, \"%d%d\", &v_int_1, &v_int_2);\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v_real_1, v_real_2;\n    sscanf(entrada, \"%lf%lf\", &v_real_1, &v_real_2);\n\n    // Verificação da ordem\n    if (v_int_2 &lt; v_int_1) {\n        int temporario = v_int_1;\n        v_int_1 = v_int_2;\n        v_int_2 = temporario;\n    }\n\n    if (v_real_2 &lt; v_real_1) {\n        double temporario = v_real_1;\n        v_real_1 = v_real_2;\n        v_real_2 = temporario;\n    }\n\n    // Apresentação de resultados\n    printf(\"Valores inteiros em ordem não decrescente: %d e %d.\\n\",\n           v_int_1, v_int_2);\n    printf(\"Valores reais em ordem não decrescente: %g e %g.\\n\",\n           v_real_1, v_real_2);\n\n    return 0;\n}\nDigite dois valores inteiros: 300 200\nDigite dois valores reais: 118.2 302.75\nValores inteiros em ordem não decrescente: 200 e 300.\nValores reais em ordem não decrescente: 118.2 e 302.75.\nÉ interessante observar que há duas variáveis chamadas temporario existindo em momentos distintos do programa. Não há, porém, problemas com essa duplicidade de uso, uma vez que suas existências são muito localizadas e não se misturam. Naturalmente cabe ao programador optar ou não por usar nomes distintos.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Escopo básico de declarações"
    ]
  },
  {
    "objectID": "linguagem-c/escopo-basico-de-declaracoes.html#outras-declarações-da-linguagem",
    "href": "linguagem-c/escopo-basico-de-declaracoes.html#outras-declarações-da-linguagem",
    "title": "Escopo básico de declarações",
    "section": "Outras declarações da linguagem",
    "text": "Outras declarações da linguagem\nUm programa não declara apenas variáveis. A própria linha int main(void) dos programas é uma declaração da função main. Sem essa declaração, o sistema operacional não teria como saber por qual instrução começar a execução. Além disso, dentro de stdio.h, por exemplo, estão declarados protótipos das funções printf, sscanf, fgets e etc. Desta forma, depois do #include essas funções passam a ser conhecidas e podem ser corretamente usadas.\nUma visão completa de declarações e regras de escopo é tratada no ?@sec-regras-de-escopo-com-modularizacao.\nEste programa seguinte ilustra uma das grandes vantagens das declarações locais suplantarem as declarações mais externas existentes.\n/*\nExemplo de declaração de uma variável lógica\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    bool remove = false;\n    printf(\"Vai remover? %s!\\n\", remove ? \"SIM\" : \"NÃO\");\n\n    return 0;\n}\nVai remover? NÃO!\nA declaração deste código cria uma variável lógica chamada remove, a qual é usada sem erros. Porém, em stdlib.h é declarada uma função remove (em inglês, do verbo to remove) que pode ser usada para apagar um arquivo. A sobreposição dos identificadores permite ter um código simples, funcional e claro sem conflito com outras declarações preexistentes.",
    "crumbs": [
      "Linguagem C",
      "Organização geral do código",
      "Escopo básico de declarações"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-aritmeticas.html",
    "href": "linguagem-c/expressoes-aritmeticas.html",
    "title": "Expressões aritméticas",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nUma coisa que um computador consegue fazer com eficiência são contas e faz isso muito rapidamente. Nesta parte são tratados os principais aspectos dos cálculos feitos por programas escritos em C.\nUma expressão aritmética é aquela que envolve valores numéricos e, pelo uso operadores, produzem um resultado também numérico. Um exemplo de uma expressão aritmética é o cálculo do discriminante \\({b^2 - 4ac}\\), referente a uma equação de segundo grau \\({ax^2 + bx + c = 0}\\) (\\(a\\neq 0\\)).",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões aritméticas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-aritmeticas.html#ordem-de-avaliação",
    "href": "linguagem-c/expressoes-aritmeticas.html#ordem-de-avaliação",
    "title": "Expressões aritméticas",
    "section": "Ordem de avaliação",
    "text": "Ordem de avaliação\nA ordem de avaliação de uma expressão aritmética em C pode ser traiçoeira. Embora, em grande parte das vezes, o valor de uma expressão seja direto, há um não tão pequeno número de situações em que o programador pode se equivocar.\nPara avaliar uma expressão, o compilador usa os seguintes passos de decisão:\n\nPara operadores com precedências diferentes, a ordem da precedência é seguida;\nPara operadores de mesma precedência, a associatividade é seguida.\n\nPor exemplo, na expressão a + b * c, b * c é avaliado primeiro, sendo a soma realizada em um segundo momento.\nPara a expressão a * b * c + d * e, a ordem de avaliação é:\n\nPrimeiro ocorre a multiplicação de a por b, gerando um resultado intermediário \\(r_1\\);\nDepois, \\(r_1\\) é multiplicado por c (\\(r_2\\));\nComo a multiplicação tem precedência sobre a soma, d e e são multiplicados (\\(r_3\\));\nPor fim, \\(r_2\\) e \\(r_3\\) são somados.\n\nA ordem de avaliação, portanto, é (((a * b) * c) + (d * e)), embora se saiba que a ordem de multiplicação dos três primeiros termos não interfira no resultado.\nFelizmente, para os operadores de soma, subtração e multiplicação, a ordem seguida pelo compilador é normalmente a esperada.\nQuando há uma divisão, uma margem para erros acaba se apresentando. Como exemplo, pode-se considerar a expressão a * b / c * d, na qual todos os operadores possuem a mesma ordem de precedência, mas diferentes ordens de avaliação levam a resultados distintos. Para este caso, a ordem de avaliação é:\n\nÉ feita inicialmente a multiplicação de a por b (\\(r_1\\));\nEm seguida, \\(r_1\\) é dividido por c, resultando \\(r_2\\);\nPor último, é feita a multiplicação de \\(r_2\\) por d, gerando o resultado final.\n\nA ordem de avaliação segue a associatividade dos operadores de mesma precedência, que neste caso é da esquerda para a direita. Assim, a * b / c * d é avaliado como (((a * b) / c) * d).",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões aritméticas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-aritmeticas.html#quebra-da-ordem-de-precedência-e-da-associatividade",
    "href": "linguagem-c/expressoes-aritmeticas.html#quebra-da-ordem-de-precedência-e-da-associatividade",
    "title": "Expressões aritméticas",
    "section": "Quebra da ordem de precedência e da associatividade",
    "text": "Quebra da ordem de precedência e da associatividade\nConhecido o procedimento usado pelo compilador para avaliar uma expressão aritmética, fica expressa a necessidade de, por vezes, escolher uma ordem diferente. A linguagem C usa os parênteses para definir a ordem de avaliação. Um exemplo importante e simples é o cálculo media: (v1 + v2)/2. Sem os parênteses, apenas v2 seria dividido por 2.\nApenas parênteses são usados nas expressões, pois colchetes e chaves servem a outros propósitos na linguagem.\nConsiderando a, título de exemplo, que uma variável real discriminante contenha o valor \\(b^2 - 4ac\\) correspondente a uma equação de segundo grau \\({ax^2 + bx + c = {}}\\) 0 (\\(a \\neq\\) 0), a Tabela 2 mostra tentativas de escrever o cálculo de uma das raízes da equação, considerando que o discriminante seja não negativo.\n\n\n\nTabela 2: Exemplos de tentativas de código para calcular uma raiz de uma equação de segundo grau com discriminante \\(\\Delta \\geq 0\\).\n\n\n\n\n\n\n\n\n\n\nExpressão do código\nExpressão equivalente\nResultado\n\n\n\n\n-b - sqrt(discriminante) / 2 * a\n\\(-b - \\dfrac{\\sqrt{\\Delta}}{2} a\\)\nIncorreto\n\n\n-b - sqrt(discriminante) / (2 * a)\n\\(-b - \\dfrac{\\sqrt{\\Delta}}{2a}\\)\nIncorreto\n\n\n(-b - sqrt(discriminante)) / 2 * a\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2} a\\)\nIncorreto\n\n\n(-b - sqrt(discriminante))  /  2*a\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2} a\\)\nIncorreto\n\n\n(-b - sqrt(discriminante)) / (2 * a)\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2a}\\)\nCorreto\n\n\n(-b - sqrt(discriminante)) / 2 / a\n\\(\\dfrac{-b - \\sqrt{\\Delta}}{2a}\\)\nCorreto\n\n\n\n\n\n\n\n\n\n\n\n\nDica\n\n\n\nEm C, o compilador ignora os espaços entre os operadores. A ordem que vale é a da precedência, em primeiro lugar, e da associatividade, para precedências iguais. Dessa forma, é indiferente para o compilador escrever a/b*c, a / b * c ou a / b*c, pois todas serão avaliadas ((a / b) * c).\nMesmo que desnecessário, muitas vezes o uso dos parênteses para deixar clara a ordem de avaliação que o programador deseja ajuda na legibilidade e entendimento do código fonte.\nPor exemplo, é comum, no lugar de elevar um valor ao quadrado, usar a multiplicação dele por ele mesmo. Uma expressão que usa esse recurso, por exemplo, seria \\(a^2(b+c)^2\\), que poderia ser escrita (a * a) * ((b + c) * (b + c)), mesmo que a * a * (b + c) * (b + c) seja exatamente equivalente. Os parênteses servem apenas para ênfase.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões aritméticas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-aritmeticas.html#footnotes",
    "href": "linguagem-c/expressoes-aritmeticas.html#footnotes",
    "title": "Expressões aritméticas",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nHá um transbordo quando o resultado de uma operação precisa de mais bits que o tipo tem disponível, corrompendo a representação por causa dos bits perdidos.↩︎",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões aritméticas"
    ]
  },
  {
    "objectID": "linguagem-c/desvirtuacao-das-repeticoes.html",
    "href": "linguagem-c/desvirtuacao-das-repeticoes.html",
    "title": "Desvirtuação das repetições",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA estrutura do for, embora seja bem objetiva indicando iniciação, condição e incremento (seus três elementos de operação), ela é bastante flexível do ponto de vista de seu uso pelo programador.\nUm indicador dessa liberdade dada ao programador é que todos os elementos são opcionais, além de permitirem outros elementos.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Desvirtuação das repetições"
    ]
  },
  {
    "objectID": "linguagem-c/desvirtuacao-das-repeticoes.html#laços-infinitos",
    "href": "linguagem-c/desvirtuacao-das-repeticoes.html#laços-infinitos",
    "title": "Desvirtuação das repetições",
    "section": "Laços infinitos",
    "text": "Laços infinitos\nEm termos de argumentos opcionais, o trecho de código seguinte pode ser considerado.\nfor (;;)\n    printf(\"Faça algo!\\n\");\nPara esta repetição, não há iniciação, nem condição, nem incremento. Seu comportamento, assim, funciona como um “repita o comando para sempre”, ou seja, um laço infinito.\n\n\n\n\n\n\nDica\n\n\n\nLaços infinitos, embora não se apresentem como uma solução algorítmica em si, não são incomuns em programas. Por exemplo, o programa que gerencia um aparelho eletrônico simples como um forno de micro-ondas não foi feito para terminar: ele inicia ao se ligar o aparelho na tomada e só para quando o plugue for retirado.\nEmbora o esquema for (;;) seja usado, recomenda-se que laços infinitos usem while (true) para dar essa ênfase.\n\n\nNa prática, basta não ter a condição de continuidade especificada para se ter a repetição infinita. Segue outro exemplo simples com repetições infinitas usando o for, que faz a contagem cíclica de 0 a 9 (contagem modular).\nfor (int i = 0;; i = (i + 1) % 10)\n    printf(\"%d \", i);",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Desvirtuação das repetições"
    ]
  },
  {
    "objectID": "linguagem-c/desvirtuacao-das-repeticoes.html#término-forçado-for",
    "href": "linguagem-c/desvirtuacao-das-repeticoes.html#término-forçado-for",
    "title": "Desvirtuação das repetições",
    "section": "Término forçado for",
    "text": "Término forçado for\nEnquanto se escreve um programa, o uso da repetição com for intuitivamente indica que um determinado número de repetições vai ocorrer. Muitos programadores deturpam essa percepção artificialmente interrompendo a repetição.\nAo considerar o código seguinte, a expectativa é que a leitura seja feita cinco vezes. Na repetição, porém, há um if que altera o valor de i de forma a terminar a repetição.\n/*\nLeitura e apresentação de valores inteiros\nRequer: uma sequência de até 5 valores inteiros não negativos ou uma\n    sequência encerrada por um valor negativo\nAssegura: a apresentação de cada valor lido na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Digite até 5 valores inteiros não negativos:\\n\");\n    for(int i = 0; i &lt; 5; i++) {\n        char entrada[160];\n        printf(\"&gt; \");\n        fgets(entrada, sizeof entrada, stdin);\n        int valor;\n        sscanf(entrada, \"%d\", &valor);\n\n        printf(\"  +-- digitado %d.\\n\", valor);\n        if (valor &lt; 0)\n            i = 5;\n    }\n\n    return 0;\n}\nDigite até 5 valores inteiros não negativos:\n&gt; 10\n  +-- digitado 10.\n&gt; 0\n  +-- digitado 0.\n&gt; -5\n  +-- digitado -5.\nO programa não está incorreto no sentido de que encerra as leituras ao encontrar um valor negativo. O problema é que esse encerramento prematuro em função do valor lido é mascarado e exige por parte de outro programador que analise os comandos uma atenção extra para entender que um “para i de 1 até 5” não será sempre de 1 a 5.\nEm programas mais complexos e com mais variáveis, o uso desse expediente de término forçado pode ficar mascarado o suficiente para que outro programador, ao fazer uma modificação, sequer note essa possibilidade e introduza um erro ou instabilidade no código.\nNeste caso, como o número de vezes da repetição é variável, o código ficaria mais claro usando o do while, por exemplo. Assim, não há indução no código a um comportamento que o programa não tem e deixa explícitas as duas condições de parada da repetição.\n/*\nLeitura e apresentação de valores inteiros\nRequer: uma sequência de até 5 valores inteiros não negativos ou uma\n    sequência encerrada por um valor negativo\nAssegura: a apresentação de cada valor lido na tela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Digite até 5 valores inteiros não negativos:\\n\");\n    int i = 0;\n    int valor;\n    do {\n        char entrada[160];\n        printf(\"&gt; \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n\n        printf(\"  +-- digitado %d.\\n\", valor);\n        i++;\n    } while (valor &gt;= 0 && i &lt; 5);\n\n    return 0;\n}\nDigite até 5 valores inteiros não negativos:\n&gt; 10\n  +-- digitado 10.\n&gt; 0\n  +-- digitado 0.\n&gt; -5\n  +-- digitado -5.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Desvirtuação das repetições"
    ]
  },
  {
    "objectID": "linguagem-c/desvirtuacao-das-repeticoes.html#footnotes",
    "href": "linguagem-c/desvirtuacao-das-repeticoes.html#footnotes",
    "title": "Desvirtuação das repetições",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nO cálculo considera que sizeof (bool) é um byte, valor usado pelo compilador durante a escrita desse livro.↩︎",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Desvirtuação das repetições"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-texto.html",
    "href": "linguagem-c/arquivos-texto.html",
    "title": "Arquivos texto",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nTodos os programas apresentados até o momento escrevem e leem texto, usando o terminal como interface: tela para a apresentação de informações e teclado para receber caracteres digitados.\nNa escrita de um programa em C usando a função printf, a saída é sempre um texto. Este texto pode ser explícito e direto, como o do comando seguinte.\nPor outro lado, o texto escrito pode ser o resultante de uma conversão do valor de uma variável, exemplificado na sequência.\nNeste último printf, a variável d contém um dado valor representado internamente com o tipo double, mas a escrita é uma representação textual desse valor. De acordo com o formato %.2f, a transformação do valor para texto gera a sequência de caracteres 1, ., 3 e 2. A saída, portanto, é texto.\nA questão uso de texto também ocorre nas leituras. Os programas recebem uma sequência de caracteres (texto) obtidas por fgets, mas um eventual valor numérico digitado deve ser convertido para um tipo int ou double, por exemplo. Assim, toda entrada para os programas também tem sido exclusivamente no formato textual. Segue um exemplo destacando a conversão.",
    "crumbs": [
      "Linguagem C",
      "Manipulação de arquivos",
      "Arquivos texto"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-texto.html#entrada-e-saída-padrão",
    "href": "linguagem-c/arquivos-texto.html#entrada-e-saída-padrão",
    "title": "Arquivos texto",
    "section": "Entrada e saída padrão",
    "text": "Entrada e saída padrão\nDurante a execução de um programa, ele é capaz de escrever e ler de um terminal. O sistema operacional automaticamente associa as leituras a um fluxo chamado de entrada padrão, conhecido por stdin (de standard input). A saída, por seu turno, é associada à chamada saída padrão, que é o fluxo stdout (standard output).\nAo executar um programa, stdout é associada ao terminal e, assim, todos as chamadas a printf produzem textos nesse terminal. De forma similar, stdin é também associada a esse terminal, de forma que as digitações realizadas são transferidas para o programa (daí o último argumento de fgets ser stdin).\n\n\n\n\n\n\nCuriosidade\n\n\n\nExiste, ainda, um segundo fluxo de saída chamado stderr (standard error), que também é associado ao terminal e funciona praticamente da mesma forma que stdout.\n\n\nPara concluir, o programa em execução pega dados de um fluxo de entrada e gera dados um fluxo de saída.",
    "crumbs": [
      "Linguagem C",
      "Manipulação de arquivos",
      "Arquivos texto"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-texto.html#texto-plano-e-outros-fluxos-de-entrada-e-saída",
    "href": "linguagem-c/arquivos-texto.html#texto-plano-e-outros-fluxos-de-entrada-e-saída",
    "title": "Arquivos texto",
    "section": "Texto plano e outros fluxos de entrada e saída",
    "text": "Texto plano e outros fluxos de entrada e saída\nNos fluxos de entrada e saída padrão, via de regra, são produzidos o que se convencionou chamar de texto plano (ou texto simples). Esse texto plano se refere apenas ao fluxo de caracteres convencionais, sem atributos associados. Em outras palavras, o nem fgets nem printf lidam com itálicos, negritos, espaçamento de linhas entre parágrafos ou linhas centralizadas, para citar alguns exemplos de formatação.\nQuando um programa em C é escrito em um editor, ele é um texto plano. A maioria dos IDEs coloca cores e negritos para destacar palavras chaves e comentários, mas esse recurso é apenas visual e automático; essas características não são salvas junto como o código fonte. Textos planos são os produzidos em IDEs ou editores simples, como o GEdit ou o Notepad.\nProgramas em C são capazes de gerenciar outros fluxos além de stdin e stdout, os quais são manipulados como textos planos. Esses novos fluxos são usualmente associados a arquivos, o que permite que as leituras sejam feitas usando-se os caracteres armazenados em um arquivo e, adicionalmente, que as saídas produzam textos direcionados para outro arquivo.\nO termo geral arquivo é usado para qualquer fluxo de dados de entrada ou saída de um programa. Estranhamente, stdin e stdout são tratados internamente também como arquivos.\n A função de escrita printf escreve na saída padrão. Há uma outra função similar, a fprintf, esta última permitindo especificar o fluxo para o qual texto será enviado.\n/*\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Duas saídas equivalente\n    printf(\"Hello, world!\\n\");  // implicitamente envia para stdout\n    fprintf(stdout, \"Hello, world!\\n\"); // explícito para stdout\n\n    return 0;\n}\nHello, world!\nHello, world!\nA função fprintf possui um novo parâmetro obrigatório, que é o fluxo que será usado. Neste programa em particular, as duas instruções possuem o mesmo efeito, pois ambas as funções estão associadas a stdout.",
    "crumbs": [
      "Linguagem C",
      "Manipulação de arquivos",
      "Arquivos texto"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-texto.html#a-função-fopen",
    "href": "linguagem-c/arquivos-texto.html#a-função-fopen",
    "title": "Arquivos texto",
    "section": "A função fopen",
    "text": "A função fopen\nA função de associação entre o programa e o arquivo real é a fopen. Ela sempre possui dois parâmetros, sendo o primeiro a indicação do nome do arquivo e o segundo, o modo de abertura.\nO nome do arquivo é uma cadeia de caracteres que pode ser somente o nome do arquivo, como \"figuras.txt\", por exemplo. Nesse caso, o arquivo físico é considerado em relação ao diretório corrente. O nome pode indicar também o caminho: \"../figuras.txt\" indica o arquivo no diretório pai (isto é, um acima do atual) e \"/home/user/dados/figuras.txt\" dá o caminho absoluto e independe do diretório corrente1.\nEm relação aos modos, como \"w\" ou \"r\" usados nos exemplos, a Tabela 1 sumariza como funcionam.\n\n\n\nTabela 1: Modos do fopen para manipulação de arquivos texto.\n\n\n\n\n\n\n\n\n\n  Modo  \nSignificado\n\n\n\n\n\"w\"\nPrepara um arquivo somente para escrita, criando um arquivo novo ou truncando o existente para tamanho zero. A posição corrente é ajustada para o início do arquivo.\n\n\n\"r\"\nPrepara um arquivo somente para leitura. A posição corrente é ajustada para o início do arquivo.\n\n\n\"a\"\nPrepara um arquivo somente para escrita. Se o arquivo já existir, a posição corrente é ajustada para o final do arquivo; senão, um novo arquivo é criado.\n\n\n\n\n\n\nArquivos texto são, via de regra, processados sequencialmente, do início ao fim ou do início até um ponto de interesse qualquer. Raramente são abertos para leitura e escrita, de forma que essa opção foi omitida da lista apresentada.\nA Tabela 1 também introduz um elemento importante, embora intuitivamente fácil de compreender: a posição corrente. Esse termo é aplicado ao local no arquivo onde as operações de leitura e escrita serão realizadas. Por exemplo, quando um arquivo é aberto em modo \"r\", a posição corrente está no início do arquivo, que é o byte zero. A cada leitura, a posição corrente é ajustada para o próximo byte que será lido.\nEmbora a posição corrente não seja diretamente usada pelo programador no processamento sequencial do arquivo, um exemplo simples de programa ilustra esse conceito.\n\n/*\nEscrita de algumas linhas de texto em um arquivo com acompanhamento da\n    posição corrente de Escrita\nAssegura: criação de arquivo 'texto.txt' com algum texto e apresentação\n    dos bytes usados em cada linha durante a escrita\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_numeros = fopen(\"texto.txt\", \"w\");\n\n    if (arquivo_numeros == NULL)\n        printf(\"Falha ao criar arquivo de saída.\\n\");\n    else {\n        printf(\"Primeira linha: bytes de %ld\", ftell(arquivo_numeros));\n        fprintf(arquivo_numeros, \"Primeira linha deste arquivo.\\n\");\n        printf(\" a %ld.\\n\", ftell(arquivo_numeros) - 1);\n\n        printf(\"Segunda linha: bytes de %ld\", ftell(arquivo_numeros));\n        fprintf(arquivo_numeros, \"Linha 2\");  // escrita em duas etapas\n        fprintf(arquivo_numeros, \" segue aqui...\\n\");\n        printf(\" a %ld.\\n\", ftell(arquivo_numeros) - 1);\n\n        printf(\"Terceira linha: bytes de %ld\", ftell(arquivo_numeros));\n        fprintf(arquivo_numeros, \"Finalmente o fim do texto! (linha 3)\");\n        printf(\" a %ld.\\n\", ftell(arquivo_numeros) - 1);\n\n        fclose(arquivo_numeros);\n    }\n\n    return 0;\n}\nPrimeira linha: bytes de 0 a 29.\nSegunda linha: bytes de 30 a 51.\nTerceira linha: bytes de 52 a 87.\nO conteúdo de texto.txt ficou como se segue.\nPrimeira linha deste arquivo.\nLinha 2 segue aqui...\nFinalmente o fim do texto! (linha 3)\nPara visualização, a seguir é apresentado o conteúdo do arquivo com 16 bytes por linha. A primeira coluna é a contagem de caracteres (primeira linha do od são os bytes de zero a 15), o que ajuda a identificar a posição de cada caractere relativo a sua posição do arquivo. Os valores \\n são as mudanças de linha usuais2. Vale a pena confrontar os valores escritos pelo programa anterior com as posições reais do arquivo.\n$ od -Ad -tc texto.txt\n0000000   P   r   i   m   e   i   r   a       l   i   n   h   a       d\n0000016   e   s   t   e       a   r   q   u   i   v   o   .  \\n   L   i\n0000032   n   h   a       2       s   e   g   u   e       a   q   u   i\n0000048   .   .   .  \\n   F   i   n   a   l   m   e   n   t   e       o\n0000064       f   i   m       d   o       t   e   x   t   o   !       (\n0000080   l   i   n   h   a       3   )\n0000088\n\n\nO conceito da posição corrente também é válido para as leituras, que se iniciam na posição zero (início do arquivo) e, após cada leitura, é atualizada para o próximo byte que será lido em um próximo fgets.\nA ideia da posição em que ocorre a próxima operação de entrada ou saída é a usada quando o modo \"a\" é usado no fopen. Nesse caso, o arquivo é aberto para escrita, seu conteúdo (se existir) é preservado e a posição corrente é colocada depois do último byte do arquivo. Com isso, uma nova escrita no arquivo acrescentará texto ao seu final.\nUm log é um arquivo usado para registrar eventos. Por exemplo, sempre que um usuário entra no sistema ou quando um trabalho de impressão é iniciado, cada evento é registrado no log. O programa seguinte, cada vez que executado, solicita uma linha de informação e a grava em um arquivo de log.\n\n/*\nInserção de uma linha no arquivo de log 'registro.log'\nRequer: a digitação da linha de informação\nAssegura: o acréscimo dessa linha no final do arquivo\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    FILE *arquivo_log = fopen(\"registro.log\", \"a\");\n\n    if (arquivo_log == NULL)\n        printf(\"Falha ao criar ou abrir arquivo de log.\\n\");\n    else {\n        printf(\"Digite a informação a ser registrada:\\n&gt; \");\n        char linha_de_log[160];\n        fgets(linha_de_log, sizeof linha_de_log, stdin);\n\n        fprintf(arquivo_log, \"%s\", linha_de_log);\n\n        fclose(arquivo_log);\n    }\n\n    return 0;\n}\nDigite a informação a ser registrada:\n&gt; Primeiro registro do log.\nNa primeira execução, o arquivo registro.log ainda não existe, o que faz com que ele seja criado vazio. Então o programa solicita o primeiro registro e o grava no arquivo.\nA cada nova execução, uma linha é solicitada e adicionada ao final do arquivo.\n\n\n\n\n\n\n\n\nCuriosidade\n\n\n\nQuando um arquivo é aberto apenas para escrita (\"w\" e \"a\"), tentativas de leitura desse arquivo são apenas ignoradas sem gerar qualquer erro. De forma similar, ao se tentar escrever em um arquivo aberto com \"r\", a escrita não é feita e nenhum erro é indicado.",
    "crumbs": [
      "Linguagem C",
      "Manipulação de arquivos",
      "Arquivos texto"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-texto.html#a-função-fclose",
    "href": "linguagem-c/arquivos-texto.html#a-função-fclose",
    "title": "Arquivos texto",
    "section": "A função fclose",
    "text": "A função fclose\nO encerramento do acesso ao arquivo é feito pela função fclose, para a qual é preciso passar como parâmetro a variável correspondente a um arquivo aberto com sucesso. Uma vez fechado, nenhuma operação de entrada ou saída para o arquivo é possível.",
    "crumbs": [
      "Linguagem C",
      "Manipulação de arquivos",
      "Arquivos texto"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-texto.html#footnotes",
    "href": "linguagem-c/arquivos-texto.html#footnotes",
    "title": "Arquivos texto",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nNo Linux, usado como plataforma para este livro, o separador de diretórios é a barra /. O mesmo ocorre para o MacOS. Em sistemas Windows, os caminhos usam a barra reversa \\ e, como essa barra tem significado especial em C, é preciso indicar o caminho com o escape \\\\: \"..\\\\figuras.txt\" ou C:\\\\User\\\\Documentos\\\\Dados\\\\figuras.txt.↩︎\nNo Windows, a mudança de linha costuma ser indicada pela sequência \\r\\n, de modo que o conteúdo do arquivo pode diferir um pouco caso seja essa a plataforma usada para execução do programa.↩︎",
    "crumbs": [
      "Linguagem C",
      "Manipulação de arquivos",
      "Arquivos texto"
    ]
  },
  {
    "objectID": "linguagem-c/dados-em-matrizes.html",
    "href": "linguagem-c/dados-em-matrizes.html",
    "title": "Dados em matrizes",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/dados-em-matrizes.html#estruturação-da-matriz-em-c",
    "href": "linguagem-c/dados-em-matrizes.html#estruturação-da-matriz-em-c",
    "title": "Dados em matrizes",
    "section": "Estruturação da matriz em C",
    "text": "Estruturação da matriz em C"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-separado.html",
    "href": "linguagem-c/organizacao-do-codigo-separado.html",
    "title": "Organização do código fonte em arquivos separados",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-separado.html#código-fonte-.ce-.h",
    "href": "linguagem-c/organizacao-do-codigo-separado.html#código-fonte-.ce-.h",
    "title": "Organização do código fonte em arquivos separados",
    "section": "Código fonte .ce .h",
    "text": "Código fonte .ce .h"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-separado.html#compilação-em-separado",
    "href": "linguagem-c/organizacao-do-codigo-separado.html#compilação-em-separado",
    "title": "Organização do código fonte em arquivos separados",
    "section": "Compilação em separado",
    "text": "Compilação em separado"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-separado.html#makefile",
    "href": "linguagem-c/organizacao-do-codigo-separado.html#makefile",
    "title": "Organização do código fonte em arquivos separados",
    "section": "Makefile",
    "text": "Makefile"
  },
  {
    "objectID": "linguagem-c/organizacao-do-codigo-separado.html#reuso-de-código",
    "href": "linguagem-c/organizacao-do-codigo-separado.html#reuso-de-código",
    "title": "Organização do código fonte em arquivos separados",
    "section": "Reuso de código",
    "text": "Reuso de código"
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html",
    "href": "linguagem-c/dados-com-struct.html",
    "title": "Dados com struct",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEste capítulo discute como variáveis compostas heterogêneas, comumente chamadas de registros, são declaradas e usadas em C. São cobertos os aspectos de declaração, atribuição e seu uso com funções.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#uso-e-acesso-a-campos",
    "href": "linguagem-c/dados-com-struct.html#uso-e-acesso-a-campos",
    "title": "Dados com struct",
    "section": "Uso e acesso a campos",
    "text": "Uso e acesso a campos\nO acesso aos campos é feito com o operador . (ponto). Assim, ponto1.x é o campo x da variável ponto1.\n// Definição de ponto1 como o ponto (1.5, 0, 3.9)\nponto1.x = 1.5;\nponto1.y = 0;\nponto1.z = 3.9;\nUma vantagem interessante de variáveis struct é a capacidade de atribuição direta. Por exemplo, a instrução ponto2 = ponto1 pode ser usada sem problemas. Na prática, o compilador não está ciente dos campos ou de seus valores, mas copia todos os bytes que formam um registro para o outro, resultando em uma cópia idêntica.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#declaração-com-iniciação",
    "href": "linguagem-c/dados-com-struct.html#declaração-com-iniciação",
    "title": "Dados com struct",
    "section": "Declaração com iniciação",
    "text": "Declaração com iniciação\nÉ possível, ao declarar uma varável do tipo registro, já incluir a iniciação de seus valores. O programa seguinte ilustra essa manipulação.\n/*\n * Exemplo de iniciação de valores de um registro\n * Assegura: apresentação dos valores iniciados\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    struct pessoa {\n        char nome[100];\n        char cpf[15];\n        int ano_nascimento;\n    };\n\n    struct pessoa alguem = {\"Fulano de tal\", \"123.456.789-00\", 2008};\n\n    printf(\"Nome: %s,\\nCPF: %s,\\nAno: %d.\\n\", alguem.nome, alguem.cpf,\n           alguem.ano_nascimento);\n\n    return 0;\n}\nNome: Fulano de tal,\nCPF: 123.456.789-00,\nAno: 2008.\nEsse recurso, porém, apenas está disponível na declaração. Tentativas de atribuição posteriores não são aceitas. Nestes casos as atribuições necessariamente têm que ser feitas campo a campo.\n/*\n * Exemplo de falha na atribuição de registros\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    struct pessoa {\n        char nome[100];\n        char cpf[15];\n        int ano_nascimento;\n    };\n\n    struct pessoa alguem;\n    alguem = {\"Muriel Gomes Faruak\", \"123.456.789-00\", 2008};  // não funciona!\n\n    printf(\"Nome: %s,\\nCPF: %s,\\nAno: %d.\\n\", alguem.nome, alguem.cpf,\n           alguem.ano_nascimento);\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:14:14: error: expected expression before ‘{’ token\n   14 |     alguem = {\"Muriel Gomes Faruak\", \"123.456.789-00\", 2008};  // \nnão funciona!\n      |              ^",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#passagem-de-registro-por-referência",
    "href": "linguagem-c/dados-com-struct.html#passagem-de-registro-por-referência",
    "title": "Dados com struct",
    "section": "Passagem de registro por referência",
    "text": "Passagem de registro por referência\nDa mesma forma que outras variáveis, é possível passar a referência de um registro para uma função. O endereço de um registro é o endereço de seu primeiro byte, independentemente de seus campos.\nNo caso do exemplo da área do triângulo, a leitura de cada ponto está passando cada campo de forma independente. Essa situação pode ser modificada passando um único parâmetro (o registro) para a função, todo ele por referência.\nSegue a nova versão do procedimento leia_ponto.\n/*!\n * Leitura de um ponto em R^3\n * @param mensagem: mensagem solicitando a digitação dos dados\n * @param ponto: referência a um ponto\n */\nvoid leia_ponto(char *mensagem, struct ponto *ponto);\nO primeiro parâmetro, mensagem, está inalterado e as três coordenadas foram substituídas pelo registro todo. Agora, o parâmetro formal aguarda o endereço de uma variável struct ponto, estruturando uma passagem por referência. A chamada para essa função pode ser, por exemplo, como apresentada logo na sequência.\nstruct ponto ponto;\nleia_ponto(\"Digite as coordenadas: \", &ponto);",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#ponteiros-para-struct-e-acesso-a-campos",
    "href": "linguagem-c/dados-com-struct.html#ponteiros-para-struct-e-acesso-a-campos",
    "title": "Dados com struct",
    "section": "Ponteiros para struct e acesso a campos",
    "text": "Ponteiros para struct e acesso a campos\nO entendimento da passagem por referência quando os parâmetros são struct requer entender a natureza da notação específica usada em C para esses casos. Dessa forma, uma sequência de exemplos proporcionam o entendimento dos operadores utilizados.\nO programa seguinte mostra o uso de um ponteiro para fazer acesso ao conteúdo de um registro.\n/*\n * Registros e ponteiros para registros\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    /*! @struct registro com campos diversos */\n    struct registro {\n        int i;\n        double d;\n        char c;\n    };\n\n    // Variável comum para registro\n    struct registro r1 = {9, 3.7, 'x'};\n    printf(\"r1 = %d / %g / '%c'.\\n\", r1.i, r1.d, r1.c);\n\n    // Ponteiro para registro\n    struct registro *pr = &r1;  // pr aponta para r1\n\n    // Uso do ponteiro com outra variável comum\n    struct registro r2 = *pr;  // copia r1 para r2\n    printf(\"r2 = %d / %g / '%c'.\\n\", r2.i, r2.d, r2.c);\n\n    return 0;\n}\nr1 = 9 / 3.7 / 'x'.\nr2 = 9 / 3.7 / 'x'.\nNesse programa, r1 é um registro com três campos, iniciados com alguns valores ilustrativos. Há, também, uma variável do tipo ponteiro, cujo tipo base é struct registro.\nstruct registro *pr;  // para guardar o endereço de um registro\nDa mesma forma que outras variáveis e respectivos ponteiros, pr é usado para guardar um endereço (no caso, de r1) e a notação *pr permite o acesso aos dados apontado. Dessa forma, escrever r2 = *pr equivale, no código, a r2 = r1, já que pr aponta para r1. Em outras palavras, o tipo de pr é struct registro* (um ponteiro) e de *pr é struct registro (o registro real que está sendo apontado).\nA questão que se apresenta é o acesso aos campos de um registro apontado. C disponibiliza uma notação particular para essa situação, usando o operador -&gt;, como se ilustra a seguir.\n/*\n * Registros e ponteiros para registros\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    /*! @struct registro com campos diversos */\n    struct registro {\n        int i;\n        double d;\n        char c;\n    };\n\n    struct registro r1 = {9, 3.7, 'x'};\n    printf(\"r1 = %d / %g / '%c'.\\n\", r1.i, r1.d, r1.c);\n\n    struct registro *pr = &r1;\n    printf(\"r2 = %d / %g / '%c'.\\n\", pr-&gt;i, pr-&gt;d, pr-&gt;c);\n\n    return 0;\n}\nr1 = 9 / 3.7 / 'x'.\nr2 = 9 / 3.7 / 'x'.\nQuando uma variável p é um ponteiro para um struct, *p é o registro apontado inteiro e p-&gt;c indica o acesso ao campo c de *p.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#uso-dos-ponteiros-na-passagem-por-referência",
    "href": "linguagem-c/dados-com-struct.html#uso-dos-ponteiros-na-passagem-por-referência",
    "title": "Dados com struct",
    "section": "Uso dos ponteiros na passagem por referência",
    "text": "Uso dos ponteiros na passagem por referência\nCom o uso de ponteiros, a passagem por referência de um registro pode ser feita. O programa seguinte modifica a função de leitura de um ponto, trocando as três coordenadas separadas pelo registro como um todo. As demais funções ficaram inalteradas e foram suprimidas para simplificar a listagem.\n/*\n * Determinação da área de um triângulo dados seus vértices em R^3\n * Requer: três pontos, cada um composto por suas coordenadas x, y e z\n * Assegura: a apresentação da área do triângulo definido pelos vértices\n */\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*! @struct ponto */\nstruct ponto {\n    double x, y, z;\n};\n\n// --- Alguns protótipos foram suprimidos\n\n/*!\n * Leitura de um ponto em R^3\n * @param mensagem: mensagem solicitando a digitação dos dados\n * @param ponto: referência para o ponto\n */\nvoid leia_ponto(char *mensagem, struct ponto *ponto);\n\n/*\n * Main\n */\nint main(void) {\n    struct ponto vertice1;\n    leia_ponto(\"Digite as coordenadas 1: \", &vertice1);\n\n    struct ponto vertice2;\n    leia_ponto(\"Digite as coordenadas 2: \", &vertice2);\n\n    struct ponto vertice3;\n    leia_ponto(\"Digite as coordenadas 1: \", &vertice3);\n\n    double area = area_triangulo(vertice1, vertice2, vertice3);\n    printf(\"Área do triângulo: %.2f.\\n\", area);\n}\n\n// --- Algumas implementações foram suprimidas\n\n// Leitura de um ponto\nvoid leia_ponto(char *mensagem, struct ponto *ponto) {\n    printf(\"%s\", mensagem);\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf%lf%lf\", &ponto-&gt;x, &ponto-&gt;y, &ponto-&gt;z);\n}\nDigite as coordenadas 1: -1 7 3\nDigite as coordenadas 2: -1 0 0\nDigite as coordenadas 1: 2 3 5\nÁrea do triângulo: 17.31.\nO procedimento leia_ponto mantém o primeiro parâmetro original, que é a mensagem apresentada e define mais um único parâmetro que é o struct passado como referência (com tipo struct ponto*). Dado que dentro desse procedimento o parâmetro ponto é um ponteiro, o acesso aos campos é escrito ponto-&gt;x, ponto-&gt;y e ponto-&gt;z. Para o sscanf, que também espera passagens por referência, são indicados os endereços de cada campo individualmente: &ponto-&gt;x, &ponto-&gt;y e &ponto-&gt;z.\nNa função main, a chamada para leia_ponto requer que seja passado o endereço do registro que será modificado.\nleia_ponto(\"Digite as coordenadas 1: \", &vertice1);",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#sec-declaracao-struct-sem-nome",
    "href": "linguagem-c/dados-com-struct.html#sec-declaracao-struct-sem-nome",
    "title": "Dados com struct",
    "section": "Declaração sem nome de registro",
    "text": "Declaração sem nome de registro\nEm algumas situações, é possível agrupar os campos em um registro sem que o struct tenha um nome próprio.\nSegue um exemplo\n/*\n * Exemplo de struct sem nome\n * Assegura: apresentação dos valores iniciados\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    struct {\n        char nome[100];\n        char cpf[15];\n        int ano_nascimento;\n    } alguem;\n    \n    strncpy(alguem.nome, \"Muriel Gomes Faruak\", sizeof alguem.nome - 1);\n    strncpy(alguem.cpf, \"123.456.789-00\", sizeof alguem.cpf - 1);\n    alguem.ano_nascimento = 2008;\n\n    printf(\"Nome: %s,\\nCPF: %s,\\nAno: %d.\\n\", alguem.nome, alguem.cpf,\n           alguem.ano_nascimento);\n\n    return 0;\n}\nNome: Muriel Gomes Faruak,\nCPF: 123.456.789-00�E�\u0007,\nAno: 2008.\nNesse exemplo, o registro é criado e a variável é declarada de uma única vez. Um nome para o registro, dado que a variável já está criada, é irrelevante e pode ser omitido.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#sec-declaracoes-struct-iguais",
    "href": "linguagem-c/dados-com-struct.html#sec-declaracoes-struct-iguais",
    "title": "Dados com struct",
    "section": "Declarações “iguais”",
    "text": "Declarações “iguais”\nEm C, ao se encontrar a definição do registro como um tipo, o compilador adiciona esse novo struct a uma tabela interna de novos tipos. Se duas definições são idênticas, porém criadas em momentos diferentes, elas não são compatíveis.\nSegue um exemplo no qual duas variáveis são criadas sem especificação do nome do struct (Seção 4.1) para, em seguida, ser declarada uma terceira variável com struct idêntico no formato.\n\n/*\n * Exemplo de struct sem nome\n * Assegura: apresentação dos valores iniciados\n */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    // registro1 e registro2 são compatíveis\n    struct {\n        int i;\n        double d;\n    } registro1, registro2;\n    registro1.i = 10;\n    registro1.d = 1.1;\n    registro2 = registro1;  // cópia completa\n\n    // registro3 possui a mesma organização, porém é incompatível\n    struct {\n        int i;\n        double d;\n    } registro3;\n    registro3 = registro1;\n\n    return 0;\n}\nmain.c: In function ‘main’:\nmain.c:24:17: error: incompatible types when assigning to type ‘struct \n&lt;anonymous&gt;’ from type ‘struct &lt;anonymous&gt;’\n   24 |     registro3 = registro1;\n      |                 ^~~~~~~~~\nmain.c:23:7: warning: variable ‘registro3’ set but not used \n[-Wunused-but-set-variable]\n   23 |     } registro3;\n      |       ^~~~~~~~~\nmain.c:14:18: warning: variable ‘registro2’ set but not used \n[-Wunused-but-set-variable]\n   14 |     } registro1, registro2;\n      |                  ^~~~~~~~~\nO uso de struct com nome permite a declaração de novas variáveis referenciando um único tipo e, assim, mantendo a compatibilidade entre as variáveis.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#apresentação-de-um-registro-em-uma-função",
    "href": "linguagem-c/dados-com-struct.html#apresentação-de-um-registro-em-uma-função",
    "title": "Dados com struct",
    "section": "Apresentação de um registro em uma função",
    "text": "Apresentação de um registro em uma função\nO programa seguinte mostra mais um exemplo de passagem de um registro como parâmetro por valor.\n/*\n * Apresentação de dados de um vetor 2D com rótulo\n * Assegura: apresentação dos campos do registro\n */\n#include &lt;stdio.h&gt;\n\n/*! @struct vetor 2D */\nstruct vetor {\n    char rotulo;\n    double x, y;\n};\n\n/*!\n * Escreve o conteúdo de um vetor\n * @param vetor: vetor a ser escrito\n */\nvoid escreva_vetor(struct vetor vetor);\n\n/*\n * Main\n */\nint main(void) {\n    struct vetor vetor1 = {'A', 0.0, 0.0};\n    struct vetor vetor2 = {'B', -2.2, 1.7};\n\n    escreva_vetor(vetor1);\n    escreva_vetor(vetor2);\n\n    return 0;\n}\n\n// Apresenta um vetor na tela\nvoid escreva_vetor(struct vetor vetor) {\n    printf(\"vetor %c: (%.1f, %.1f).\\n\", vetor.rotulo, vetor.x, vetor.y);\n}\nvetor A: (0.0, 0.0).\nvetor B: (-2.2, 1.7).\nÉ reforçado, aqui, que a declaração de struct vetor deve ser global, pois isso é necessário para que o registro definido possa ser usado tanto na função escreva_vetor quanto na função main.\nDessa forma, a função escreva_vetor tem como único parâmetro um struct vetor. Em main, duas variáveis (vetor1 e vetor2) são declaradas e compartilham o mesmo tipo do parâmetro. Nas chamadas à função, cada um dos registros é passado por valor, com cópia do registro de main para o parâmetro vetor de escreva_vetor.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#normalização-de-vetores",
    "href": "linguagem-c/dados-com-struct.html#normalização-de-vetores",
    "title": "Dados com struct",
    "section": "Normalização de vetores",
    "text": "Normalização de vetores\nUm vetor \\(\\vec{v}\\) é usualmente representando por um segmento orientado, indicando sua direção e intensidade. A norma de um vetor, também chamada módulo, é representada por \\(\\lvert\\vec{v}\\rvert\\) e corresponde, graficamente, ao comprimento do segmento.\nQuando um vetor é normalizado, é mantida sua direção e sentido, alterando-se sua norma para uma unidade, ou seja \\({\\lvert\\vec{v'}\\rvert = 1}\\). O programa seguinte ilustra como vetores são normalizados. Cada vetor é organizado em um struct e são usadas funções para as diversas manipulações.\n/*\n * Apresentação de dados de um vetor 2D com rótulo\n * Assegura: apresentação dos campos do registro\n */\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\n/*! @struct vetor 2D */\nstruct vetor {\n    char rotulo;\n    double x, y;\n};\n\n/*!\n * Escreve o conteúdo de um vetor\n * @param vetor: vetor a ser escrito\n */\nvoid escreva_vetor(struct vetor vetor);\n\n/*!\n * Faz a normalização de um vetor para que tenha norma igual a 1\n * @param vetor: referência para o vetor\n */\nvoid normalize_vetor(struct vetor *vetor);\n\n/*!\n * Retorna a norma (módulo) de um vetor\n * @param vetor\n * @return norma do vetor\n */\ndouble norma_vetor(struct vetor vetor);\n\n/*\n * Main\n */\nint main(void) {\n    struct vetor vetor1 = {'A', 3.0, 4.0};\n    escreva_vetor(vetor1);\n    normalize_vetor(&vetor1);\n    escreva_vetor(vetor1);\n\n    struct vetor vetor2 = {'B', 300.0, 400.0};\n    escreva_vetor(vetor2);\n    normalize_vetor(&vetor2);\n    escreva_vetor(vetor2);\n\n    struct vetor vetor3 = {'C', -18.7, 41.1};\n    escreva_vetor(vetor3);\n    normalize_vetor(&vetor3);\n    escreva_vetor(vetor3);\n\n    return 0;\n}\n\n// Apresenta um vetor na tela\nvoid escreva_vetor(struct vetor vetor) {\n    printf(\"vetor %c: (%.1f, %.1f); norma %.2f.\\n\", vetor.rotulo, vetor.x,\n            vetor.y, norma_vetor(vetor));\n}\n\n// Normalização de um vetor\nvoid normalize_vetor(struct vetor *vetor) {\n    double norma = norma_vetor(*vetor);\n\n    vetor-&gt;x /= norma;\n    vetor-&gt;y /= norma;\n}\n\n// Calcula a norma de um vetor\ndouble norma_vetor(struct vetor vetor) {\n    return sqrt(vetor.x * vetor.x + vetor.y * vetor.y);\n}\nvetor A: (3.0, 4.0); norma 5.00.\nvetor A: (0.6, 0.8); norma 1.00.\nvetor B: (300.0, 400.0); norma 500.00.\nvetor B: (0.6, 0.8); norma 1.00.\nvetor C: (-18.7, 41.1); norma 45.15.\nvetor C: (-0.4, 0.9); norma 1.00.\nAs funções escreva_vetor e norma_vetor recebem um struct vetor por valor, com cópia do conteúdo do argumento. A normalização, por sua vez, recebe seu parâmetro por referência e altera o conteúdo do registro apontado.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-com-struct.html#footnotes",
    "href": "linguagem-c/dados-com-struct.html#footnotes",
    "title": "Dados com struct",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nEste autor reconhece que um certo número de recompilações foi necessário por erros na digitação dos parâmetros ao criar o exemplo.↩︎",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados com `struct`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-while.html",
    "href": "linguagem-c/repeticoes-com-while.html",
    "title": "Repetições com while",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA linguagem C permite laços de repetição usando while, for e do while. Neste capítulo a estrutura e aspectos lógicos do while são apresentados. O for é abordado no ?@sec-repeticoes-com-for e o do while, no ?@sec-repeticoes-com-do-while.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-while.html#entrada-com-sentinela",
    "href": "linguagem-c/repeticoes-com-while.html#entrada-com-sentinela",
    "title": "Repetições com while",
    "section": "Entrada com sentinela",
    "text": "Entrada com sentinela\nUma forma comum de entrada de dados é o uso de um valor sentinela que indica o fim dos dados. O programa seguinte apresenta uma sequência de leituras para a soma de valores inteiros maiores que zero, usando o valor nulo como sentinela para indicar o fim dos dados.\n/*\nExemplo de leitura de valores inteiros positivos, usando o zero como sentinela\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro positivo ou zero para terminar: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    while (valor != 0) {\n        printf(\"Valor digitado: %d.\\n\", valor);\n\n        printf(\"Digite um valor inteiro positivo ou zero para terminar: \");\n        fgets(entrada, sizeof entrada, stdin);\n        sscanf(entrada, \"%d\", &valor);\n    }\n    printf(\"Encerrado!\\n\");\n\n    return 0;\n}\nDigite um valor inteiro positivo ou zero para terminar: 12\nValor digitado: 12.\nDigite um valor inteiro positivo ou zero para terminar: 26\nValor digitado: 26.\nDigite um valor inteiro positivo ou zero para terminar: 13\nValor digitado: 13.\nDigite um valor inteiro positivo ou zero para terminar: 3\nValor digitado: 3.\nDigite um valor inteiro positivo ou zero para terminar: 20\nValor digitado: 20.\nDigite um valor inteiro positivo ou zero para terminar: 0\nEncerrado!\nNão é incomum o programador optar por expandir o conceito do valor sentinela. Sem prejuízo aos propósitos do programa original, o programador poderia usar na condição do while a a expressão valor &gt; 0, o que incluiria qualquer valor negativo como sentinela.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-while.html#detecção-do-encerramento-do-fluxo-de-entrada",
    "href": "linguagem-c/repeticoes-com-while.html#detecção-do-encerramento-do-fluxo-de-entrada",
    "title": "Repetições com while",
    "section": "Detecção do encerramento do fluxo de entrada",
    "text": "Detecção do encerramento do fluxo de entrada\nOutra alternativa para indicar o fim da sequência de dados é o encerramento da entrada em si. Em sistemas Linux, ao se digitar Ctrl-D em uma linha vazia é indicado ao programa que a entrada de dados foi encerrada. No Windows, o equivalente é digitar Ctrl-Z seguido de ENTER.\nUma leitura com função fgets é capaz de entender o encerramento dos dados. Essa função, como outras funções, retorna um valor resultante, o qual tem sido sistematicamente ignorado. Como exemplo, os comandos seguintes fazem uma leitura e apresentam o resultado lido. Neste caso, o valor de retorno do fgets é ignorado.\nchar entrada[160];\nfgets(entrada, sizeof entrada, stdin);\nprintf(\"%s\", entrada);\nEntretanto, essa função retorna um valor que pode ser verificado. O valor NULL é retornado em caso de erro. Assim, com uma verificação extra, a leitura da linha poderia ser escrita conforme apresentado na sequência.\nchar entrada[160];\nif (fgets(entrada, sizeof entrada, stdin) != NULL)\n    printf(\"%s\", entrada);\nelse\n    printf(\"Houve algum problema com a leitura.\\n\");\nO “problema” mais comum da falha na leitura é o fim do fluxo de entrada. Assim, um programa pode usar essa verificação para repetir a leitura condicionalmente. O programa seguinte exemplifica leituras de linha de texto e contagem do número de linhas1.\n/*\nContagem do número de linhas no fluxo de entrada\nRequer: uma sequência de linhas de texto\nAssegura: a apresentação do número de linhas desse texto\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite seu texto linha a linha (Ctrl-D) para terminar.\\n\");\n    int contador_linhas = 0;\n    while (fgets(entrada, sizeof entrada, stdin) != NULL)\n        contador_linhas++;\n\n    printf(\"Número de linhas: %d.\\n\", contador_linhas);\n\n    return 0;\n}\nDigite seu texto linha a linha (Ctrl-D) para terminar.\nCAPITULO V \nO AGREGADO \n\nNem sempre ia naquele passo vagaroso e rígido. Também se descompunha em \nacionados, era muita vez rápido e lépido nos movimentos, tao natural nesta como \nnaquela maneira. Outrossim, ria largo, se era preciso, de um grande riso sem \nvontade, mas comunicativo, a tal ponto as bochechas, os dentes, os olhos, toda a \ncara, toda a pessoa, todo o mundo pareciam rir nele. Nos lances graves, \ngravíssimo.\nNúmero de linhas: 9.\n\n\n\n\n\n\nDica\n\n\n\nAs funções de leitura, quando detectam o fim do fluxo de entrada associado a stdin, ignoram entradas subsequentes. Assim, depois de terminada uma sequência com Ctrl-D, outras chamadas a fgets são ignoradas. Isso acontece devido a um controle do fluxo feito pelo sistema operacional. Entretanto, é possível retomar a leitura com clearerr, que limpa o indicador de fim de fluxo.\n/*\nContagem do número de linhas no fluxo de entrada\nRequer: uma sequência de linhas de texto\nAssegura: a apresentação do número de linhas desse texto\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite seu texto linha a linha (Ctrl-D) para terminar.\\n\");\n    int contador_linhas = 0;\n    while (fgets(entrada, sizeof entrada, stdin) != NULL)\n        contador_linhas++;\n\n    printf(\"Número de linhas: %d.\\n\", contador_linhas);\n\n    // Reassumindo a leitura de stdin\n    clearerr(stdin);\n    printf(\"Digite seu nome: \");\n    char nome[80];\n    fgets(nome, sizeof nome, stdin);\n    nome[strlen(nome) - 1] = '\\0';  // eliminação do \\n\n    printf(\"Obrigado, %s, por sua digitação!\\n\", nome);\n\n    return 0;\n}\nSem a chamada a clearerr, a leitura do nome é ignorada.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-while.html#contagem-regressiva",
    "href": "linguagem-c/repeticoes-com-while.html#contagem-regressiva",
    "title": "Repetições com while",
    "section": "Contagem regressiva",
    "text": "Contagem regressiva\nUm exemplo simples de repetição com while é apresentado na sequência. O programa implementa um cronômetro regressivo simples e segue o Algoritmo 2.\n\n\nAlgoritmo 2: Contagem regressiva segundo a segundo\n\n\n\n/*\nRealiza a contagem regressiva para um tempo determinado\nRequer: o tempo para contagem (inteiro)\nAssegura: a apresentação de uma contagem regressiva e mensagem de finalização\n*/\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o tempo para contagem.\\n\"\n           \"Exemplos: '10' ou '10s' para 10s, '3m' para 3 minutos \"\n           \"ou '5h' para 5 horas.\\n\"\n           \"Tempo: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int tempo_restante;\n    char unidade_tempo = 's';  // padrão: segundos\n    sscanf(entrada, \"%d%c\", &tempo_restante, &unidade_tempo);\n\n    // Conversão de unidades se necessário; senão considera segundos\n    switch (unidade_tempo) {\n        case 'h':  // horas\n            tempo_restante = tempo_restante * 3600;\n            break;\n        case 'm':  // minutos\n            tempo_restante = tempo_restante * 60;\n            break;\n    }\n\n    // Contagem\n    printf(\"Contagem para %d segundo(s):\\n\", tempo_restante);\n    while (tempo_restante &gt;= 0) {\n        int tempo_horas = tempo_restante / 3600;\n        int tempo_minutos = (tempo_restante - tempo_horas * 3600) / 60;\n        int tempo_segundos = tempo_restante % 60;\n        printf(\"&gt; Tempo restante: %02dh %02dmin %02ds\\r\", tempo_horas,\n               tempo_minutos, tempo_segundos);\n        fflush(stdout);\n\n        sleep(1);  // aguarda 1 segundo\n        tempo_restante--;\n    }\n    printf(\"\\nObrigado pela paciência!\\n\");\n\n    return 0;\n}\nEste código usa o while para a contagem regressiva. A cada execução, é apresentando o valor do cronômetro (dado por tempo_restante) e esse tempo é decrescido de um segundo. A chamada sleep(1) (declarada em unistd.h) suspende a execução do processo por um segundo antes de retomar a contagem.\nValem ainda dois comentários sobre esse programa. O primeiro é sobre o uso de \\r ao apresentar o cronômetro. Esse caractere faz com que o cursor do terminal volte para o início da linha sem passar para a linha de baixo e, assim, o próximo printf sobrescreve o horário anterior, atualizando-o. O outro ponto é o uso da função fflush(stdout) (incluído via stdio.h), a qual faz com que o texto escrito pelo programa seja imediatamente colocado no terminal. Sem ele, há atrasos na escrita e o contador parece irregular.\nO programa de contagem regressiva não é preciso. Ele se baseia em intervalos de um segundo, mas a cada repetição outras operações são feitas. A longo prazo, o cronômetro ficará atrasado em relação ao tempo real. Este programa é para ser um mero exemplo da repetição e não tem maiores pretensões.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-while.html#atualização-de-saldo",
    "href": "linguagem-c/repeticoes-com-while.html#atualização-de-saldo",
    "title": "Repetições com while",
    "section": "Atualização de saldo",
    "text": "Atualização de saldo\nUm saldo bancário tem um valor inicial e, dependendo de uma série de transações de crédito ou débito, o montante é modificado. Esta é a proposta do Algoritmo 3.\n\n\nAlgoritmo 3: Atualização de saldo bancário a partir de créditos e débitos.\n\n\n\nA implementação em C apresentada na sequência considera que cada transação é entrada expressando o tipo da transação com C para crédito ou D para débito em uma linha e o valor monetário em outra. Não há valor sentinela para finalizar a entrada e o programa assume que o encerramento do fluxo de entrada implica no fim dos dados.\n/*\nAtualização de um saldo bancário a partir de uma sequência de movimentações de crédito ou débito ocorridas em um período\nRequer: o saldo inicial e uma sequência de transações, cada um fazendo indicando separadamente o tipo 'C' ou 'D' (crédito ou débito) e o valor\nAssegura: a apresentação do saldo atualizado\n\nTransações não reconhecidas são rejeitadas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Obtenção do saldo inicial\n    printf(\"Digite o saldo inicial: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double saldo;\n    sscanf(entrada, \"%lf\", &saldo);\n\n    // Atualização do saldo de acordo com as transações\n    printf(\"Digite Ctrl-D (Linux) ou Ctrl-Z (Windows) para encerrar.\\n\\n\"\n           \"Tipo (C ou D): \");\n    while (fgets(entrada, sizeof entrada, stdin) != NULL) {  // leitura do tipo\n        char tipo_transacao = '*';  // '*' = inválido\n        sscanf(entrada, \"%c\", &tipo_transacao);\n\n        printf(\"Valor: R$ \");\n        double valor_transacao;\n        fgets(entrada, sizeof entrada, stdin);  // leitura do valor\n        sscanf(entrada, \"%lf\", &valor_transacao);\n\n        switch (tipo_transacao) {\n            case 'C':\n                saldo += valor_transacao;\n                break;\n            case 'D':\n                saldo -= valor_transacao;\n                break;\n            default:\n                printf(\"Transação não reconhecida (%c).\\n\", tipo_transacao);\n        }\n\n        printf(\"Tipo (C ou D): \");  // próxima transação\n    }\n\n    // Apresentação do saldo atualizado\n    printf(\"\\nSaldo final: R$ %.2f.\\n\", saldo);\n\n    return 0;\n}\nDigite o saldo inicial: 5800.00\nDigite Ctrl-D (Linux) ou Ctrl-Z (Windows) para encerrar.\n\nTipo (C ou D): D\nValor: R$ 300.00\nTipo (C ou D): C\nValor: R$ 82.50\nTipo (C ou D): C\nValor: R$ 181.00\nTipo (C ou D): D\nValor: R$ 1.25\nTipo (C ou D): D\nValor: R$ 789.42\nTipo (C ou D): \nSaldo final: R$ 4972.83.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-while.html#footnotes",
    "href": "linguagem-c/repeticoes-com-while.html#footnotes",
    "title": "Repetições com while",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nO texto digitado como exemplo foi extraído de Dom Casmurro, de Machado de Assis, obtido em http://www.educadores.diaadia.pr.gov.br/arquivos/File/2010/literatura/obras_completas_literatura_brasileira_e_portuguesa/MACHADO_ASSIS/DCASMURRO/CASMURRO5.HTM.↩︎",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `while`"
    ]
  },
  {
    "objectID": "linguagem-c/modularizacao-com-vetores.html",
    "href": "linguagem-c/modularizacao-com-vetores.html",
    "title": "Modularização com vetores",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "linguagem-c/modularizacao-com-vetores.html#vetores-como-parâmetros",
    "href": "linguagem-c/modularizacao-com-vetores.html#vetores-como-parâmetros",
    "title": "Modularização com vetores",
    "section": "Vetores como parâmetros",
    "text": "Vetores como parâmetros"
  },
  {
    "objectID": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html",
    "href": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html",
    "title": "Endereçamento de memória e ponteiros nos programas",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEste capítulo aborda alguns detalhes sobre como os diversos elementos se relacionam à memória do dispositivo onde um programa é executado. Esse tema pode parecer desconexo do conteúdo de todos os capítulos anteriores, mas os conceitos descritos aqui são muito importantes para capítulos seguintes. Para capítulos anteriores este material complementa informações já apresentadas de forma mais superficial. Nos capítulos seguintes este conteúdo será relevante, pois são tratados mecanismos para modificar, dentro de funções, variáveis declaradas em outros escopos (?@sec-procedimentos, ?@sec-passagem-por-referencia) e também meios para requerer dinamicamente espaços para armazenamento de dados (?@sec-alocacao-dinamica-de-memoria).\nNesta parte do texto apenas os conceitos de armazenamento e uso da memória são abordados. As aplicações desses recursos para resolver problemas práticos da linguagem são abordados em outros lugares.",
    "crumbs": [
      "Linguagem C",
      "Acesso à memória",
      "Endereçamento de memória e ponteiros nos programas"
    ]
  },
  {
    "objectID": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html#selecionando-o-menor-valor",
    "href": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html#selecionando-o-menor-valor",
    "title": "Endereçamento de memória e ponteiros nos programas",
    "section": "Selecionando o menor valor",
    "text": "Selecionando o menor valor\nO exemplo seguinte usa um ponteiro para modificar o valor de uma entre duas variáveis. A variável a ser modificada é sempre a de valor mínimo.\n/*\n * Duplicando o valor mínimo com uso de ponteiro\n * Requer: dois valores reais quaisquer\n * Assegura: apresentação do dobro do valor mínimo e do valor máximo original\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    // Entrada\n    printf(\"Digite dois valores reais: \");\n    char entrada[160];\n    fgets(entrada, sizeof entrada, stdin);\n    double valor1, valor2;\n    sscanf(entrada, \"%lf%lf\", &valor1, &valor2);\n\n    // Duplicação do valor mínimo usando um ponteiro\n    double *ponteiro_minimo;\n    if (valor1 &lt; valor2)\n        ponteiro_minimo = &valor1;\n    else\n        ponteiro_minimo = &valor2;\n    *ponteiro_minimo = *ponteiro_minimo * 2;  // dobra o valor mínimo\n\n    // Apresentação do resultado\n    printf(\"valor1 = %g e valor2 = %g.\\n\", valor1, valor2);\n\n    return 0;\n}\nDigite dois valores reais: 10.7 18.2\nvalor1 = 21.4 e valor2 = 18.2.\nCom valor1 e valor2 lidos, a variável ponteiro_minimo pode apontar tanto para a primeira quanto para a segunda, a depender de seus valores.\nA estrutura if usada poderia ser substituída por uma atribuição com o condicional ternário:\nponteiro_minimo = (valor1 &lt; valor2) ? &valor1 : &valor2;",
    "crumbs": [
      "Linguagem C",
      "Acesso à memória",
      "Endereçamento de memória e ponteiros nos programas"
    ]
  },
  {
    "objectID": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html#sec-exemplo-varios-ponteiros-para-mesmo-local",
    "href": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html#sec-exemplo-varios-ponteiros-para-mesmo-local",
    "title": "Endereçamento de memória e ponteiros nos programas",
    "section": "Vários ponteiros para um mesmo local",
    "text": "Vários ponteiros para um mesmo local\nAssim como nada impede que duas ou mais variáveis double tenham um mesmo valor, também é possível que vários ponteiros armazenem o mesmo endereço. Nesse caso, diz-se que vários ponteiros apontam para o mesmo local.\nO programa seguinte define uma variável c do tipo char e usa três ponteiros para referenciá-la.\n/*\n * Uso de vários ponteiros para um mesmo local\n * Assegura: apresentação dos valores apontados dadas algumas modificações\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 'A';\n\n    char *p1, *p2, *p3;\n    p1 = p2 = p3 = &c;  // todos os ponteiros apontam para c\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    c = 'B';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    *p1 = 'C';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    *p2 = 'D';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    *p3 = 'E';\n    printf(\"c = %c; *p1 = %c; *p2 = %c; *p3 = %c.\\n\", c, *p1, *p2, *p3);\n\n    return 0;\n}\nc = A; *p1 = A; *p2 = A; *p3 = A.\nc = B; *p1 = B; *p2 = B; *p3 = B.\nc = C; *p1 = C; *p2 = C; *p3 = C.\nc = D; *p1 = D; *p2 = D; *p3 = D.\nc = E; *p1 = E; *p2 = E; *p3 = E.\nComo todas as variáveis (c, *p1, *p2 e *p3) estão se referenciando ao mesmo char na memória, esse caractere pode ser modificado por qualquer uma delas.",
    "crumbs": [
      "Linguagem C",
      "Acesso à memória",
      "Endereçamento de memória e ponteiros nos programas"
    ]
  },
  {
    "objectID": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html#copiando-referências",
    "href": "linguagem-c/enderecamento-de-memoria-e-ponteiros.html#copiando-referências",
    "title": "Endereçamento de memória e ponteiros nos programas",
    "section": "Copiando referências",
    "text": "Copiando referências\nAo se atribuir o endereço de uma variável a um ponteiro, o valor armazenado é o endereço de memória do primeiro byte dessa variável. Se houver outra variável do tipo ponteiro, esse endereço pode ser copiado para ela com uma atribuição simples. Dessa forma, como no exemplo da Seção 7.2, o resultado é que se tem mais de um ponteiro referenciando uma mesma posição.\n/*\n * Cópia de referência entre ponteiros\n * Assegura: apresentação dos valores apontados dadas algumas modificações\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = 'A';\n\n    char *p1 = &c;\n    char *p2 = p1;\n    printf(\"c = %c; *p1 = %c; *p2 = %c.\\n\", c, *p1, *p2);\n\n    c = 'X';\n    printf(\"c = %c; *p1 = %c; *p2 = %c.\\n\", c, *p1, *p2);\n\n    return 0;\n}\nc = A; *p1 = A; *p2 = A.\nc = X; *p1 = X; *p2 = X.\nNeste programa, p1 aponta para c ao receber &c. Para p2 é atribuído o valor de p1, o qual, nesse momento, é igual ao &c.",
    "crumbs": [
      "Linguagem C",
      "Acesso à memória",
      "Endereçamento de memória e ponteiros nos programas"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html",
    "title": "Variáveis e leituras em C",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nUm programa em C lida com dados, que podem ser de diferentes tipos, como int, long int ou double, por exemplo. Neste capítulo são apresentados onde os dados são armazenados nos programas (variáveis), seus nomes (identificadores) e como guardar e substituir os valores desses dados (atribuição e leitura).",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#estilo",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#estilo",
    "title": "Variáveis e leituras em C",
    "section": "Estilo",
    "text": "Estilo\nNos programas apresentados neste livro, todos os identificadores de variáveis e de funções são escritos em snake case, que é um estilo de escrita. No snake case, todas as letras usadas são minúsculas e, quando um identificador é composto de duas ou mais palavras, é usada a sublinha para separá-las.\nEssa regra é seguida mesmo quando os nomes possuem sua combinação de maiúsculas e minúsculas característicos. Desta forma, o armazenamento do CPF usará uma variável cpf, um cálculo envolvendo o pH usará ph ou a temperatura em Fahrenheit usará fahrenheit.\nEsse padrão não é necessariamente adotado pelas bibliotecas da linguagem, que usam abreviações e combinações de estilo próprias e independentes. Como exemplos, não é usado print_formatted, mas printf, e na manipulação de caracteres há uma função chamada strcat, que significa string concatenation (sim, concatenation é abreviada para cat).\n\n\n\n\n\n\nDica\n\n\n\nA aderência a um padrão no formato dos identificadores, qualquer que ela seja, é muito importante para códigos claros e compreensíveis. Uma vez escolhido um padrão, este deve ser mantido constante em todo o código.\n\n\nOs estilos usados nos programas implementados neste material estão descritos no ?@sec-guia-de-estilo.\n\n\n\n\n\n\nDica\n\n\n\nA versões mais atuais das especificações para a linguagem C permitem o uso de caracteres acentuados nos identificadores. Essa é uma prática de uso raro, porém.\n/*\nAumento de salário\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double salário_atual = 3500.00;\n    double porcentagem_aumento = 0.15;  // 15%\n\n    printf(\"Salário anterior: %.2f.\\n\", salário_atual);\n\n    salário_atual = salário_atual * (1 + porcentagem_aumento);\n    printf(\"Salário novo: %.2f.\\n\", salário_atual);\n\n    return 0;\n}\nSalário anterior: 3500.00.\nSalário novo: 4025.00.\nFica registrada uma recomendação de que somente caracteres ASCII simples sejam usados para os identificadores. A manutenção do código por terceiros, por exemplo, pode se tornar complicada se outros programadores, com configurações de teclado diferentes, simplesmente não conseguirem digitar o nome de uma variável, como um código escrito em tcheco com uma variável chamada stáří (idade).",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#identificadores-significativos",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#identificadores-significativos",
    "title": "Variáveis e leituras em C",
    "section": "Identificadores significativos",
    "text": "Identificadores significativos\nEm programas bem escritos a clareza é importante. O compilador não se importa com o nome escolhido para uma variável; essa escolha é para os humanos que leem o código fonte. A escolha de bons nomes ajuda a entender melhor o que o comandos fazem e, em consequência, permitem a identificação de erros, a correção dessas falhas e a incorporação de novas funcionalidades.\nA regra básica para escolher um nome de variável é deixar claro o que ela contém. A opção por um ou outro nome depende bastante do contexto e é nesse contexto que deve haver clareza. Como um exemplo, uma variável chamada nível pode conter um valor numérico correspondente ao nível de um reservatório ou então ser uma valor textual com valores esperados \"fácil\", \"médio\" ou \"difícil\".\nHá uma tendência natural (e bem comum) de associar as variáveis dos programas às variáveis da matemática, o que leva a escolha de variáveis com identificadores genéricos e não significativos, como x, t ou a. Em geral, se uma variável possui uma única letra, essa escolha não é uma boa opção. Há, porém, exceções.\n\n\n\n\n\n\nDica\n\n\n\nSe um programador precisar explicar, de alguma forma, o que uma variável contém, é porque o identificador dela foi mal escolhido.\n\n\nAo longo do livro, os programas usam variáveis com nomes significativos. Muitas vezes os nomes são longos, o que pode levar o programador a ter preguiça de digitá-los. Felizmente, os IDEs modernos possuem recursos de auto-completar as digitações, que eliminam essa dificuldade.\nUm problema de identificadores muito longos é que as linhas de código também ficam muito longas. Abreviações nos nomes podem ser empregadas, porém de forma criteriosa. Se temperatura é uma escolha clara para guardar um valor de temperatura, temp também pode ser. Porém temp é uma abreviação comum para um valor temporário e, em um contexto de temperaturas, não deve ser empregado.\n\n\n\n\n\n\nDica\n\n\n\nA decisão do comprimento de um identificador envolve clareza do código e a facilidade de visualização do código fonte por um humano. O programador deve balancear esses e quaisquer outros aspectos, sempre com o objetivo de tornar o código o mais inteligível possível.\n\n\nUma amostra de um código com identificadores pobremente escolhidos é apresentando na sequência. A ausência de documentação é proposital neste caso.\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 57;\n    int a = 1967;\n\n    int e = a + i;\n    printf(\"%d ou %d\\n\", e, e + 1);\n\n    return 0;\n}\n2024 ou 2025\nSegue agora uma nova versão do mesmo código, para o qual o compilador gera resultados idênticos (e provavelmente códigos executáveis iguais também).\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int idade = 10;\n    int ano_nascimento = 2013;\n\n    int estimativa_ano_atual = ano_nascimento + idade;\n    printf(\"%d ou %d\\n\", estimativa_ano_atual, estimativa_ano_atual + 1);\n\n    return 0;\n}\n2023 ou 2024\nHá claramente uma maior compreensão do propósito do programa nesta segunda versão. Nomes significativos ajudam a entender melhor o contexto como um todo.\nSegue, para fins didáticos, a versão final do código.\n/*\nEstimativa do ano atual dadas a idade e o ano de nascimento de uma pessoa.\nDuas estimativas são feitas, pois o ano corrente depende se a pessoa fez ou \nnão aniversário nesse ano.\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int idade = 10;\n    int ano_nascimento = 2013;\n\n    int estimativa_ano_atual = ano_nascimento + idade;\n    printf(\"%d ou %d\\n\", estimativa_ano_atual, estimativa_ano_atual + 1);\n\n    return 0;\n}\n2023 ou 2024",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#sec-leitura-de-valores-textuais",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#sec-leitura-de-valores-textuais",
    "title": "Variáveis e leituras em C",
    "section": "Leitura conteúdo textual com fgets",
    "text": "Leitura conteúdo textual com fgets\nNo programa seguinte, um nome é solicitado pelo programa e, em seguida, apresentado de volta juntamente com uma saudação.\n/* \nSaudação\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Digite seu nome: \");\n\n    char nome[80];\n    fgets(nome, sizeof nome, stdin);\n\n    printf(\"Olá, %s!\\n\", nome);\n\n    return 0;\n}\nDigite seu nome: Alfonso Cardoso\nOlá, Alfonso Cardoso\n!\nUma variável string é usada para o armazenamento de cadeias de caracteres. Em C, o tipo básico char é usado para indicar uma único caractere; porém, como textos são sequências de caracteres (letras, dígitos, pontuações), os colchetes colocados depois do identificador nome indicam o comprimento máximo de caracteres que a variável suporta. No caso, o programa pode armazenar até 80 caracteres, o que é suficiente para um nome.\nA função fgets (stdio.h) copia o que o usuário digitou no terminal, byte a byte, para a cadeia de caracteres. Esta função possui três parâmetros: o primeiro é para onde os dados digitados serão copiados (variável nome), o segundo é o comprimento da memória disponível para copiar (sizeof nome) e, por final, o último que é stdin, que é o fluxo de bytes vindo do teclado.\nNa execução do programa anterior, é possível notar que a exclamação é apresentada na linha de baixo, logo depois do nome. A razão para isso é que o ENTER também é passado ao programa. Assim, para que se obtenha apenas o nome, é preciso remover esse \\n. Essa ação é feita substituindo-se a mudança de linha por um caractere nulo (\\0).\n/* \nSaudação\n*/\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;  // para strlen\n\nint main(void) {\n    printf(\"Digite seu nome: \");\n\n    char nome[80];\n    fgets(nome, sizeof nome, stdin);\n    nome[strlen(nome) - 1] = '\\0';  // sobrepõe '\\0' ao '\\n'\n\n    printf(\"Olá, %s!\\n\", nome);\n\n    return 0;\n}\nDigite seu nome: Alfonso Cardoso\nOlá, Alfonso Cardoso!\nO comando nome[strlen(nome) - 1] = '\\0' determina a posição do \\n usando o comprimento do texto digitado dado por strlen e atribui ali o \\0. É importante notar que '\\0' é escrito usando aspas simples, pois é um único caractere. Esses aspectos são abordados em mais detalhes no ?@sec-dados-textuais.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#leitura-de-valores-numéricos",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#leitura-de-valores-numéricos",
    "title": "Variáveis e leituras em C",
    "section": "Leitura de valores numéricos",
    "text": "Leitura de valores numéricos\nToda digitação provida pelo usuário e passada ao programa é textual. Como exemplo, se o usuário digita 10 como entrada, o programa recebe os caracteres 1, 0 e o ENTER, ou seja, \"10\\n\". Para transformar essa sequência de caracteres em um int, por exemplo, é preciso convertê-la.\nA função sscanf pode ser usada para diversas conversões, pois ela analisa os caracteres e os interpreta adequadamente.\nPara exemplificar a leitura de dados numéricos, considere o problema de estimar qual é o ano atual baseado na idade de uma pessoa e de seu ano de nascimento. O cálculo é simples, apesar da resposta depender se a pessoa já fez ou não aniversário no ano atual. Desta forma, o Algoritmo 1 dá os dois possíveis resultados.\n\n\nAlgoritmo 1: Determinação do ano atual baseado na idade e no ano de nascimento de uma pessoa.\n\n\n\n/*\nDeterminação do ano atual com base na idade e do ano de nascimento de uma\n    pessoa\nRequer: A idade e o ano de nascimento de uma pessoa\nAssegura: As duas possibilidades do ano corrente, considerando se a\n    pessoa já fez ou não aniversário\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Qual sua idade? \");\n    fgets(entrada, sizeof entrada, stdin);\n    int idade;\n    sscanf(entrada, \"%d\", &idade);\n\n    printf(\"Que ano você nasceu? \");\n    fgets(entrada, sizeof entrada, stdin);\n    int ano_nascimento;\n    sscanf(entrada, \"%d\", &ano_nascimento);\n\n    int estimativa_ano_atual = ano_nascimento + idade;\n    printf(\"Se você já fez aniversário este ano, estamos em %d.\\n\",\n        estimativa_ano_atual);\n    printf(\"Se não, o ano é %d.\\n\", estimativa_ano_atual + 1);\n    printf(\"Bem, este é meu chute...\\n\");\n\n    return 0;\n}\nQual sua idade? 20\nQue ano você nasceu? 2003\nSe você já fez aniversário este ano, estamos em 2023.\nSe não, o ano é 2024.\nBem, este é meu chute...\nA linha que merece atenção neste programa é a que segue.\nsscanf(entrada, \"%d\", &idade);\nA função sscanf faz uma varredura na variável entrada (seu primeiro parâmetro), buscando um valor inteiro escrito em decimal (%d). Se achar o valor, faz a interpretação adequada e coloca o valor na variável inteira idade. É importante neste caso que a função precisa saber onde a variável está na memória e, assim, o operador &, que significa algo como “o local onde está”, é obrigatório. A linha de comando pode ser, então, lida da seguinte forma: “procure no texto contido em entrada um valor no formato %d e o armazene na memória onde está a variável idade”.\nPara o ano de nascimento o procedimento é exatamente igual e a variável entrada é reaproveitada para fazer a segunda leitura.\nUma observação relevante é que, na interpretação da linha pela busca do valor inteiro, o sscanf ignora qualquer texto em branco antes dos dígitos numéricos esperados, como espaços e tabulações. Ele também encerra a interpretação ao encontrar qualquer coisa que não seja compatível com o tipo buscado e, desta forma, o \\n no final de entrada é automaticamente ignorado.\nSegue novo exemplo, com leituras simples, agora usando valores reais armazenados em variáveis double.\n/*\nLeitura de variáveis do tipo double\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double valor1;\n    sscanf(entrada, \"%lf\", &valor1);\n\n    printf(\"Digite outro valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double valor2;\n    sscanf(entrada, \"%lf\", &valor2);\n\n    printf(\"%g + %g = %g\\n\", valor1, valor2, valor1 + valor2);\n\n    return 0;\n}\nDigite um valor real: 872.2\nDigite outro valor real: 1.03e5\n872.2 + 103000 = 103872\nValores do tipo double usam a especificação de formato %lf (%g só é usado no printf) e a interpretação é feita agora pela busca de qualquer combinação que possa ser interpretada como um valor real válido, incluindo a notação científica usada no exemplo.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#leitura-de-um-único-caractere",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#leitura-de-um-único-caractere",
    "title": "Variáveis e leituras em C",
    "section": "Leitura de um único caractere",
    "text": "Leitura de um único caractere\nA função fgets, por si só, obtém o texto digitado no terminal. O filtro para que apenas o primeiro caractere seja capturado em uma variável do tipo char pode ser feito também com o sscanf usando-se o indicador de formato %c.\n/*\nLeitura de um valor em uma variável do tipo char com sscanf\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um caractere: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    char caractere;\n    sscanf(entrada, \"%c\", &caractere);\n    printf(\"O caractere digitado foi o %c\\n\", caractere);\n    printf(\"Seu código hexadecimal ASCII é %X\\n\", caractere);\n\n    return 0;\n}\nDigite um caractere: M\nO caractere digitado foi o M\nSeu código hexadecimal ASCII é 4D\nNo exemplo, na variável entrada é armazenada a sequência M\\n, ou seja o M digitado e o ENTER usado para enviar a linha ao programa. Com o %c do sscanf, somente o primeiro caractere da entrada é considerado, ignorando-se tudo o que existe depois dele. Na prática, depois do M do exemplo poderiam vir quaisquer outros caracteres e somente o primeiro é extraído de entrada.\nPara este exemplo em particular, há uma forma mais simples e direta de obter o primeiro caractere do que o usuário digitou. Isso é feito explicitamente selecionando o primeiro caractere da variável: entrada[0].\n/*\nLeitura de um valor em uma variável do tipo char usando indexação da cadeia\nde entrada\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um caractere: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    char caractere = entrada[0];\n    printf(\"O caractere digitado foi o %c\\n\", caractere);\n    printf(\"Seu código hexadecimal ASCII é %X\\n\", caractere);\n\n    return 0;\n}\nDigite um caractere: m\nO caractere digitado foi o m\nSeu código hexadecimal ASCII é 6D\nEsta última versão é, na opinião do autor, mais simples e direta, superando a leitura a obtenção do caractere com o sscanf.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#várias-leituras-em-uma-única-linha",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#várias-leituras-em-uma-única-linha",
    "title": "Variáveis e leituras em C",
    "section": "Várias leituras em uma única linha",
    "text": "Várias leituras em uma única linha\nÉ bastante comum, em programas que processam dados, que uma linha possa conter mais que um valor. Desta forma, é preciso indicar ao sscanf para varrer a cadeia de entrada por mais que um valor.\nO programa seguinte implementa o Algoritmo 2 e mostra a leitura de coordenadas em \\(\\mathbb{R}^2\\). O programa solicita os valores para \\(x\\) e para \\(y\\), mas ambos devem ser digitados na mesma linha. Como resultado, o programa apresenta a distância desse ponto à origem do sistema de coordenadas.\n\n\nAlgoritmo 2: Distância de um ponto \\((x, y)\\) à origem\n\n\n\n/*\nCálculo e apresentação da distância de um ponto em R^2 à origem, tendo como\n    entrada os valores das coordenadas x e y desse ponto\nRequer: x e y\nAssegura: a distância de (x, y) à (0, 0)\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;  // para sqrt (raiz quadrada)\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os valores de x e y: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    double x, y;\n    sscanf(entrada, \"%lf%lf\", &x, &y);\n\n    double distancia_origem = sqrt(x * x + y * y);\n    printf(\"A distância de (%g, %g) a (0, 0) é %g.\\n\", x, y, distancia_origem);\n\n    return 0;\n}\nDigite os valores de x e y: 3.2 -1.8\nA distância de (3.2, -1.8) a (0, 0) é 3.67151.\nPrimeiramente é relevante destacar o uso da função sqrt (square root) para o cálculo da raiz quadrada, a qual está especificada no arquivo de cabeçalho math.h, que deve ser incluído no preâmbulo do código fonte. Para o cálculo do quadrado foi usado o “truque” elementar que \\({x^2 = x\\cdot x}\\). Além disso, como biblioteca de funções matemáticas não é automaticamente incluída durante a compilação, deve ser acrescentada a opção -lm (i.e., faça a ligação, link, com a biblioteca matemática m) no final da linha de compilação com o gcc.\nVoltando agora para leitura, o destaque é para a especificação de formato %lf%lf usada no sscanf. Ela indica que dois valores reais devem ser buscados em entrada e cada um deve ser armazenado, respectivamente, nas variáveis x e y, ambas double. A ordem das variáveis deve corresponder à ordem em que os valores são digitados. Como já apresentado, as leituras de valores numéricos ignoram caracteres brancos antes de encontrar o valor em si, de forma que espaços ou tabulações antes de cada %lf são descartadas na varredura da linha, o que significa que, na digitação, a quantidade de espaços antes de cada valor é irrelevante. De forma complementar, tudo o que não corresponder a um valor real que apareça depois do segundo valor também é descartado.\nA mistura de diferentes tipos em uma única linha também é possível, como indica o exemplo na sequência.\n/*\nExemplos de leituras de tipos diferentes em uma mesma linha\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n    double d;\n    int i1, i2;\n    char c;\n\n    printf(\"Digite um inteiro e um real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%lf\", &i1, &d);\n    printf(\"O inteiro é %d e o o real é %g.\\n\\n\", i1, d);\n\n    printf(\"Digite um inteiro, um real e outro inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%lf%d\", &i1, &d, &i2);\n    printf(\"Os inteiros são %d e %d; o o real é %g.\\n\\n\", i1, i2, d);\n\n    printf(\"Digite um real seguido por um caractere: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%lf%c\", &d, &c);\n    printf(\"O real é %g e o caractere é %c.\\n\\n\", d, c);\n\n    return 0;\n}\nDigite um inteiro e um real: 320 44.5\nO inteiro é 320 e o o real é 44.5.\n\nDigite um inteiro, um real e outro inteiro: 10 1.1 20\nOs inteiros são 10 e 20; o o real é 1.1.\n\nDigite um real seguido por um caractere: 0.125ee\nO real é 0.125 e o caractere é e.\nExistem, naturalmente e previsivelmente, limitações nas leituras. Por exemplo, a última varredura usando %lf%c para obter um número real e um caractere esbarra na capacidade de análise dos caracteres digitados. Por exemplo, se o usuário digitar 0.1235A é possível separar o 0,125 da letra A; se for digitado 0.125 A, a variável d conterá o valor 0,125, mas c conterá o espaço, que é o próximo caractere depois do número, sendo o A\\n que sobram ignorados. Além disso, é impossível com esse formato que o caractere seja um dígito, pois ele seria interpretado como parte do número e não como o caractere depois do número.\nO contorno de tais limitações foge do escopo deste material.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#um-pouco-mais-sobre-o-sscanf",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#um-pouco-mais-sobre-o-sscanf",
    "title": "Variáveis e leituras em C",
    "section": "Um pouco mais sobre o sscanf",
    "text": "Um pouco mais sobre o sscanf\nO objetivo da função sscanf é analisar uma cadeia de caracteres procurando por padrões, os quais, reconhecidos adequadamente, são convertidos para o tipo indicado e atribuído às variáveis indicadas por seus endereços (razão do operador & usado nos exemplos diversos). Assim, ao se especificar %d%d%lf o sscanf espera encontrar dois inteiros e um real, nesta ordem. Para sumarizar, a Tabela 2 apresenta as principais especificações de formato usadas no sscanf.\n\n\n\nTabela 2: Relação entre formatos e tipos utilizados pelo sscanf.\n\n\n\n\n\nEspecificação\nTipo associado\n\n\n\n\n%d\nint\n\n\n%ld\nlong int\n\n\n%f\nfloat\n\n\n%lf\ndouble\n\n\n%c\nchar\n\n\n%s\nchar[\\(n\\)]",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#sobre-os-padrões-interpretados-no-sscanf",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#sobre-os-padrões-interpretados-no-sscanf",
    "title": "Variáveis e leituras em C",
    "section": "Sobre os padrões interpretados no sscanf",
    "text": "Sobre os padrões interpretados no sscanf\nO padrão especificado no segundo parâmetro da função sscanf é muito mais poderoso do que apenas a busca por números ou caracteres. Seguem alguns poucos exemplos sobre a versatilidade do sscanf na sua interpretação.\n/*\nCálculo e apresentação da distância de um ponto em R^2 à origem, tendo como\n    entrada os valores das coordenadas x e y desse ponto\nRequer: o ponto (x, y)\nAssegura: a distância de (x, y) à (0, 0)\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um ponto no formato (x, y): \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    double x, y;\n    sscanf(entrada, \"(%lf,%lf)\", &x, &y);\n\n    double distancia_origem = sqrt(x * x + y * y);\n    printf(\"A distância de (%g, %g) a (0, 0) é %g.\\n\", x, y, distancia_origem);\n\n    return 0;\n}\nDigite um ponto no formato (x, y): (3.2, -1.8)\nA distância de (3.2, -1.8) a (0, 0) é 3.67151.\nEste exemplo é uma releitura do programa que calcula a distância de um ponto à raiz, com referência ao Algoritmo 2. Nesta nova versão, a digitação da entrada deve seguir o formato convencional de representação de um ponto no plano, ou seja, circundar os valores com parênteses e usar uma vírgula para separar os \\(x\\) de \\(y\\). O padrão que foi dado é (%lf,%lf), o que significa que a função espera, nesta sequência, um abre parênteses, um valor real, uma vírgula, outro valor real e um fecha parênteses. O conteúdo provavelmente não será interpretado corretamente se o padrão não for completamente satisfeito.\nO padrão de interpretação pode indicar que um dado valor será ignorado da interpretação. Para isso, um asterisco deve ser adicionado logo depois do símbolo %. Por exemplo, %*lf significa que um valor real deve ser reconhecido, mas seu valor será descartado. O exemplo seguinte mostra como, de uma linha com dois valores inteiros, utilizar apenas o segundo.\n/*\nLeitura de uma linha com quatro inteiros, porém descartando o primeiro e\no terceiro\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite quatro valores inteiros: \");\n    fgets(entrada, sizeof entrada, stdin);\n\n    int segundo, quarto;\n    sscanf(entrada, \"%*d%d%*d%d\", &segundo, &quarto);\n\n    printf(\"Valores de interesse: %d e %d.\\n\", segundo, quarto);\n\n    return 0;\n}\nDigite quatro valores inteiros: 6652 943 7609 -7\nValores de interesse: 943 e -7.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#erros-de-interpretação-do-padrão",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#erros-de-interpretação-do-padrão",
    "title": "Variáveis e leituras em C",
    "section": "Erros de interpretação do padrão",
    "text": "Erros de interpretação do padrão\nA função sscanf é capaz de interpretar corretamente um valor numérico tanto quanto o valor faça sentido. Se houver um erro na interpretação, a análise da varredura é interrompida e o valores corretamente convertidos são atribuídos às respectivas variáveis; as variáveis restantes não têm seu valor modificado.\nO exemplo seguinte apresenta a situação de duas leituras\n/*\nLeituras corretas e incorretas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Valores iniciais\n    int i1 = 1, i2 = 2, i3 = 3, i4 = 4;\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n\n    // Leitura 1\n    printf(\"Digite os valores para i1, i2, i3 e i4: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%d%d%d\", &i1, &i2, &i3, &i4);\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n\n    // Leitura 2\n    printf(\"Digite os valores para i1, i2, i3 e i4: \");\n    fgets(entrada, sizeof entrada, stdin);\n    sscanf(entrada, \"%d%d%d%d\", &i1, &i2, &i3, &i4);\n    printf(\"i1 = %d; i2 = %d; i3 = %d; i4 = %d.\\n\\n\", i1, i2, i3, i4);\n\n    return 0;\n}\ni1 = 1; i2 = 2; i3 = 3; i4 = 4.\n\nDigite os valores para i1, i2, i3 e i4: 10 20 30 40\ni1 = 10; i2 = 20; i3 = 30; i4 = 40.\n\nDigite os valores para i1, i2, i3 e i4: 100 200 abc 400\ni1 = 100; i2 = 200; i3 = 30; i4 = 40.\nNa primeira leitura do programa, todos os valores são lidos corretamente e todas as atribuições são feitas. Na segunda leitura a varredura falha ao encontrar abc quando um número inteiro era esperado. Com o erro na interpretação, apenas i1 e i2 são atualizados, enquanto i3 e i4 não têm seus valores modificados.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/variaveis-identificadores-e-leitura.html#footnotes",
    "href": "linguagem-c/variaveis-identificadores-e-leitura.html#footnotes",
    "title": "Variáveis e leituras em C",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nMais detalhes sobre valores iniciais de variáveis são apresentados no ?@sec-regras-de-escopo-com-modularizacao.↩︎",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Variáveis e leituras em C"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-for.html",
    "href": "linguagem-c/repeticoes-com-for.html",
    "title": "Repetições com for",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA linguagem C permite laços de repetição, sendo um deles dado pelo for. Neste capítulo essa estrutura é abordada.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `for`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-for.html#média-de-24-temperaturas",
    "href": "linguagem-c/repeticoes-com-for.html#média-de-24-temperaturas",
    "title": "Repetições com for",
    "section": "Média de 24 temperaturas",
    "text": "Média de 24 temperaturas\nNa linha do exemplo das temperaturas hora a hora é apresentado o Algoritmo 1, o qual determina a média das temperaturas colhidas a cada hora de um dia.\n\n\nAlgoritmo 1: Cálculo da média das temperaturas horárias de um dia\n\n\n\nSegue, agora, a implementação desse algoritmo.\n/*\nCálculo da média de 24 medidas de temperatura colhidas hora a hora durante um dia\nRequer: uma sequência de 24 temperaturas em Celsius\nAssegura: a média dessas temperaturas\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Digite as temperaturas.\\n\");\n\n    double soma_temperaturas = 0;\n    for (int hora = 0; hora &lt; 24; hora++) {\n        char entrada[160];\n        printf(\"Temperatura de %2dh: \", hora);\n        fgets(entrada, sizeof entrada, stdin);\n        double temperatura;\n        sscanf(entrada, \"%lf\", &temperatura);\n\n        soma_temperaturas += temperatura;\n    }\n\n    printf(\"Média diária: %.1fºC.\\n\", soma_temperaturas / 24);\n\n    return 0;\n}\nDigite as temperaturas.\nTemperatura de  0h: 9.7\nTemperatura de  1h: 9.6\nTemperatura de  2h: 10.6\nTemperatura de  3h: 8.1\nTemperatura de  4h: 14.1\nTemperatura de  5h: 14.5\nTemperatura de  6h: 12.1\nTemperatura de  7h: 18.2\nTemperatura de  8h: 19.2\nTemperatura de  9h: 20.7\nTemperatura de 10h: 24.2\nTemperatura de 11h: 24.5\nTemperatura de 12h: 18.4\nTemperatura de 13h: 23.1\nTemperatura de 14h: 21.5\nTemperatura de 15h: 21.9\nTemperatura de 16h: 23.9\nTemperatura de 17h: 23.7\nTemperatura de 18h: 18.7\nTemperatura de 19h: 20.4\nTemperatura de 20h: 16.6\nTemperatura de 21h: 14.2\nTemperatura de 22h: 8.0\nTemperatura de 23h: 9.5\nMédia diária: 16.9ºC.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `for`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-for.html#áreas-de-triângulos",
    "href": "linguagem-c/repeticoes-com-for.html#áreas-de-triângulos",
    "title": "Repetições com for",
    "section": "Áreas de triângulos",
    "text": "Áreas de triângulos\nO Algoritmo 2 é uma proposta de nível alto para a determinação da área de uma dada quantidade de triângulos. A quantidade de áreas a serem calculadas é a primeira entrada esperada pela solução.\n\n\nAlgoritmo 2: Cálculo da área de uma sequência de triângulos.\n\n\n\nPara mais detalhes, segue a versão do Algoritmo 2 com menor grau de abstração. Nesta versão optou-se por fazer o cálculo da área por semiperímetro.\n\n\nAlgoritmo 3: Cálculo da área de uma sequência de triângulos usando o semiperímetro.\n\n\n\nUma implementação do Algoritmo 3 em C é apresentada na sequência.\n/*\nCálculo da área de diversos triângulos definidos pelas coordenadas em R^2\n    de seus vértices\nRequer: a quantidade de triângulos seguida pelas coordenadas $(x,y)$ de\n    cada vértice do triângulo\nAssegura: a apresentação de cada área calculada\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite a quantidade de triângulos: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int quantidade;\n    sscanf(entrada, \"%d\", &quantidade);\n\n    for (int i = 1; i &lt;= quantidade; i++) {\n        printf(\"Triângulo %d:\\n\"\n               \"Digite x e y do vértice 1: \", i);\n        fgets(entrada, sizeof entrada, stdin);\n        double x1, y1;\n        sscanf(entrada, \"%lf%lf\", &x1, &y1);  // (x1, y1)\n        printf(\"Digite x e y do vértice 2: \");\n        fgets(entrada, sizeof entrada, stdin);\n        double x2, y2;\n        sscanf(entrada, \"%lf%lf\", &x2, &y2);  // (x2, y2)\n        printf(\"Digite x e y do vértice 3: \");\n        fgets(entrada, sizeof entrada, stdin);\n        double x3, y3;\n        sscanf(entrada, \"%lf%lf\", &x3, &y3);  // (x3, y3)\n\n        double lado1 = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));\n        double lado2 = sqrt(pow(x1 - x3, 2) + pow(y1 - y3, 2));\n        double lado3 = sqrt(pow(x2 - x3, 2) + pow(y2 - y3, 2));\n        double semiperimetro = (lado1 + lado2 + lado3) / 2;\n\n        double area = sqrt(semiperimetro * (semiperimetro - lado1) *\n                           (semiperimetro - lado2) * (semiperimetro - lado3));\n\n        printf(\"Área do triângulo %d: %.2f.\\n\\n\", i, area);\n    }\n\n    return 0;\n}\nDigite a quantidade de triângulos: 2\nTriângulo 1:\nDigite x e y do vértice 1: 0 0\nDigite x e y do vértice 2: 0 1\nDigite x e y do vértice 3: 1 0\nÁrea do triângulo 1: 0.50.\n\nTriângulo 2:\nDigite x e y do vértice 1: -1.5 -1\nDigite x e y do vértice 2: 1.5 -1\nDigite x e y do vértice 3: 0 3.8\nÁrea do triângulo 2: 7.20.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `for`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-for.html#desenho-de-um-círculo",
    "href": "linguagem-c/repeticoes-com-for.html#desenho-de-um-círculo",
    "title": "Repetições com for",
    "section": "Desenho de um “círculo”",
    "text": "Desenho de um “círculo”\nO programa seguinte mostra o aninhamento de dois laços for. Cada um deles vai de -10 a 10 e a saída é um * caso a distância ao “centro” seja menor que 10. No programa, ao invés de calcular \\({\\sqrt{x^2 + y^2} \\leq 10}\\), optou-se por usar a expressão equivalente \\({x^2 + y^2 \\leq 10^2}\\), que não requer calcular a raiz quadrada.\n/*\nDesenho de um círculo usando caracteres\nAssegura: apresentação de um círculo tão razoável quanto possível\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    for (int x = -10; x &lt;= 10; x++) {\n        for (int y = -10; y &lt;= 10; y++)\n            if (x * x + y * y &lt;= 100)  // distância &lt; 10\n                printf(\"XXX\");  // no círculo\n            else\n                printf(\"   \");  // fora do círculo\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n                              XXX                              \n                  XXXXXXXXXXXXXXXXXXXXXXXXXXX                  \n            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX            \n         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX         \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      \n         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX         \n            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX            \n                  XXXXXXXXXXXXXXXXXXXXXXXXXXX                  \n                              XXX                              \nComo cada caractere escrito sempre tem altura maior que a largura, optou-se por usar três caracteres para cada posição para tentar compensar essa diferença e obter o “círculo” com menor distorção. A escolha por três caracteres foi feita por tentativa e erro.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `for`"
    ]
  },
  {
    "objectID": "linguagem-c/execucao-condicional-com-if.html",
    "href": "linguagem-c/execucao-condicional-com-if.html",
    "title": "Execução condicional com if",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA maioria dos programas requer que alguns comandos apenas sejam executados em algumas condições e isso é chamado, naturalmente, de execução condicional.\nA principal estrutura na linguagem C para determinar se determinados comandos são ou não executados é o if. Esta estrutura é o assunto deste capítulo.\n\nA estrutura condicional if\nPara introduzir a estrutura condicional é apresentado um programa que implementa o Algoritmo 1.\n\n\nAlgoritmo 1: Apresentação de dois valores reais em ordem não decrescente.\n\n\n\nA codificação em C deste algoritmo pode ser feita como se segue.\n/*\nApresentação de dois valores em ordem não decrescente\nRequer: dois valores reais v1 e v2\nAssegura: v1 &lt;= v2\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite dois valores reais: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double v1, v2;\n    sscanf(entrada, \"%lf%lf\", &v1, &v2);\n\n    if(v2 &lt; v1) {\n        double temporario = v1;\n        v1 = v2;\n        v2 = temporario;\n    }\n\n    printf(\"Valores em ordem não decrescente: %g e %g.\\n\", v1, v2);\n    \n    return 0;\n}\nDigite dois valores reais: 4.5 1.3\nValores em ordem não decrescente: 1.3 e 4.5.\nA estratégia da implementação é a mesma do algoritmo, que opta por fazer a troca dos valores (e isso requer o uso de uma variável temporária auxiliar). As três instruções que realizam a troca somente são executadas quando v2 for menor que v1 e ignoradas se isso não for verdade\nÉ importante ressaltar que as chaves agrupam as três atribuições do if, de forma que todos os comandos ficam condicionados. O uso das chaves para agrupar comandos cria um comando composto, o qual pode ser usado no lugar de qualquer comando simples.\nEm C, a estrutura básica do if se estabelece conforme destacado na sequência.\n\n\n\n\n\n\nEstrutura if básica\n\n\n\nif ( condição ) comando\n\n\nA condição é uma expressão que deve resultar em verdadeiro ou falso. Somente se a condição for verdadeira comando é executado. O comando, por sua vez, pode ser tanto um comando simples (terminado com ponto e vírgula) ou um comando composto (usando chaves).\nSeguem dois exemplos válidos de estruturas if: a primeira usa um comando simples e, na segunda, um comando composto contendo apenas um comando simples. É interessante observar que o ponto e vírgula ocorre apenas no final do comando simples, enquanto comandos compostos não usam esse terminador depois do fecha chaves.\nif(valor &lt; 0)\n    valor = -valor; // torna positivo\nif(valor &lt; 0) {\n    valor = -valor; // torna positivo\n}\n\n\nif + else\nA cláusula else pode ser adicionada ao if para indicar uma ação a ser feita caso a condição de teste seja avaliada como falsa.\n\n\n\n\n\n\nEstrutura if completa\n\n\n\nif ( condição ) comando_verdade else comando_falso\n\n\nComo exemplo, considere o problema de determinar o peso (massa) ideal de uma pessoa baseada em seu sexo biológico. Para o sexo feminino, o peso em quilogramas é dado pela expressão 62,1\\(h\\)  -  44,7, sendo \\(h\\) a altura da pessoa em metros; para o masculino, o cálculo é 72,7\\(h\\) - 58. Seguem a solução algorítmica e uma implementação em C para esse problema.\n\n\nAlgoritmo 2: Estimativa do peso ideal conforme sexo biológico e altura.\n\n\n\n/*\nCálculo estimado da massa ideal de uma pessoa baseada em seu sexo biológico\n    e sua altura\nRequer: o sexo biológico (masculino ou feminino) e a altura em metros\nAssegura: a massa ideal da pessoa apresentada (kg)\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o sexo (M ou F) e a altura em quilogramas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    char sexo;\n    double altura;\n    sscanf(entrada, \"%c%lf\", &sexo, &altura);\n\n    double massa_ideal;\n    if(sexo == 'F')\n        massa_ideal = 62.1 * altura - 44.7;  // feminino\n    else\n        massa_ideal = 72.7 * altura - 58;  // masculino\n\n    printf(\"Massa ideal: %.1fkg.\", massa_ideal);\n\n    return 0;\n}\nDigite o sexo (M ou F) e a altura em quilogramas: F 1.68\nMassa ideal: 59.6kg.\nNeste há dois caminhos possíveis: o cálculo como sexo biológico feminino ou masculino. Pela especificação do problema, apenas M ou F são entradas válidas, o que permitiu associar ao else, inequivocamente, o valor M. Em C, vale o destaque que = é usado para a atribuição, sendo que a comparação de igualdade é feita com ==.\nEm relação ao if, tanto no caso verdadeiro quanto no falso foram inseridos comandos simples.\nComo exemplo adicional, um algoritmo para classificar um triângulo como equilátero, escaleno ou isósceles a partir do comprimento de seus lados é apresentado no Algoritmo 3.\n\n\nAlgoritmo 3: Classificação de um triângulo em relação aos comprimentos de seus lados\n\n\n\nEm C, a codificação pode ser expressa na forma seguinte.\n#include &lt;stdio.h&gt;\n/*\nClassificação de um triângulo em relação aos comprimentos de seus lados\nRequer: Os comprimentos dos lados de um triângulo válido\nAssegura: uma classificação em equilátero, escaleno ou isósceles\n*/\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digites os comprimentos dos lados de um triângulo: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double lado1, lado2, lado3;\n    sscanf(entrada, \"%lf%lf%lf\", &lado1, &lado2, &lado3);\n\n    char *classificacao;\n    if(lado1 == lado2 && lado2 == lado3)\n        classificacao = \"equilátero\";\n    else if(lado1 == lado2 || lado2 == lado3 || lado1 == lado3)\n        classificacao = \"escaleno\";\n    else\n        classificacao = \"isósceles\";\n\n    printf(\"O triângulo é %s.\\n\", classificacao);\n\n    return 0;\n}\nDigites os comprimentos dos lados de um triângulo: 9.1 4.3 9.1\nO triângulo é escaleno.\nO programa usa comandos simples para as atribuições, o que dispensa os comandos compostos com as chaves. Na lógica da solução inicialmente verificada a hipótese dos três lados iguais (equilátero). Caso essa verificação dê falso, então há pelo menos um lado diferente e isso leva ao segundo if, que verifica a hipótese de haver algum par de lados de mesmo comprimento.\nEste programa, além do if e algumas operações lógicas com e e ou, também usa uma variável classificacao declarada como do tipo char *. Quando são feitas atribuições como as usadas no exemplo a esse tipo de variável, é feita apenas uma referência à constante e não uma atribuição convencional, na qual uma cópia do texto é guardada na variável. A manipulação de cadeias de caracteres em C é, para se bem dizer, chata e difícil. Como ela não é tão natural, acaba exigindo conhecimento de outros elementos da linguagem. O ?@sec-dados-textuais aborda esse tema com mais detalhes.\n\n\n\n\n\n\nDica\n\n\n\nNas comparações com valores double resultantes de expressões aritméticas, nunca se deve verificar pela igualdade. Os valores reais são armazenados com precisão limitada. É conveniente o uso uma tolerância nessas comparações.\n/* \nIlustração do problema de precisão nas operações com double\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    double a = 40.96;\n    double b = 6.4 * 6.4;  // 40.96\n\n    // Opção ruim\n    if(a == b)\n        printf(\"%g == %g.\\n\", a, b);\n    else {\n        printf(\"%g != %g.  :-(\\n\", a, b);\n        printf(\"Diferença: %g.\\n\\n\", a - b);\n    }\n\n    // Opção melhor, contornando o problema\n    if(fabs(a - b) &lt; 1e-5)  // cinco casas decimais...\n        printf(\"%g == %g. (o suficiente!)\\n\", a, b);\n    else {\n        printf(\"%g != %g.  :-(\\n\", a, b);\n        printf(\"Diferença: %g.\\n\\n\", a - b);\n    }\n\n    return 0;\n}\n40.96 != 40.96.  :-(\nDiferença: -7.10543e-15.\n\n40.96 == 40.96. (o suficiente!)\nNeste programa, se a diferença for menor que 0,00001 (segundo if), então os valores são considerados iguais. A tolerância, é claro, depende do contexto do problema.\n\n\nComo um último exemplo, segue o algoritmo para o cálculo das raízes reais de uma equação de segundo grau \\({ax^2 + bx + c = 0}\\) dados seus coeficientes (Algoritmo 1, apresentado no ?@sec-nocoes-de-algoritmos).\n\nSua codificação em C pode ser apresentada conforme se segue.\n/*\nCálculo e apresentação das raízes reais de uma equação de segundo grau na\n    forma ax^2 + bx + c = 0\nRequer: Os coeficientes a, b e c da equação\nAssegura: as raízes reais da equação; ou mensagem que a equação é\n    inválida; ou mensagem que não há raízes reais\n*/\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os valores de a, b e c da equação: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double a, b, c;\n    sscanf(entrada, \"%lf%lf%lf\", &a, &b, &c);\n\n    if(a == 0)\n        printf(\"Não é equação do segundo grau (a = 0).\\n\");\n    else {\n        double discriminante = pow(b, 2) - 4 * a * c;\n        if(discriminante &lt; 0)\n            printf(\"A equação não possui raízes reais.\\n\");\n        else if(discriminante &lt; 1.0e-10) {  // tolerância: &lt; 1.0e-10 é \"zero\"\n            // Uma raiz real\n            double x = -b / (2 * a);\n            printf(\"Uma raiz: %g.\\n\", x);\n        }\n        else {\n            // Duas raízes reais\n            double x1 = (-b - sqrt(discriminante)) / (2 * a);\n            double x2 = (-b + sqrt(discriminante)) / (2 * a);\n            printf(\"Raízes reais: %g e %g.\\n\", x1, x2);\n        }\n    }\n\n    return 0;\n}\nDigite os valores de a, b e c da equação: 1 -5.9 7.14\nRaízes reais: 1.7 e 4.2.\n\n\nDe quem é esse else?\nUm ponto relevante quando se usa if dentro de if é a quem pertence um determinado else. Para considerar esse problema é apresentado um código em C.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 5;\n\n    if(k &gt; 10)\n        if (k &gt; 20)\n            i = 10;\n    else \n        j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\ni = 0 e j = 0.\nA intenção do código seria fazer j = 10 para valores de k menores ou iguais a 10. Porém, apesar da organização visual sugerir que o else pertence ao if(k &gt; 10), ele se liga ao if(k &gt; 20). Assim, independentemente da disposição dos comandos no codigo fonte, o programa será sempre interpretado como se segue. E, neste caso, o primeiro if não possui else.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 5;\n\n    if(k &gt; 10)\n        if (k &gt; 20)\n            i = 10;\n        else \n            j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\nO else sempre se ligará ao if mais próximo da sequência das instruções. Para resolver esse problema do exemplo, é preciso isolar o if mais interno, colocando-o em um bloco, formando um comando composto.\nO resultado é apresentado na sequência.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 5;\n\n    if(k &gt; 10) {\n        if (k &gt; 20)\n            i = 10;\n    }\n    else \n        j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\ni = 0 e j = 10.\nÉ ainda interessante notar que, caso o if(k &gt; 20) tivesse seu próprio else, a ambiguidade desapareceria e o comando composto seria desnecessário.\n/*\nIlustração do problema do else pendente\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 0;\n    int j = 0;\n\n    int k = 15;\n\n    if(k &gt; 10) \n        if (k &gt; 20)\n            i = 10;\n        else\n            i = 20;\n    else \n        j = 10;\n\n    printf(\"i = %d e j = %d.\\n\", i, j);\n    \n    return 0;\n}\ni = 20 e j = 0.\n\n\n\n\n\n\nDica\n\n\n\nA manutenção da organização visual do código com as indentações corretas ajuda na identificação dos erros.\n\n\n\n\nBoas práticas\n\nEvitação de redundância nas condições.\nEscrita de código com legibilidade.\nEvitação de comparações desnecessárias.\nCuidado com a qual if um dado else pertence.\nEmprego coerente de declarações locais a comandos compostos (blocos).\nEvitação de “sombreamento” de identificadores (repetição de identificador em escopos diferentes muito próximos).",
    "crumbs": [
      "Linguagem C",
      "Controle de fluxo simples",
      "Execução condicional com `if`"
    ]
  },
  {
    "objectID": "linguagem-c/execucao-condicional-com-switch.html",
    "href": "linguagem-c/execucao-condicional-com-switch.html",
    "title": "Execução condicional com switch",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nA linguagem C provê, além do if, uma segunda estrutura para execução condicional: o switch.",
    "crumbs": [
      "Linguagem C",
      "Controle de fluxo simples",
      "Execução condicional com `switch`"
    ]
  },
  {
    "objectID": "linguagem-c/execucao-condicional-com-switch.html#sec-entendendo-o-switch",
    "href": "linguagem-c/execucao-condicional-com-switch.html#sec-entendendo-o-switch",
    "title": "Execução condicional com switch",
    "section": "Entendendo o switch",
    "text": "Entendendo o switch\nO switch é uma estrutura da linguagem usada para estabelecer uma sequência de instruções.\n\n\n\n\n\n\nEstrutura switch\n\n\n\nswitch ( expressão ) comando\n\n\nA expressão é qualquer expressão que resulte em um valor escalar, como int, char ou mesmo bool. Por sua vez, comando é um bloco delimitado com chaves com uma lista de comandos que serão executados condicionalmente.\nO trecho de código seguinte ilustra a estrutura do switch com vários chamadas para a função printf. A variável valor pode ser um int, por exemplo.\nswitch(valor) {\n    printf(\"A\\n\");\n    printf(\"B\\n\");\n    printf(\"C\\n\");\n    printf(\"D\\n\");\n    printf(\"E\\n\");\n    printf(\"F\\n\");\n    printf(\"G\\n\");\n    printf(\"H\\n\");\n    printf(\"I\\n\");\n}\nEsse código, do jeito que está apresentado, não terá nenhum de seus comandos executados. A especificação para que algo seja executado é feito por rótulos que indicam em que posição da sequência se inicia a execução.\nOs rótulos são especificados com case.\n\n\n\n\n\n\nEstrutura da rotulação com case\n\n\n\ncase constante :\n\n\nSegue a lista de comandos com rótulos inseridos. Esses rótulos são as constantes 1, 3 e 10.\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n    }\nPara essa organização, o funcionamento do switch avalia a expressão (variável valor) e inicia a execução da lista de comandos a partir do case em que houver igualdade.\nAssim, se valor for igual a 1, todos os printf são executados; se for igual a 3, a execução se inicia no printf(\"E\\n\") e vai até o final; e se for igual a 10, somente H e I são escritos. Para qualquer outro valor, nada é escrito, pois não existe o rótulo indicando em que posição da lista começa a execução.\nO programa seguinte contém a implementação completa do exemplo apresentado.\n/*\nExemplo de escolha de execução com switch\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n    }\n\n    return 0;\n}\nDigite um valor inteiro: 3\nE\nF\nG\nH\nI\nO conceito da estrutura switch é ter uma lista de comandos e, por meio dos rótulos, indicam em que posição da lista se inicia a execução.\nPara ter um último exemplo de como essa estrutura de seleção funciona, é adicionada uma cláusula default, que indica que, se não houver nenhum rótulo coincidente, é nesse ponto que a execução se inicia.\n/*\nExemplo de escolha de execução com switch\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n        default:\n            printf(\"Y\\n\");\n            printf(\"Z\\n\");\n    }\n\n    return 0;\n}\nDigite um valor inteiro: 4\nY\nZ\nTalvez sejam raros os casos em que um problema consiga usar o switch conforme apresentado até o momento, visto que a lista de comandos é sempre executada até o final.\nDessa forma, é comum a inserção de uma interrupção na sequência de comandos e, para isso, é usada a instrução break. O exemplo seguinte é uma nova versão do programa, agora limitando até onde a lista executa.\nQuando um break é encontrado, o switch é interrompido naquele ponto.\n/*\nExemplo de escolha de execução com switch\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor;\n    sscanf(entrada, \"%d\", &valor);\n\n    switch (valor) {\n        case 1:\n            printf(\"A\\n\");\n            printf(\"B\\n\");\n            printf(\"C\\n\");\n            printf(\"D\\n\");\n            break;\n        case 3:\n            printf(\"E\\n\");\n            printf(\"F\\n\");\n            printf(\"G\\n\");\n            break;\n        case 10:\n            printf(\"H\\n\");\n            printf(\"I\\n\");\n            break;\n        default:\n            printf(\"Y\\n\");\n            printf(\"Z\\n\");\n    }\n\n    return 0;\n}\nDigite um valor inteiro: 1\nA\nB\nC\nD\nNesta versão, a mais completa e usual, mostra como, dependendo de um dado valor, apenas uma lista específica de instruções é executada.\nPara um exemplo mais prático, pode ser o problema de ler uma expressão com dois operandos e um operador aritmético simples e apresentar o resultado (Algoritmo 1).\n\n\nAlgoritmo 1: Cálculo de uma expressão aritmética simples a partir dos operandos e do operador.\n\n\n\n/*\nRealização de uma operação aritmética simples dados os operandos e o\n    operador\nRequer: operando1, operador e operando2\nAssegura: o resultado da operação ou mensagem se o operador for\n    desconhecido\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite uma operação aritmética (sem espaços): \");\n    fgets(entrada, sizeof entrada, stdin);\n    double operando1, operando2;\n    char operador;\n    sscanf(entrada, \"%lf%c%lf\", &operando1, &operador, &operando2);\n\n    double resultado;\n    bool eh_operador_valido = true;\n    switch (operador) {\n        case '+':\n            resultado = operando1 + operando2;\n            break;\n        case '-':\n            resultado = operando1 - operando2;\n            break;\n        case '*':\n            resultado = operando1 * operando2;\n            break;\n        case '/':\n            resultado = operando1 / operando2;\n            break;\n        default:\n            eh_operador_valido = false;\n    }\n\n    if (eh_operador_valido)\n        printf(\"%g %c %g = %g.\\n\", operando1, operador, operando2, resultado);\n    else\n        printf(\"Operador não reconhecido.\\n\");\n\n    return 0;\n}\nDigite uma operação aritmética (sem espaços): 1.75*-3.1\n1.75 * -3.1 = -5.425.",
    "crumbs": [
      "Linguagem C",
      "Controle de fluxo simples",
      "Execução condicional com `switch`"
    ]
  },
  {
    "objectID": "linguagem-c/execucao-condicional-com-switch.html#limitações-do-switch",
    "href": "linguagem-c/execucao-condicional-com-switch.html#limitações-do-switch",
    "title": "Execução condicional com switch",
    "section": "Limitações do switch",
    "text": "Limitações do switch\nEmbora bastante útil, o switch serve apenas para comparações de igualdade, não permitindo verificações de intervalos, por exemplo.\nOutra limitação é que a expressão usada tem que ser inteira ou char. Valores reais não podem ser usados.",
    "crumbs": [
      "Linguagem C",
      "Controle de fluxo simples",
      "Execução condicional com `switch`"
    ]
  },
  {
    "objectID": "linguagem-c/arquivos-binarios.html",
    "href": "linguagem-c/arquivos-binarios.html",
    "title": "Arquivos binários",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEm construção…\n\nArquivos binários\n\n\nAcesso direto (fseek)\n\n\nstdint.h\n\n\nArquivos de registros\n\n\nBoas práticas\n\nAtenção aos parâmetros de fread e fwrite.\nUso de sizeof para especificar o tamanho do objeto.\nUso dos valores de retorno da leitura e escrita.\nAtenção para movimentar para a posição correta ao usar fseek.\nSempre fechar arquivo com fclose."
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html",
    "title": "Expressões relacionais e lógicas",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nAlém de expressões aritméticas, há outros dois tipos de expressões relevantes, ambas tratadas neste capítulo: relacionais e lógicas.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#afinal-_bool-ou-bool",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#afinal-_bool-ou-bool",
    "title": "Expressões relacionais e lógicas",
    "section": "Afinal, _Bool ou bool?",
    "text": "Afinal, _Bool ou bool?\nA linguagem C, no início, não possuía um tipo lógico específico. Eram empregadas variáveis do tipo int para representar tanto os valores realmente inteiros (como idades ou contadores) quanto para valores lógicos. Assim, para o programador com alguma experiência, não é estranha essa mistura de significados nos códigos mais antigo e também nos novos.\nComo não havia a necessidade de uma variável lógica, a palavra bool nunca foi reservada para a linguagem e poderia ser usada livremente nos programas. Em decorrência de uma posterior criação do tipo booliano, reservar uma palavra poderia implicar a reescrita em massa dos códigos já existentes. Dessa forma, a palavra-chave escolhida for _Bool.\nPara os programas para os quais não haveria conflito, foi incluída à biblioteca padrão o arquivo de cabeçalho stdbool.h, o qual define bool como um novo nome para _Bool. Além do novo nome, também define true e false para serem usados no lugar de 1 e 0, respectivamente.\nA modificação do programa para usar essas definições é pequena, bastando incluir o arquivo de cabeçalhos e modificar o tipo na declaração da variável.\n#include &lt;stdbool.h&gt;\nbool eh_classe_a = renda_familiar &gt; 20 * 1412.00;\nA forma de escrita usando bool parece, para o autor, a forma mais natural de declaração, pois segue um padrão visual similar ao dos outros tipos. Este será empregado ao longo do texto.\nAntes de apresentar a versão final do código, agora com o cabeçalho stdbool.h, é interessante notar que existe em C uma construção que pode ser usada neste programa para melhorar a apresentação do resultado. Esse elemento é conhecido como condicional ternário.\n\n\n\n\n\n\nOperador condicional ternário\n\n\n\nexpressão_lógica ? resultado_verdadeiro : resultado_falso\n\n\nEsse condicional, assim como os aritméticos e os relacionais, resultam em um valor dependente de seus operandos. Neste caso, há três operandos e dois operadores: ? e :. Se o valor de expressão_lógica for verdadeiro, então o resultado final da expressão é o valor resultado_verdadeiro e, caso contrário, o resultado é resultado_falso.\nSegue um exemplo simples desse condicional ternário.\nint a = 20;\nint b = 12;\n\nint maior = a &gt; b ? a : b;\nNa atribuição a maior, a expressão_lógica do condicional ternário é a &gt; b. Se o resultado dessa expressão for verdadeiro, então o valor de a é o resultado atribuído a maior. Se o valor de a for menor ou igual ao de b, o resultado final será b.\nNão há restrições dos tipos de dados que podem ser usados como resultado do condicional ternário e o programa usa cadeias de caracteres como resultado.\n/*\nDeterminação se uma renda familiar mensal é classificada como classe A no\n    Brasil; Classe A: 20 salários mínimos de R\\$1.412,00 (valor de janeiro\n    de 2024)\nRequer: o valor da renda familiar\nAssegura: verdadeiro se se enquadrar na classe A; falso se não\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite o valor da renda mensal familiar: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double renda_familiar;\n    sscanf(entrada, \"%lf\", &renda_familiar);\n\n    bool eh_classe_a = renda_familiar &gt; 20 * 1412.00;  // mínimo em 1/2024\n\n    printf(\"Sua família %s classe A!\\n\", eh_classe_a ? \"é\" : \"não é\");\n\n    return 0;\n}\nDigite o valor da renda mensal familiar: 30000\nSua família é classe A!\nAs modificações para o uso de bool foram feitas e, para o condicional ternário, se eh_classe_a for verdadeiro, o resultado é o texto \"é\" e, se não for, \"não é\". Um desses dois valores ocupará o lugar do %s no texto do printf.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#sec-relacoes-ternarias",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#sec-relacoes-ternarias",
    "title": "Expressões relacionais e lógicas",
    "section": "Relações matemáticas ternárias e sucessivas",
    "text": "Relações matemáticas ternárias e sucessivas\nNo cotidiano é comum usar expressões ternárias como 0 \\(&lt; x &lt;\\) 10 para indicar que \\(x\\) está em um determinado intervalo. Em C é preciso cuidado com tais expressões, pois cada expressão relacional resulta em um valor inteiro.\nPor exemplo, a expressão 0 &lt; valor &lt; 10 é avaliada na seguinte ordem, considerando-se valor contendo 20:\n\n(0 &lt; valor) &lt; 10: avaliação que ocorre da esquerda para a direita;\n1 &lt; 10: substituição do resultado intermediário na expressão;\n1: o resultado final é verdadeiro.\n\nPorém 0 &lt; 20 &lt; 10 é esperado que resulte em falso.\nExpressões ternárias em C não são possíveis e, assim, devem ser escritas como uma combinação de expressões binárias. A expressão deve ser escrita: 0 &lt; valor && valor &lt; 10, sendo que o && significa “e”. O modo com que as expressões relacionais são avaliadas e o uso de valores inteiros como resultado levam à necessidade de que expressões sejam escritas, muitas vezes, de forma extensa.\nEstendendo esse conceito, matematicamente se pode escrever \\(a = b = c = d\\), por exemplo. Em C, a expressão requer expressões relacionais isoladas combinadas com operadores lógicos. Assim, a == b && b == c & c == d é uma expressão equivalente. Seguem exemplos.\na == b && b == c && c == d  // a = b = c = d\na &lt; b && b &lt; c && c &lt; d     // a &lt; b &lt; c &lt; d\na == b && b &lt; c             // a = b &lt; c",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#comparações-com-vários-valores",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#comparações-com-vários-valores",
    "title": "Expressões relacionais e lógicas",
    "section": "Comparações com vários valores",
    "text": "Comparações com vários valores\nOutra questão que surgem com frequência é a verificação de uma variável com uma série de valores. Este é o caso, por exemplo, para verificar se uma variável inteira mes é um dos meses com 31 dias, ou seja, se \\({m \\in \\{ 1, 3, 5, 7, 8, 10, 12 \\}}\\). Não é incomum que programados iniciantes tentem fazer essa comparação como se segue.\nmes == 1 || 3 || 5 || 7 || 8 || 10 || 12  // incorreto!\nEssa expressão, pelas regras da linguagem, primeiro avalia se mes == 1 e esse resultado é 0 ou 1. A próxima comparação verifica, portanto, 0 || 3 ou 1 || 3, o que resulta em 1, qualquer que seja o valor obtido na primeira comparação. É importante lembrar que o valor falso está associado ao 0, enquanto qualquer valor não nulo é verdadeiro. A expressão acima significa, na prática, “mês igual a 1 ou verdadeiro ou verdadeiro ou verdadeiro…”, o que é sempre verdadeiro, ou seja, 1.\nO ajuste necessário para essa expressão é individualizar as comparações e a comparação seguinte produz o resultado desejado.\nmes == 1 || mes == 3 || mes == 5 || mes == 7 ||  mes == 8 ||\n    mes == 10 || mes == 12  // OK!\n\n\n\n\n\n\nDica\n\n\n\nElaborar expressões lógicas requer prática e atenção. Nem sempre as verificações são óbvias e testar a avaliação da expressão passo a passo pode ser uma estratégia muito interessante ou até necessária.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-cédulas-válidas",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-cédulas-válidas",
    "title": "Expressões relacionais e lógicas",
    "section": "Verificação de cédulas válidas",
    "text": "Verificação de cédulas válidas\nEste é um exemplo para determinar se um determinado valor é ou não um valor de cédula válido. Atualmente no Brasil, há cédulas e moedas usadas sendo usada cotidianamente no comércio. As cédulas em papel possuem valores de face de 2, 5, 10, 20, 50, 100 e 200 reais.\nAssim, é proposto o Algoritmo 2 para determinar se um valor qualquer é ou não o valor de face de uma cédula brasileira.\n\n\nAlgoritmo 2: Determinação se um valor é um valor de face de uma cédula brasileira.\n\n\n\nO programa seguinte codifica esse algoritmo.\n/*\nVerificação se um dado valor inteiro qualquer é ou não um valor de face\n    válido entre as cédulas do Brasil\nRequer: um valor inteiro qualquer\nAssegura: verdadeiro se o valor corresponder a uma das cédulas; falso\n    caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor inteiro para verificação de cédula: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int valor_candidato;\n    sscanf(entrada, \"%d\", &valor_candidato);\n\n    bool eh_valido = valor_candidato == 2 || valor_candidato == 5 ||\n                        valor_candidato == 10 || valor_candidato == 20 ||\n                        valor_candidato == 50 || valor_candidato == 100 ||\n                        valor_candidato == 200;\n\n    printf(\"O valor %d é %s.\\n\", valor_candidato,\n        eh_valido ? \"válido\" : \"inválido\");\n\n    return 0;\n}\nDigite um valor inteiro para verificação de cédula: 100\nO valor 100 é válido.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-aprovação-em-disciplina",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-aprovação-em-disciplina",
    "title": "Expressões relacionais e lógicas",
    "section": "Verificação de aprovação em disciplina",
    "text": "Verificação de aprovação em disciplina\nConsiderando-se que a aprovação de um aluno em uma disciplina exija que ele tenha média maior ou superior a 6 e que sua frequência não seja inferior a 75%, o problema que deve ser resolvido é determinar se um aluno foi ou não aprovado. Para determinar média final, há duas notas e deve ser calculada sua média. Para a frequência, estão disponíveis o número de faltas e o número total de aulas. Assim, é proposto como solução o Algoritmo 3.\n\n\nAlgoritmo 3: Verificação da aprovação ou reprovação de um aluno em função de notas e frequência.\n\n\n\nA implementação é apresentada na sequência.\n/*\nDeterminação de aprovação em disciplina em função da média de duas notas e frequência baseada no número de faltas e número de aulas\nRequer: duas notas de provas, número de faltas e número de aulas\nAssegura: A média, a frequência e verdadeiro/falso conforme aprovado ou reprovado\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    // Média\n    printf(\"Digite as duas notas de provas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double nota1, nota2;\n    sscanf(entrada, \"%lf%lf\", &nota1, &nota2);\n    double media = (nota1 + nota2) / 2;\n    bool tem_media = media &gt;= 6;\n\n    // Frequência\n    printf(\"Digite o número de faltas e o de aulas: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int numero_faltas, numero_aulas;\n    sscanf(entrada, \"%d%d\", &numero_faltas, &numero_aulas);\n    double frequencia = (double) (numero_aulas - numero_faltas) / numero_aulas;\n    bool tem_pouca_frequencia = frequencia &lt; 0.75;\n\n    // Aprovação/reprovação e resultado\n    bool tem_aprovacao = tem_media && !tem_pouca_frequencia;\n    printf(\"Média: %.1f; frequência: %.1f%%.\\n\", media, 100 * frequencia);\n    printf(\"Situação: %s.\\n\", tem_aprovacao ? \"aprovado\" : \"reprovado\");\n\n    return 0;\n}\nDigite as duas notas de provas: 5.8 9.1\nDigite o número de faltas e o de aulas: 8 30\nMédia: 7.4; frequência: 73.3%.\nSituação: reprovado.\nEste programa usa variáveis lógicas para as diversas condições. Um detalhe interessante é a variável tem_pouca_frequencia, a qual indica que a frequência não é suficiente para aprovação. Na verificação final, é usado o operador não para negar essa condição e conceder a aprovação: !tem_pouca_frequencia (i.e., “não tem pouca frequência”).\nO operador ! é pouco usado juntamente com expressões relacionais, pois escrever a &lt;= b é melhor que !(a &gt; b). Por outro lado, se existem uma variável detectou_problema, é mais natural negar escrevendo detectou_problema ou !detectou_problema.\n\n\n\n\n\n\nDica\n\n\n\nOperadores lógicos nunca devem ser comparados com os valores true e false, como exemplificado na sequência.\ntem_aprovacao ? \"aprovado\" : \"reprovado\"           // bom!\ntem_aprovacao == true ? \"aprovado\" : \"reprovado\"   // ruim e desnecessário!\ntem_aprovacao != false ? \"aprovado\" : \"reprovado\"  // pior ainda!\nPode-se considerar que comparar uma variável com true ou false faz tanto sentido como escrever (a &gt; b) == true.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-existência-de-triângulo",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-existência-de-triângulo",
    "title": "Expressões relacionais e lógicas",
    "section": "Verificação de existência de triângulo",
    "text": "Verificação de existência de triângulo\nPara ilustrar tanto as expressões como o uso de valores lógicos, o problema de verificar se três segmentos de reta podem ser os lados de um triângulo é apresentado. Um triângulo não pode ser formado caso um dos segmentos seja maior ou igual à soma dos outros dois, situação em que o triângulo “não fecha”. Seguem a solução no Algoritmo 4 e sua implementação em C.\n\n\nAlgoritmo 4: Verificação se três segmentos de reta podem ou não formar um triângulo\n\n\n\n/*\nVerificação se três segmentos de reta com determinados comprimentos podem\n    ou não formar um triângulo\nRequer: os comprimentos $l_1$, $l_2$ e $l_3$ dos segmentos de reta\nAssegura: Verdadeiro se podem formar um triângulo; falso caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite os comprimentos dos segmentos de reta: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double lado1, lado2, lado3;\n    sscanf(entrada, \"%lf%lf%lf\", &lado1, &lado2, &lado3);\n\n    bool triangulo_eh_valido = lado1 &lt; lado2 + lado3 && lado2 &lt; lado1 + lado3 &&\n            lado3 &lt; lado1 + lado2;\n\n    printf(\"Triângulo %s.\\n\", triangulo_eh_valido ? \"válido\" : \"inválido\");\n\n    return 0;\n}\nDigite os comprimentos dos segmentos de reta: 3 4 5\nTriângulo válido.\nNeste programa, a variável triangulo_eh_valido é usada como uma variável lógica.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-validade-de-uma-data",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#verificação-de-validade-de-uma-data",
    "title": "Expressões relacionais e lógicas",
    "section": "Verificação de validade de uma data",
    "text": "Verificação de validade de uma data\nComo exemplo com expressões lógicas, segue um algoritmo para determinar se valores para dia, mês e ano formam uma data válida (Algoritmo 5). Os valores formam uma data válida se o valor do dia estiver dentro do intervalo do mês e o ano for diferente de zero1. A solução desconsidera anos bissextos, de forma que fevereiro considera apenas 28 dias. Também considera que valores negativos para um ano indicam AC (antes de Cristo).\n\n\nAlgoritmo 5: Determinação se valores inteiros para dia, mês e ano formam uma data válida.\n\n\n\n/*\nDeterminação se valores inteiros para dia, mês e ano formam uma data\nválida,desconsiderando anos bissextos e entendendo anos negativos como AC\nRequer: valores inteiros para dia, mês e ano\nAssegura: verdadeiro se a data é válida ou falso caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n    \n    printf(\"Digite os valores para dia, mês e ano: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int dia, mes, ano;\n    sscanf(entrada, \"%d%d%d\", &dia, &mes, &ano);\n\n    bool data_valida = dia &gt; 0 && mes &gt; 0 && ano != 0 && (\n            dia &lt;= 28 && mes == 2 ||\n            dia &lt;= 31 && (mes == 1 || mes == 3 || mes == 5 || mes == 7 ||\n                mes == 8 || mes == 10 || mes == 12) ||\n            dia &lt;= 30 && (mes == 4 || mes == 6 || mes == 9 || mes == 11)\n        );\n\n    printf(\"%02d/%02d/%04d é %s.\\n\", dia, mes, ano, \n        data_valida ? \"válida\" : \"inválida\");\n\n    return 0;\n}\nDigite os valores para dia, mês e ano: 30 2 2050\n30/02/2050 é inválida.\nEmbora a ordem de precedência dos operadores permita escrever as expressões usando apenas os parênteses somente necessário, é usual que expressões mais longas usem o recurso dos parênteses para dar maior clareza à expressão. Um desses casos é envolver o && com parênteses, mesmo sabendo-se que o || será avaliado posteriormente. O programa de verificação de datas é escrito lançando mão dessa estratégia.\n/*\nDeterminação se valores inteiros para dia, mês e ano formam uma data\n    válida,desconsiderando anos bissextos e entendendo anos negativos\n    como AC\nRequer: valores inteiros para dia, mês e ano\nAssegura: verdadeiro se a data é válida ou falso caso contrário\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n    \n    printf(\"Digite os valores para dia, mês e ano: \");\n    fgets(entrada, sizeof entrada, stdin);\n    int dia, mes, ano;\n    sscanf(entrada, \"%d%d%d\", &dia, &mes, &ano);\n\n    bool data_valida = dia &gt; 0 && mes &gt; 0 && ano != 0 && (\n            (dia &lt;= 28 && mes == 2) ||\n            (dia &lt;= 31 && (mes == 1 || mes == 3 || mes == 5 || mes == 7 ||\n                mes == 8 || mes == 10 || mes == 12)) ||\n            (dia &lt;= 30 && (mes == 4 || mes == 6 || mes == 9 || mes == 11))\n        );\n\n    printf(\"%02d/%02d/%04d é %s.\\n\", dia, mes, ano, \n        data_valida ? \"válida\" : \"inválida\");\n\n    return 0;\n}\nDigite os valores para dia, mês e ano: 18 12 1892\n18/12/1892 é válida.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#mais-sobre-valores-lógicos-em-c",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#mais-sobre-valores-lógicos-em-c",
    "title": "Expressões relacionais e lógicas",
    "section": "Mais sobre valores lógicos em C",
    "text": "Mais sobre valores lógicos em C\nComo já exposto no início do capítulo, se um valor for igual a zero ele é considerado falso e se for diferente de zero é verdadeiro. A questão é que, na linguagem C, isso é válido para qualquer valor e não somente os do tipo bool e inteiros.\nPara exemplificar, o programa abaixo pode ser considerado.\n/*\nExemplo de programa com negação de valor double\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double d;\n    sscanf(entrada, \"%lf\", &d);\n\n    bool r = !d;\n\n    printf(\"r é %s.\\n\", r ? \"verdadeiro\" : \"falso\");\n    return 0;\n}\nDigite um valor real: 0.0\nr é verdadeiro.\nSe o valor digitado para d for igual a zero, !d é 1; se for diferente de zero, r receberá 0. Para a linguagem, é irrelevante que d seja double.\nSegue mais um exemplo.\n/*\nExemplo de programa com negação de valor double\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    printf(\"Digite um valor real: \");\n    fgets(entrada, sizeof entrada, stdin);\n    double d;\n    sscanf(entrada, \"%lf\", &d);\n\n    printf(\"O valor digitado é %s zero.\\n\", d ? \"diferente de\" : \"igual a\");\n    return 0;\n}\nDigite um valor real: 5.2\nO valor digitado é diferente de zero.\nNeste programa, o condicional ternário é escrito d ? \"diferente de\" : \"igual a\". Se d for zero, a expressão é assumida como falsa; se não for, é verdadeira.\n\n\n\n\n\n\nCuidado\n\n\n\nNão é uma boa prática usar um valor que não seja lógico como se assim fosse. A escrita do código deve deixar claro o que é o que.\nPor exemplo, mesmo que 2 * i - 1 ? \"Ok\" : \"Não ok\" funcione, resultando em \"Ok\" sempre que 2 * i - 1 for diferente de zero, deve-se sempre escrever 2 * i - 1 != 0 ? \"Ok\" : \"Não ok\", já que a operação aritmética não é, em si, uma expressão lógica.",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/expressoes-relacionais-e-logicas.html#footnotes",
    "href": "linguagem-c/expressoes-relacionais-e-logicas.html#footnotes",
    "title": "Expressões relacionais e lógicas",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nO calendário da era cristã (Anno Domini, ou ano do Senhor) se inicia com o ano 1 DC e anos antes de Cristo se iniciam com 1 AC. Não há ano zero.↩︎",
    "crumbs": [
      "Linguagem C",
      "Programação básica",
      "Expressões relacionais e lógicas"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-do-while.html",
    "href": "linguagem-c/repeticoes-com-do-while.html",
    "title": "Repetições com do while",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nEste capítulo contempla a estrutura e aspectos lógicos do do while, cuja função é executar comandos repetitivamente.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `do while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-do-while.html#leitura-de-senha",
    "href": "linguagem-c/repeticoes-com-do-while.html#leitura-de-senha",
    "title": "Repetições com do while",
    "section": "Leitura de senha",
    "text": "Leitura de senha\nEste exemplo é de um programa que solicita uma senha para autorizar ou não a execução. A senha é hardcoded (i.e., fixa no código e nada versátil) e há um limite de três tentativas.\n/*\nProcessamento somente mediante senha\nRequer: uma sequência de tentativas de senha terminada com a senha correta\n    ou com comprimento máximo de três tentativas\nAssegura: apresentação de mensagem autorizando ou negando acesso conforme a\n    a senha esteja ou não correta\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    bool validou_senha = false;\n    int numero_tentativas = 0;\n    do {\n        numero_tentativas++;\n        printf(\"Digite a senha: \");\n        char senha[160];\n        fgets(senha, sizeof senha, stdin);\n\n        validou_senha = strcmp(senha, \"12345678\\n\") == 0; // é igual?\n    } while (!validou_senha && numero_tentativas &lt; 3);\n\n    if (validou_senha)\n        printf(\"\\nAcesso autorizado.\\n\");\n    else\n        printf(\"\\nAcesso negado.\\n*** Este problema será reportado.\\n\");\n\n    return 0;\n}\nDigite a senha: senha\nDigite a senha: senha123\nDigite a senha: 123456\n\nAcesso negado.\n*** Este problema será reportado.\nNeste código há o uso da função strcmp, declarada no arquivo de cabeçalho string.h. Ela retorna zero se as duas cadeias de caracteres passadas como parâmetro forem iguais1. Uma observação interessante é que senha é declarada dentro do bloco do do while, uma vez que ela não é necessária fora dele; o mesmo comentário não é válido para validou_senha.",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `do while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-do-while.html#pense-em-um-número-de-1-a-15.000",
    "href": "linguagem-c/repeticoes-com-do-while.html#pense-em-um-número-de-1-a-15.000",
    "title": "Repetições com do while",
    "section": "Pense em um número de 1 a 15.000!",
    "text": "Pense em um número de 1 a 15.000!\nO programa deste exemplo se propõe a adivinhar um número pensado pelo usuário em no máximo 13 tentativas.\n/*\nPense em um número de 1 até 15.000 para eu adivinhar qual é!\nRequer: respostas do usuário dizendo se o valor é maior (+) ou menor (-)\n    que o número pensado\nAssegura: a apresentação do número pensado pelo usuário em até 14 tentativas\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(void) {\n    printf(\"Pense em um número de 1 a 15000 e responda...\\n\");\n    sleep(8);  // 8s para pensar!\n\n    int inicio_intervalo = 1;\n    int fim_intervalo = 15000;\n    int numero_tentativas = 0;\n    int tentativa;\n    bool acertei = false;\n    do {\n        numero_tentativas++;\n        tentativa = (inicio_intervalo + fim_intervalo) / 2;\n\n        printf(\"É o %d?\\n\", tentativa);\n        printf(\"Responda + se o número for maior, - se for menor \"\n               \"ou = se eu acertei: \");\n        char resposta[160];\n        fgets(resposta, sizeof resposta, stdin);\n        switch (resposta[0]) {\n            case '+':\n                inicio_intervalo = tentativa + 1;  // tentarei número maior\n                break;\n            case '-':\n                fim_intervalo = tentativa - 1;  // tentarei número menor\n                break;\n            case '=':\n                acertei = true;  // UFA!\n                break;\n            default:\n                printf(\"Não entendi a resposta... tente de novo.\\n\");\n                numero_tentativas--;  // essa tentativa não conta!\n        }\n\n        if (!acertei) {\n            if (numero_tentativas == 13)\n                printf(\"Minha ÚLTIMA CHANCE!!!\\n\");\n            else if (numero_tentativas &gt; 10)\n                printf(\"Só tenho mais %d chances.. :-(\\n\",\n                       14 - numero_tentativas);\n            sleep(0.7);  // pausa leve de dramaticidade\n        }\n    } while (!acertei && fim_intervalo &gt;= inicio_intervalo);\n\n    if (acertei)\n        printf(\"\\n\\nBeleza! Acertei em %d tentativas!\\n\", numero_tentativas);\n    else\n        printf(\"\\n\\nHummmm! Algo de errado não está certo aqui...\\n\"\n               \"Suas respostas foram corretas?\\n\");\n\n    return 0;\n}\nPense em um número de 1 a 15000 e responda...\nÉ o 7500?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 11250?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 13125?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 14063?\nResponda + se o número for maior, - se for menor ou = se eu acertei: -\nÉ o 13594?\nResponda + se o número for maior, - se for menor ou = se eu acertei: -\nÉ o 13359?\nResponda + se o número for maior, - se for menor ou = se eu acertei: +\nÉ o 13476?\nResponda + se o número for maior, - se for menor ou = se eu acertei: =\n\n\nBeleza! Acertei em 7 tentativas!",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `do while`"
    ]
  },
  {
    "objectID": "linguagem-c/repeticoes-com-do-while.html#footnotes",
    "href": "linguagem-c/repeticoes-com-do-while.html#footnotes",
    "title": "Repetições com do while",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nManipulações de cadeias de caracteres são tratadas em detalhes no ?@sec-dados-textuais.↩︎",
    "crumbs": [
      "Linguagem C",
      "Controle de repetição do fluxo",
      "Repetições com `do while`"
    ]
  },
  {
    "objectID": "linguagem-c/dados-em-vetores.html",
    "href": "linguagem-c/dados-em-vetores.html",
    "title": "Dados em vetores",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\nOs vetores são estruturas de dados que agrupam coleções de itens, todos com o mesmo tipo. Cada item de um vetor é individualizado por seu índice, que é um valor inteiro. Neste capítulo é abordado como vetores são criados em C e quais as peculiaridades que possuem.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados em vetores"
    ]
  },
  {
    "objectID": "linguagem-c/dados-em-vetores.html#declarações-com-atribuição-explícita",
    "href": "linguagem-c/dados-em-vetores.html#declarações-com-atribuição-explícita",
    "title": "Dados em vetores",
    "section": "Declarações com atribuição explícita",
    "text": "Declarações com atribuição explícita\nAssim como outras variáveis, é possível iniciar os valores de um vetor juntamente com sua declaração.\nPara vetores com itens inteiros ou reais, a iniciação é indicada por uma atribuição com os valores indicados entre chaves. Segue um exemplo simples com a iniciação de um vetor de valores reais.\n/*\n * Programa mostrando a declaração de vetor com iniciação\n * Assegura: apresentação dos valores do vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double vetor[5] = {1.7, 8.2, -6.5, 0.0, 1.2};\n\n    for(int i = 0; i &lt; 5; i++)\n        printf(\"%g \", vetor[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n1.7 8.2 -6.5 0 1.2 \nTambém é possível atribuir apenas às posições iniciais do vetor, como se exemplifica.\n/*\n * Programa mostrando a declaração de vetor com iniciação\n * Assegura: apresentação dos valores do vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double vetor[10] = {-8.23, 0.0, -6.5};\n\n    for(int i = 0; i &lt; 10; i++)\n        printf(\"%g \", vetor[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n-8.23 0 -6.5 0 0 0 0 0 0 0 \nNo programa, apenas são indicados valores para as três primeiras posições de vetor, sendo que para as demais nada é explicitamente especificado. Neste caso, todas as posições não especificadas terão valores nulos (ou equivalente, dependendo do tipo base do vetor).\nO programa seguinte exemplifica um vetor que tem apenas suas duas posições iniciais com valores explicitamente atribuídos. As demais, uma vez que houve a atribuição, têm seus valores zerados.\n/*\n * Programa mostrando a declaração de vetores com iniciação parcial\n * Assegura: apresentação da quantidade de zeros no vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    double vetor[1000] = {1.1, 2.2};  // valores para posições 0 e 1\n\n    int contador_de_zeros = 0;\n    for (int i = 0; i &lt; 1000; i++)\n        if (vetor[i] == 0)\n            contador_de_zeros++;\n    printf(\"No vetor local: %d de 1000 valores zero.\\n\", contador_de_zeros);\n\n    return 0;\n}\nNo vetor local: 998 de 1000 valores zero.\nA execução mostra que, exceto pelos pelas duas posições iniciais do vetor, todas as demais possuem valor nulo.\nEssa atribuição é interessante para casos em que se precisa de um vetor com zeros inicialmente em todas suas posições. Assim, uma declaração como a seguinte é suficiente.\nint v[500000] = {0};  // todo o vetor é iniciado com 500.000 zeros\nQuando o tipo base do vetor é char, as mesmas regras gerais valem. Se um vetor local sem iniciação explícita é criado, seu conteúdo é considerado lixo.\nchar s[300];  // 300 caracteres simples\nA iniciação do vetor pode ser realizada juntamente com a declaração da variável especificando-se os valores, posição a posição. Como nos casos de inteiros e reais, as primeiras posições recebem valores e as demais ficam com bytes nulos. No caso de cadeias de caracteres, o byte nulo é o caractere \\0.\nchar s[10] = {'H', 'e', 'l', 'l', 'o'};\nO programa seguinte comprova esse comportamento.\n/*\n * Criação de vetor de caracteres com iniciação parcial\n * Assegura: apresentação do conteúdo do vetor, posição a posição\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char s[10] = {'H', 'e', 'l', 'l', 'o'};\n\n    for (int i = 0; i &lt; 10; i++)\n        printf(\"s[%d] = '%c' \\t(código %d)\\n\", i, s[i], s[i]);\n\n    return 0;\n}\ns[0] = 'H' \t(código 72)\ns[1] = 'e' \t(código 101)\ns[2] = 'l' \t(código 108)\ns[3] = 'l' \t(código 108)\ns[4] = 'o' \t(código 111)\ns[5] = '' \t(código 0)\ns[6] = '' \t(código 0)\ns[7] = '' \t(código 0)\ns[8] = '' \t(código 0)\ns[9] = '' \t(código 0)\nAqui é importante relembrar a compatibilidade dessa iniciação com a representação de cadeias de caraceteres. Por exemplo, a função printf, usando o formato %s, escreva na tela o texto Hello, pois interpreta o \\0 de s[5] com fim da cadeia.\nHá também que se ter uma concordância dos programadores que digitar 'H', 'e', 'l', 'l', 'o' é uma tarefa, no mínimo, aborrecida. A linguagem aceita a iniciação com os valores entre aspas, usando o conceito dos valores textuais. Dessa forma, a mesma declaração com a mesma iniciação pode ser escrita usando as aspas duplas, com o mesmo resultado.\nchar s[10] = \"Hello\";\nA versão que especifica o conteúdo caractere a caractere é útil se o vetor não for usado como uma cadeia de caracteres usual, mas como um vetor de caracteres qualquer. O programa seguinte, variação do anterior, ilustra que o conteúdo do vetor é tratado como vários caracteres e não como uma string.\n/*\n * Criação de vetor de caracteres com iniciação parcial\n * Assegura: apresentação do conteúdo do vetor, posição a posição\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char s[10] = {'a', 'e', 'K', '\\0', 'G', '\\t', 'o', '\\a', '\\0', 'A'};\n\n    for (int i = 0; i &lt; 10; i++)\n        printf(\"s[%2d] = '%c' \\t(código %d)\\n\", i, s[i], s[i]);\n\n    return 0;\n}\ns[ 0] = 'a' \t(código 97)\ns[ 1] = 'e' \t(código 101)\ns[ 2] = 'K' \t(código 75)\ns[ 3] = '' \t(código 0)\ns[ 4] = 'G' \t(código 71)\ns[ 5] = '\t' \t(código 9)\ns[ 6] = 'o' \t(código 111)\ns[ 7] = '\u0007' \t(código 7)\ns[ 8] = '' \t(código 0)\ns[ 9] = 'A' \t(código 65)",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados em vetores"
    ]
  },
  {
    "objectID": "linguagem-c/dados-em-vetores.html#declarações-com-tamanho-automático",
    "href": "linguagem-c/dados-em-vetores.html#declarações-com-tamanho-automático",
    "title": "Dados em vetores",
    "section": "Declarações com tamanho automático",
    "text": "Declarações com tamanho automático\nA linguagem permite uma facilidade ao programador quando um vetor é criado com valores inicialmente atribuídos, que é omitir a quantidade de itens que o vetor possui. Esse tamanho é determinado pelos valores atribuídos. Segue um exemplo.\n/*\n * Programa mostrando a declaração de vetores com tamanho automático\n * Assegura: apresentação dos valores do vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int vetor[] = {5, 4, 3, 2, 1};  // vetor com 5 itens\n\n    for (int i = 0; i &lt; 5; i++)\n        printf(\"%d \", vetor[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n5 4 3 2 1 \nA variável vetor é criada com exatamente cinco itens, já que há especificação de cinco valores na iniciação. A declaração feita no programa é exatamente equivalente à declaração seguinte.\nint vetor[5] = {5, 4, 3, 2, 1};\nA vantagem dessa omissão do tamanho é facilitar a escrita do código, sem que o programador tenha que contar quantos valores estão sendo usados na iniciação para colocá-lo dentro dos colchetes.\nEmbora esse recurso de escrita facilite a declaração, ele não se estende ao resto do código. Por exemplo, no programa exemplo o for usou a condição i &lt; 5, o que significa que o programador tem que saber quantos valores há efetivamente no vetor. Para esses casos, um truque de programação pode ser usado e ele é exemplificado no programa seguinte.\n/*\n * Programa mostrando a declaração de vetores com tamanho automático\n * Assegura: apresentação do tamanho de vetor em bytes, do tamanho do \n *  tipo base em bytes e a quantidade de itens no vetor\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int vetor[] = {18, -2, 0, 3, 1, 7, 22, 13, 255, 1, 0, 0, 3};\n    printf(\"O vetor de int possui %zu bytes.\\n\", sizeof vetor);\n    printf(\"Um único int possui %zu bytes.\\n\", sizeof(int));\n    printf(\"Portanto, o vetor possui %zu/%zu = %zu itens!\\n\",\n           sizeof vetor, sizeof(int), sizeof vetor / sizeof(int));\n\n    return 0;\n}\nO vetor de int possui 52 bytes.\nUm único int possui 4 bytes.\nPortanto, o vetor possui 52/4 = 13 itens!\nSabendo-se o tamanho total em bytes do vetor (sizeof vetor) e o tamanho em bytes de cada um de seus itens (sizeof (int)), é possível deduzir quantos itens há no vetor. Segue um novo programa exemplo que usa essa estratégia.\n/*\n * Apresentação das unidades monetárias da moeda brasileira\n * Assegura: apresentação de cada valor de cédula ou moeda (reais ou\n *  centavos)\n */\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Moeda brasileira\\n\"\n           \"----------------\\n\\n\"\n           \"Notas:\\n\");\n    double valores_notas[] = {200.00, 100.00, 50.00, 20.00, 10.00, 5.00, 2.00};\n    for (int i = 0; i &lt; (int)(sizeof valores_notas / sizeof(double)); i++)\n        printf(\"R$ %6.2f\\n\", valores_notas[i]);\n\n    printf(\"\\nMoedas:\\n\");\n    double valores_moedas[] = {1.00, 0.50, 0.25, 0.10, 0.05, 0.01};\n    for (int i = 0; i &lt; (int)(sizeof valores_moedas / sizeof(double)); i++)\n        printf(\"R$ %.2f\\n\", valores_moedas[i]);\n\n    return 0;\n}\nMoeda brasileira\n----------------\n\nNotas:\nR$ 200.00\nR$ 100.00\nR$  50.00\nR$  20.00\nR$  10.00\nR$   5.00\nR$   2.00\n\nMoedas:\nR$ 1.00\nR$ 0.50\nR$ 0.25\nR$ 0.10\nR$ 0.05\nR$ 0.01",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados em vetores"
    ]
  },
  {
    "objectID": "linguagem-c/dados-em-vetores.html#vetores-com-tamanho-sob-demanda",
    "href": "linguagem-c/dados-em-vetores.html#vetores-com-tamanho-sob-demanda",
    "title": "Dados em vetores",
    "section": "Vetores com tamanho sob demanda",
    "text": "Vetores com tamanho sob demanda\nO número de itens de um vetor pode ser especificado de duas formas básicas: com a especificação explícita do tamanho nos colchetes ou fazendo a iniciação com o número desejado de itens. Uma possibilidade adicional, relativa ao primeiro formato, é o uso de uma expressão para indicar a quantidade.\nint n = 10;\ndouble v1[n];  // vetor com 10 itens\ndouble v2[2 * n];  // vetor com 20 itens\nNa prática, a quantidade de itens usada para dimensionar o vetor pode depender de um cálculo ou uma informação em tempo de execução.\nO programa seguinte mostra vetores criados com tamanhos aleatórios, usando a função rand de stdlib.h.\n/*\n * Criação de vetores com diferentes quantidades de itens\n * Assegura: apresentação do número de itens de cada vetor\n */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void) {\n    for (int exemplo = 1; exemplo &lt;= 10; exemplo++) {\n        // rand() % 20 + 1 resulta em um valor aleatório de 1 até 20\n        double vetor[rand() % 20 + 1];\n        printf(\"Exemplo %d: vetor criado com %zu itens.\\n\", exemplo,\n               sizeof vetor/sizeof (double));\n    }\n\n    return 0;\n}\nExemplo 1: vetor criado com 4 itens.\nExemplo 2: vetor criado com 7 itens.\nExemplo 3: vetor criado com 18 itens.\nExemplo 4: vetor criado com 16 itens.\nExemplo 5: vetor criado com 14 itens.\nExemplo 6: vetor criado com 16 itens.\nExemplo 7: vetor criado com 7 itens.\nExemplo 8: vetor criado com 13 itens.\nExemplo 9: vetor criado com 10 itens.\nExemplo 10: vetor criado com 2 itens.\nA cada repetição do for é criado um vetor com um tamanho aleatório, podendo ter de 1 a 20 itens. A quantidade de itens é apresentada verificando o tamanho real do vetor.\nO uso desse recurso é interessante, por exemplo, quando o usuário fornece a quantidade de itens inicialmente, seguida dos valores de cada dado. O vetor pode ser criado exatamente do tamanho para armazenar os dados esperados.",
    "crumbs": [
      "Linguagem C",
      "Estruturação de dados",
      "Dados em vetores"
    ]
  },
  {
    "objectID": "oops.html",
    "href": "oops.html",
    "title": "Algoritmos & Programação",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\n\n\n\n\n\nOoops!\n\n\n\n 404 Conteúdo não encontrado???\nÉ que este capítulo não está pronto (ainda).\nDesculpe o autor por isso!\n;-)"
  },
  {
    "objectID": "conteudo-linguagem-c.html",
    "href": "conteudo-linguagem-c.html",
    "title": "Conteúdo para a linguagem C",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "conteudo-linguagem-c.html#introdução-à-programação-e-à-linguagem-c",
    "href": "conteudo-linguagem-c.html#introdução-à-programação-e-à-linguagem-c",
    "title": "Conteúdo para a linguagem C",
    "section": "Introdução à Programação e à Linguagem C",
    "text": "Introdução à Programação e à Linguagem C\n\nConceito de linguagem estruturada\nEstrutura básica: main()\nInclusão de cabeçalhos .h\nreturn 0\nConceitos de código fonte, objeto e executável\nCompilador e o processo de compilação\nErros lógicos e sintáticos\nBoas práticas\n\nGarantia da existência de um ponto de entrada (main)\nGarantia de um valor de retorno apropriado para main\nInclusão apenas dos cabeçalhos necessários\nBanimento de inclusão de arquivos .c\nEntendimento das mensagens de erro do compilador\nDocumentação adequada do código\nTeste do código projetando bem os casos de teste"
  },
  {
    "objectID": "conteudo-linguagem-c.html#tipos-de-dados-primitivos",
    "href": "conteudo-linguagem-c.html#tipos-de-dados-primitivos",
    "title": "Conteúdo para a linguagem C",
    "section": "Tipos de Dados Primitivos",
    "text": "Tipos de Dados Primitivos\n\nTipos de dados básicos: int, double, _Bool/bool, char\nBoas práticas\n\nConsciência das capacidades e limitações de cada tipo\nEmprego coerente do tipo de dados conforme a situação"
  },
  {
    "objectID": "conteudo-linguagem-c.html#saída",
    "href": "conteudo-linguagem-c.html#saída",
    "title": "Conteúdo para a linguagem C",
    "section": "Saída",
    "text": "Saída\n\nFunção printf\nEspecificadores de formato (%d, %s etc.)\nConceito de tipos de dados (constantes)\nNoções de representação de dados em memória\nFunções puts e putchar\nModificadores de formato (%10s``, ``%010.2f)\nApresentação do fflush\nBoas práticas\n\nUso dos especificadores de formato adequados\nUso dos especificadores de formato para precisão e largura dos campos\nConsiderar que o printf é um comando com custo computacional relativamente alto\nUso de putchar e puts (mais eficientes que printf)\nUso do fflush apenas quando necessário"
  },
  {
    "objectID": "conteudo-linguagem-c.html#entrada",
    "href": "conteudo-linguagem-c.html#entrada",
    "title": "Conteúdo para a linguagem C",
    "section": "Entrada",
    "text": "Entrada\n\nDeclarações de variáveis\nModificadores (short, long, unsigned)\nOperador sizeof\nFunções scanf, fgets, sscanf\nBoas práticas\n\nEscolha dos tipos apropriados\nUso de identificadores significativos\nUso de case de nomes de forma consistente (camel-case, snake-case etc.)\nIniciação adequada (sempre iniciar por atribuição ou leitura)\nEvitação de iniciações desnecessárias (iniciar variável logo antes da leitura)\nUso mínimo de variáveis globais"
  },
  {
    "objectID": "conteudo-linguagem-c.html#expressões",
    "href": "conteudo-linguagem-c.html#expressões",
    "title": "Conteúdo para a linguagem C",
    "section": "Expressões",
    "text": "Expressões\n\nOperadores aritméticos (inteiros e reais)\nOrdem de precedência\nPromoção automática de tipo (e.g., int para double)\nConversões de tipo: typecast e funções (e.g. atoi)\nOperadores relacionais\nOperadores lógicos\nOperador condicional ternário\nFunções matemáticas úteis em math.h\nBoas Práticas\n\nEscolha do melhor tipo para clareza e bom uso da memória\nUso de unsigned apenas quando necessário\nPreferência por double no lugar de float\nGarantia de variável iniciada antes de seu uso\nUso de identificadores significativos\nObservância de divisão por zero\nUso de parênteses para clareza\nObservância de não usar = no lugar de ==\nEmprego de variáveis lógicas para aumentar a clareza do código"
  },
  {
    "objectID": "conteudo-linguagem-c.html#estruturas-condicionais",
    "href": "conteudo-linguagem-c.html#estruturas-condicionais",
    "title": "Conteúdo para a linguagem C",
    "section": "Estruturas Condicionais",
    "text": "Estruturas Condicionais\n\nContextualização da execução condicional e retomada das expressões lógicas\nSintaxe de if\nComandos compostos com { … }\nSintaxe de if-else\nSintaxe de if-else if-else e a ordem das condições\nSintaxe do condicional ternário ? :\nComando de seleção com switch e case (break e default) e limitações\nAninhamento de condicionais\nComparações envolvendo double\nBoas práticas\n\nEvitação de redundância nas condições\nEscrita de código com legibilidade\nEvitação de comparações desnecessárias\nEmprego coerente de declarações locais a comandos compostos (blocos)\nEvitação de “sombreamento” de identificadores (repetição de identificador em escopos diferentes muito próximos)"
  },
  {
    "objectID": "conteudo-linguagem-c.html#estruturas-de-repetição",
    "href": "conteudo-linguagem-c.html#estruturas-de-repetição",
    "title": "Conteúdo para a linguagem C",
    "section": "Estruturas de Repetição",
    "text": "Estruturas de Repetição\n\nRepetições contadas e controladas por condição\nEstruturas while, do while e for\nUso de break, continue e goto\nLaços infinitos e comparações com double\nComparação entre as estruturas\nBoas práticas\n\nEscolha da repetição adequada.\nDeterminação de uma condição de parada válida e atingível.\nEvitação de laços infinitos.\nEscrita de código legível e bem documentado.\nUso de identificadores adequados."
  },
  {
    "objectID": "conteudo-linguagem-c.html#manipulação-de-strings",
    "href": "conteudo-linguagem-c.html#manipulação-de-strings",
    "title": "Conteúdo para a linguagem C",
    "section": "Manipulação de Strings",
    "text": "Manipulação de Strings\n\nDeclarações de strings como vetores de caracteres com terminador\nIniciação de strings (char s[] = ... e char s[10] = ...)\nCabeçalho string.h\n\nstrlen\nstrncpy\nstrncat\nstrcmp\nstrstr (busca por substring)\nLeitura com fgets e scanf + %19s\n\nAcesso à string como vetor\nPonteiros para strings\nAlocação dinâmica de strings\nConversões com sscanf e snprintf\nBoas práticas\n\nBanimento do uso de gets\nRealização de leitura cuidando do tamanho do vetor\nAcesso dentro dos limites de indexação válidos\nGarantia da existência do terminador \\0\nVerificação de sucesso em alocações dinâmicas com necessária liberação da memória\nEvitação de strcpy e strcat"
  },
  {
    "objectID": "conteudo-linguagem-c.html#manipulação-de-arquivos-texto",
    "href": "conteudo-linguagem-c.html#manipulação-de-arquivos-texto",
    "title": "Conteúdo para a linguagem C",
    "section": "Manipulação de Arquivos Texto",
    "text": "Manipulação de Arquivos Texto\n\nConceito de abertura e fechamento de arquivos (fopen e fclose)\nModos de abertura (r, w, a e variantes com + e b)\nConceito de posição corrente\nRetorno ao início com rewind\nFunção fscanf e seu retorno\nFunção fprintf\nFunções fputs e fputc\nFunção fgets e fgetc\nConceito de “fim de arquivo”\nTratamento de erros (retorno de fopen)\nBoas práticas:.\n\nAtenção ao modo de abertura de arquivo.\nVerificação do sucesso de fopen.\nUso de perror para mensagens de erro.\nSempre fechar o arquivo com fclose.\nUso dos valores de retorno das funções de leitura.\nPreferência ao uso de fgets no lugar de fscanf.\nUsar fflush apenas quando necessário."
  },
  {
    "objectID": "conteudo-linguagem-c.html#manipulação-de-arquivos-binários",
    "href": "conteudo-linguagem-c.html#manipulação-de-arquivos-binários",
    "title": "Conteúdo para a linguagem C",
    "section": "Manipulação de Arquivos Binários",
    "text": "Manipulação de Arquivos Binários\n\nConceito de abertura e fechamento de arquivos (fopen e fclose)\nConceito de arquivo de registros\nModos de abertura (r, w, a e variantes com +; uso do especificador b)\nFunções fread e fwrite\nFunções ftell e fseek\nAtualização de registros\nProblemas de portabilidade\nBoas práticas:\n\nAtenção aos parâmetros de fread e fwrite\nUso de sizeof para especificar o tamanho do objeto\nUso dos valores de retorno da leitura e escrita\nAtenção para movimentar para a posição correta ao usar fseek\nSempre fechar arquivo com fclose"
  },
  {
    "objectID": "conteudo-linguagem-c.html#modularização",
    "href": "conteudo-linguagem-c.html#modularização",
    "title": "Conteúdo para a linguagem C",
    "section": "Modularização",
    "text": "Modularização\n\nBenefícios da modularização\n\nReutilização de código\nFacilidade de manutenção\nLegibilidade e organização\nRedução de complexidade\nSeparação lógica de funcionalidades\n\nArquivos: cabeçalho (.h) e implementação (.c)\nFunções e procedimentos\nParâmetros formais: passagem por valor e referência\nEscopo de declarações\nEndereços e ponteiros\nCompilação e ligação de módulos\nBoas práticas\n\nEscolha de nomes de arquivos e funções.\nEmprego de diretivas do pré-processador.\nEvitação definições globais desnecessárias.\nCriação de módulos coesos.\nRealização de documentação."
  },
  {
    "objectID": "conteudo-linguagem-c.html#recursividade",
    "href": "conteudo-linguagem-c.html#recursividade",
    "title": "Conteúdo para a linguagem C",
    "section": "Recursividade",
    "text": "Recursividade\n\nConceito de função que chama a si própria\nIdentificação de caso base e passo recursivo\n\nBase: determinação de ponto de parada para as chamadas\nRecursivo: Divisão do problema em problemas menores\n\nQuestões de desempenho e eficiência\nComparação com implementações iterativas\nLimitações (stack overflow)\nProjeto de funções recursivas\n\nAvaliação do problema e possibilidade de solução recursiva\nIdentificação do caso base\nDefinição do passo recursivo com garantia de convergência\n\nNoções de memoização\nNoções de recursão de cauda\nBoas práticas:\n\nGarantir a existência da condição de parada (caso base e convergência)\nPreferência para iteração para cálculos simples\nControlar o consumo de memória\nQuebrar funções complexas em funções auxiliares"
  },
  {
    "objectID": "conteudo-linguagem-c.html#registros",
    "href": "conteudo-linguagem-c.html#registros",
    "title": "Conteúdo para a linguagem C",
    "section": "Registros",
    "text": "Registros\n\nAplicações e uso de registros\nSintaxe básica stuct (declaração e iniciação)\nAcesso a campos (operador .), com atribuição e leitura\nUso do typedef\nAninhamento de registros\nAcesso a campos com uso de ponteiros (operador -&gt;)\nRegistros como parâmetros de funções (valor e referência)\nRegistros como valor de retorno de funções\nAlinhamento de memória dentro de struct\nCampos que são ponteiros\nSintaxe e uso de union\nBoas práticas\n\nUso de identificadores adequados (camel-case para typedef)\nCuidado com estruturas muito grandes (uso de memória em passagem por valor)\nEvitar uso de structs globais usando passagem como parâmetro"
  },
  {
    "objectID": "conteudo-linguagem-c.html#vetores",
    "href": "conteudo-linguagem-c.html#vetores",
    "title": "Conteúdo para a linguagem C",
    "section": "Vetores",
    "text": "Vetores\n\nAplicações e uso de vetores\nSintaxe de declaração e iniciação\nLeitura de dados\nAcesso aos itens e cuidado com limites\nPassagem de vetores como parâmetros de funções\nUso do const em parâmetros\nVetores dentro de registros\nStrings como vetores de char com terminador\nAlocação dinâmica de vetores\nBoas práticas\n\nDeclaração e iniciação segura\nCuidado com índices inválidos\nEvitação de vetores globais"
  },
  {
    "objectID": "conteudo-linguagem-c.html#matrizes",
    "href": "conteudo-linguagem-c.html#matrizes",
    "title": "Conteúdo para a linguagem C",
    "section": "Matrizes",
    "text": "Matrizes\n\nAplicação e uso de matrizes\nDeclaração e iniciação\nAcesso e modificação com índices\nPassagem de matrizes como parâmetros para funções\nAlocação dinâmica de matrizes\nMatrizes multidimensionais\n\nIdentificadores\nCuidado com limites de índices\nCuidado com passagem de matrizes para funções\nEvitação de matrizes globais"
  },
  {
    "objectID": "conteudo-linguagem-c.html#endereçamento-de-memória-e-ponteiros",
    "href": "conteudo-linguagem-c.html#endereçamento-de-memória-e-ponteiros",
    "title": "Conteúdo para a linguagem C",
    "section": "Endereçamento de memória e ponteiros",
    "text": "Endereçamento de memória e ponteiros\n\nNoções de ponteiros\nDeclaração de ponteiros e seus tipos\nOperadores & (endereço) e * (desreferência)\nRepresentação da memória em endereços\nTamanho do ponteiro e do objeto apontado (sizeof)\nPonteiro nulo (NULL)\nBoas práticas:\n\nGarantia de iniciação de ponteiro antes do uso\nEvitação de acesso a ponteiros nulos"
  },
  {
    "objectID": "conteudo-linguagem-c.html#alocação-dinâmica",
    "href": "conteudo-linguagem-c.html#alocação-dinâmica",
    "title": "Conteúdo para a linguagem C",
    "section": "Alocação Dinâmica",
    "text": "Alocação Dinâmica\n\nNoções de heap como memória disponível\nFunções: malloc, calloc, realloc e free (stdlib.h)\nUso de malloc\nUso de calloc\nComparação entre malloc e calloc\nUso de realloc e cuidado com movimentação de dados\nLiberação de memória com free\nVazamento de memória\nPonteiros para blocos desalocados\nUso do valgrind\nAritmética de ponteiros\nBoas práticas\n\nVerificação de sucesso na alocação\nUso mandatório de desalocação\nCuidado com vazamentos de memória\nEvitação do uso de memória já desalocada\nVerificar sucesso e movimentação de dados no realloc\nCuidado para evitar alocação excessiva (e.g., em repetições)\nCuidado com a aritmética de ponteiros"
  },
  {
    "objectID": "algoritmos/formalizacao.html",
    "href": "algoritmos/formalizacao.html",
    "title": "Formalização dos algoritmos computacionais",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Formalização dos algoritmos computacionais"
    ]
  },
  {
    "objectID": "algoritmos/formalizacao.html#objetivos-do-pseudocódigo",
    "href": "algoritmos/formalizacao.html#objetivos-do-pseudocódigo",
    "title": "Formalização dos algoritmos computacionais",
    "section": "Objetivos do pseudocódigo",
    "text": "Objetivos do pseudocódigo\nO pseudocódigo pode ser visto como uma mistura de aspectos mais formais, como computação ou notação matemática, com linguagem natural.\nComo um primeiro exemplo é apresentado o Algoritmo 1, que considera uma forma de se obter indiretamente a altura de um prédio dados os comprimentos das sombras do prédio de de uma pessoa, juntamente com a altura dessa pessoa. Este tipo de algoritmo pode ser facilmente implementado em C.\n\n\nAlgoritmo 1: Estimativa da altura de um prédio em função de sobras projetadas.\n\n\n\nEste é um típico problema e programa solicitado em listas de exercícios de cursos de programação. O algoritmo apresenta uma solução praticamente pronta para a implementação do programa, incluindo sugestões para os nomes das variáveis e até induzindo os comandos que serão usados. A escrita do Algoritmo 1 foi feita considerando que o algoritmo seria lido por um programador com, minimamente, as capacidades básicas de codificação.\nComo um segundo exemplo de pseudocódigo, o Algoritmo 2 pode ser considerado.\n\n\nAlgoritmo 2: PNN based LPP, adaptado de Levada (2022)\n\n\n\nEste algoritmo é uma adaptação do apresentado no artigo de Levada (2022) e, para entendê-lo por completo, tanto o texto do artigo deve ser lido quanto o leitor deve ter conhecimento sobre o tema abordado. O objetivo do algoritmo não é o entendimento do procedimento que ele realiza em detalhes, mas observar a sequência de passos para produzir o resultado desejado. Ele ainda envolve a integração da linguagem natural com notação matemática para representar as expressões e matrizes utilizadas. No algoritmo original não há a documentação com a descrição nem as pré e pós-condições, uma vez que ele está inserido na discussão apresentada pelo artigo como um todo.\nO Algoritmo 2 não foi escrito para pronta implementação. Ele deixa muitos pontos em aberto, mesmo sendo claro quanto a todos os cálculos que devem ser feitos e em que sequência. Esse é um algoritmo de nível alto de abstração, ou seja, muitos detalhes são omitidos propositalmente em função do público-alvo, que são os leitores do artigo científico. Apresentar todos os detalhes, como o passo a passo da criação dos vetores de distâncias \\(\\vec{d}_i\\) ou a própria fórmula usada para a distância somente tornaria o código desnecessariamente complexo, prejudicando a compreensão da estratégia da solução.\n\nPúblico-alvo e nível de abstração\nQuando um algoritmo vai ser escrito, é preciso ter claro qual é o público-alvo que ele pretende atingir. As instruções, portanto, assumem uma forma baseada no conhecimento prévio de quem vai interpretá-las. Essa decisão implica na escolha do nível de abstração que será empregado.\nUm algoritmo escrito com nível de abstração baixo é aquele mais próximo do programa que será implementado. Ele costuma apresentar as variáveis e comandos de forma mais explícita. Quando o nível de abstração sobe, os detalhes de implementação são substituídos por descrições mais genéricas.\nSupondo que o problema a ser resolvido seja a soma de duas matrizes de mesma dimensão, são apresentados algoritmos em níveis de abstração diferentes, todos corretos e abordando exatamente a mesma solução. O Algoritmo 3 possui um nível de abstração bastante alto, seguido pelo Algoritmo 4, o qual apresenta mais detalhes e pode ser considerado de nível médio; por sua vez, o Algoritmo 5 e o Algoritmo 6 já possuem nível baixo e se aproximam mais de uma possível implementação em um programa.\n\n\nAlgoritmo 3: Soma de duas matrizes de mesma dimensão (nível alto).\n\n\n\n\n\nAlgoritmo 4: Soma de duas matrizes de mesma dimensão (nível médio).\n\n\n\n\n\nAlgoritmo 5: Soma de duas matrizes de mesma dimensão (nível mais baixo).\n\n\n\n\n\nAlgoritmo 6: Soma de duas matrizes de mesma dimensão (nível baixo).\n\n\n\nOs algoritmos são apresentados em quatro níveis de abstração diferentes. A Tabela 1 sumariza uma comparação desses algoritmos.\n\n\n\nTabela 1: Comparação da soma de matrizes com algoritmos em diferentes níveis de abstração.\n\n\n\n\n\nAlgoritmo\nNível\nComentário\n\n\n\n\nAlgoritmo 3\nAlto\nPressupõe o conhecimento de matrizes e suas operações; detalhes como as dimensões são omitidos.\n\n\nAlgoritmo 4\nMédio\nAinda considera o conhecimento sobre matrizes; há mais detalhes de como os dados são obtidos e como o cálculo da soma é feito.\n\n\nAlgoritmo 5\nMais baixo\nA necessidade de conhecer matrizes é mínima, bastando assumir cada elemento como uma variável separada; introduz a necessidade das dimensões para controle da somas; mantém uma linguagem mais natural.\n\n\nAlgoritmo 6\nBaixo\nNão há praticamente necessidade de entender o que é uma matriz; uma estruturação de pseudocódigo é adicionada; cada ação é hiperdetalhada; a linguagem natural é mínima.\n\n\n\n\n\n\nDa mesma forma que o nível de abstração depende do público-alvo, também inexiste a necessidade de que um mesmo algoritmo mantenha o nível de abstração constante para todas suas partes. Desse modo, pontos menos importantes, ou seja, que não são o foco do algoritmo, podem ter nível mais alto enquanto outras partes podem ser mais detalhadas, deixando o nível mais baixo para explicitar pontos relevantes da solução.",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Formalização dos algoritmos computacionais"
    ]
  },
  {
    "objectID": "algoritmos/formalizacao.html#formalização-do-pseudocódigo",
    "href": "algoritmos/formalizacao.html#formalização-do-pseudocódigo",
    "title": "Formalização dos algoritmos computacionais",
    "section": "Formalização do pseudocódigo",
    "text": "Formalização do pseudocódigo\nNão existem regras para a escrita de pseudocódigo. Nada é necessariamente fixo, nem existem estruturas imutáveis que possam ser empregadas. O principal ponto é a representação clara do algoritmo para o leitor.\nEmbora as regras não existam absolutamente, há um convenção geral adotada pela comunidade, ficando um grupo de estruturas e aspectos relativamente consolidados.\n\nPadronização\nOs algoritmos apresentados neste livro seguem um pseudocódigo próprio, baseado no uso geral dos algoritmos escritos pela comunidade de computação. Alguns elementos são mais usuais (condicionais, repetições e funções), outras são menos utilizadas (documentação com pré e pós-condições) e outras não são convencionais (condicional de seleção).\nA opção por ter tanto os elementos de uso geral e quanto algumas “invovações” vem do caráter didático a que este material se propõe a ter.\n\n\nDocumentação\nTodos os algoritmos neste livro conterão um cabeçalho de documentação. Nele são exibidos os seguintes elementos:\n\nDescrição;\nPré-condições;\nPós-condições.\n\nA descrição é a caracterização do problema que o algoritmo resolve e tem a extensão necessária para apresentar com clareza o problema. Em particular, a descrição não apresenta como o problema é resolvido, pois isso é a parte das instruções.\nAs pré-condições e pós-condições reportam de forma tão precisa quanto possível, o que o algoritmo precisa e em que condições esses dados devem estar e também o que ele produz, dando detalhes para que não haja problemas em interpretar o que o algoritmo produz como resultado. Estes dois elementos são apresentados no ?@sec-nocoes-de-algoritmos.\n\n\nDeclaração e uso de variáveis\nEmbora ocorram em alguns algoritmos, as declarações de variáveis não são empregadas nas soluções apresentadas. A ideia de declaração introduz um detalhamento desnecessário no pseudocódigo, pois levaria à necessidade de especificar tipos de dados e impor, eventualmente, limitações e particularidades a eles. Manteve-se, assim, um nível mais alto de abstração para as variáveis.\nOs identificadores são expressos de forma relativamente livre, usando snake case e notação matemática. As atribuições usam",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Formalização dos algoritmos computacionais"
    ]
  },
  {
    "objectID": "algoritmos/formalizacao.html#elementos-estruturais",
    "href": "algoritmos/formalizacao.html#elementos-estruturais",
    "title": "Formalização dos algoritmos computacionais",
    "section": "Elementos estruturais",
    "text": "Elementos estruturais\nSeguindo uma convenção geral, o pseudocódigo adotado segue padrões comuns a artigos científicos e muitos outros materiais disponíveis. Em particular, a formalização adotada no texto segue alguns elementos de estruturação importantes.\n\nExecução sequencial\nCada instrução do algoritmo é escrita em sua própria linha, estabelecendo uma execução sequencial das instruções. Uma nova instrução somente será executada depois da anterior ter sido completamente finalizada.\n\n\n\n\n\nMuitas vezes a inversão na ordem não impacta no resultado, mas uma ordem incorreta implica em uma solução incorreta.\nComo o algoritmo é uma sequência de ordens que devem ser seguidas à risca, o modo verbal usado será sempre o imperativo.\n\n\nObtenção e apresentação de dados\nNos algoritmos, os dados necessários devem ser “entrados” de forma a produzir “saídas”. Por uma associação livre e direta, as entradas são as informações que um usuário digitaria para o programa utilizar, enquanto as saídas são os resultados apresentados no terminal.\nNeste texto, as entradas estarão associadas principalmente ao verbo obter, enquanto a saída usa o verbo apresentar. Por associação às linguagens de programação, também é comum o uso dos verbos ler e escrever, respectivamente.\nNa sequência é apresentada uma entrada e uma saída de dados.\n\n\n\n\n\nAlternativamente, as mesmas instruções podem ser apresentadas como se segue. Nesta versão a verbosidade dá lugar a uma apresentação mais compacta e mais próxima a uma linguagem de programação.\n\n\n\n\n\n\n\nExecução condicional\nA execução condicional assume a forma tradicional da estrutura se, na qual a lista de instruções indicada somente deve ser executada quando a condição verificada for verdadeira.\n\n\n\n\n\nNesta estrutura condicional, a ação somente será executada se a condição indicada for verdadeira. Caso seja falsa, essa ação é simplesmente ignorada.\nAlternativamente, uma ação pode ser indicada caso a condição não seja satisfeita, usando-se uma alternativa com senão.\n\n\n\n\n\nUma terceira forma de expressar a execução condicional com se é pelo sequenciamento de condições, cada uma excluindo a condição anterior.\n\n\n\n\n\nCada novo se somente é verificado caso o imediatamente anterior tenha condição avaliada como falsa.\nEsta última construção da estrutura condicional equivale à apresentada na sequência.\n\n\n\n\n\nAs duas formas são equivalentes, porém a primeira é mais sintética e clara.\nOutro modo de execução condicional pode ser indicado pela estrutura de seleção. Embora estruturas similares estejam presentes em linguagens de programação, esta alternativa é raramente usada em pseudocódigos em geral.\nA estrutura de seleção é uma comparação por igualdades e tem a estrutura seguinte.\n\n\n\n\n\nO conceito desta estrutura de condicional é a indicação de seleções diretas. Assim, entende-se que apenas uma das alternativas será executada e que os valores constantes indicados (cada \\(c_i\\) do exemplo anterior) serão distintos entre si.\nA omissão do caso contrário representa a situação em que, não havendo coincidência com nenhuma das opções, nenhuma ação é realizada.\nQualquer seleção pode ser escrita com a estrutura condicional se.\n\n\nRepetições\nInstruções executadas repetidamente são representadas pelas repetições com enquanto, repita e para.\nA estrutura enquanto utiliza o teste de continuidade da repetição no início, permitindo zero ou mais repetições. Para a condição é esperado uma expressão que resulte em verdadeiro ou falso.\n\n\n\n\n\nA repetição com teste no final utiliza a estrutura repita, encerrada com até que, na qual consta a condição de término das repetições. A condição é avaliada apenas ao final de cada execução, o que implica que pelo menos a primeira das repetições tem que ser completada.\n\n\n\n\n\nTanto as repetições com enquanto quanto com repita são “abertas”, ou seja, dependem das ações nas instruções internas alterarem a condição para que laço seja interrompido.\nAs repetições definidas (i.e., não “abertas”) são expressas com para. Usualmente uma repetição deste tipo pressupões o conhecimento do número de vezes que as instruções serão executadas. Na sequência são apresentadas as estruturas com para.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nRepetições com para podem ser abertas como no exemplo seguinte.\n\n\n\n\n\nEsse uso é evitado (com sucesso relativo) neste livro, dando-se preferência para laços com enquanto e repita quando o número de repetições é desconhecido.\n\n\n\n\n\n\n\n\n\nModularização\n\n\nComentários",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Formalização dos algoritmos computacionais"
    ]
  },
  {
    "objectID": "algoritmos/formalizacao.html#algoritmos-estruturados",
    "href": "algoritmos/formalizacao.html#algoritmos-estruturados",
    "title": "Formalização dos algoritmos computacionais",
    "section": "Algoritmos estruturados",
    "text": "Algoritmos estruturados",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Formalização dos algoritmos computacionais"
    ]
  },
  {
    "objectID": "algoritmos/formalizacao.html#notação-programática-versus-notação-matemática",
    "href": "algoritmos/formalizacao.html#notação-programática-versus-notação-matemática",
    "title": "Formalização dos algoritmos computacionais",
    "section": "Notação programática versus notação matemática",
    "text": "Notação programática versus notação matemática\ntemperatura_celsius vs. \\(t_c\\).",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Formalização dos algoritmos computacionais"
    ]
  },
  {
    "objectID": "algoritmos/dados-compostos-matrizes.html",
    "href": "algoritmos/dados-compostos-matrizes.html",
    "title": "algoritmos-dados-compostos-matrizes.qmd",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nalgoritmos-dados-compostos-matrizes.qmd"
  },
  {
    "objectID": "algoritmos/execucao-condicional.html",
    "href": "algoritmos/execucao-condicional.html",
    "title": "Algoritmos: execução condicional",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/execucao-condicional.html#introdução-ao-fluxo-condicional",
    "href": "algoritmos/execucao-condicional.html#introdução-ao-fluxo-condicional",
    "title": "Algoritmos: execução condicional",
    "section": "Introdução ao fluxo condicional",
    "text": "Introdução ao fluxo condicional"
  },
  {
    "objectID": "algoritmos/execucao-condicional.html#exemplos",
    "href": "algoritmos/execucao-condicional.html#exemplos",
    "title": "Algoritmos: execução condicional",
    "section": "Exemplos",
    "text": "Exemplos"
  },
  {
    "objectID": "algoritmos/execucao-condicional.html#desenvolvimento-com-fluxo-condicional",
    "href": "algoritmos/execucao-condicional.html#desenvolvimento-com-fluxo-condicional",
    "title": "Algoritmos: execução condicional",
    "section": "Desenvolvimento com fluxo condicional",
    "text": "Desenvolvimento com fluxo condicional"
  },
  {
    "objectID": "algoritmos/desenvolvimento-de-algoritmos-para-processamento-de-sequencias.html",
    "href": "algoritmos/desenvolvimento-de-algoritmos-para-processamento-de-sequencias.html",
    "title": "Desenvolvimento de algoritmos para processamento de sequências de dados",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/desenvolvimento-de-algoritmos-para-processamento-de-sequencias.html#ações-simples-contagens-e-somas",
    "href": "algoritmos/desenvolvimento-de-algoritmos-para-processamento-de-sequencias.html#ações-simples-contagens-e-somas",
    "title": "Desenvolvimento de algoritmos para processamento de sequências de dados",
    "section": "Ações simples: contagens e somas",
    "text": "Ações simples: contagens e somas\nO levantamento de informações a partir de coleções de dados é sempre relevante para análises em nível mais alto. Por exemplo, a determinação do número de estudantes que obtiveram nota zero em um exame do ENEM é um indicador relevante, assim como saber a média das provas de matemática por estado da federação. Da forma similar, a identificação de transações acima de um limite em operações bancárias pode ser um indicador relevante para o mercado e para o governo.\nA obtenção dessas informações recai, em última (e simplificada) instância, em ações básicas como contar e somar.\n\nContagem\nA contagem nada mais é que a identificação do número de ocorrências. Para exemplificar, um problema bastante trivial é apresentado: determinar, para uma sequência de idades, a quantidade de crianças, o seja, com até 12 anos incompletos1. A quantidade de idades disponíveis é considerada desconhecida, podendo também ser nula. O Algoritmo 1 apresenta uma solução para processar essa coleção de dados como uma sequência.\n\n\nAlgoritmo 1: Determinação do número de crianças em uma coleção de idades zero ou mais itens (versão com imprecisão).\n\n\n\nO uso da estrutura enquanto é relevante, pois controla uma quantidade indeterminada de idades como entrada e trata, também, o caso dessa quantidade ser nula.\nEsse algoritmo contém um elemento de imprecisão. No caso, por exemplo, de não haver nenhuma idade abaixo dos 12 anos, a condição do se nunca será verdadeira e nenhuma contagem é feita. Porém, a última instrução explicita que que uma contagem que nunca foi feita deva ser apresentada.\nÉ interessante que, nos algoritmos, essa ambiguidade seja explicitamente resolvida e, para isso, a forma com que a contagem é feita pode ser detalhada, indicando claramente o resultado esperado. O resultado da modificação é o Algoritmo 2\n\n\nAlgoritmo 2: Determinação do número de crianças em uma coleção de idades zero ou mais itens (versão com imprecisão).\n\n\n\nNesta versão, \\(\\Id{contador}\\) é uma variável usada para fazer a contagem, começando explicitamente com zero, o que deixa claro o valor que será apresentado caso não haja nenhuma repetição.\nO princípio da contagem é a atualização do valor de uma variável com seu sucessor, de forma que “adicione 1 a \\(\\Id{contador}\\)” significa \\({\\Id{contador} \\gets \\Id{contador} + 1}\\).\nContadores podem ser aplicados em diferentes cenários de entrada, como sequências com sentinela ou com comprimento conhecido ou previamente informado.\nO mesmo problema base (contagem de idades inferiores a 12) pode ter especificação e solução novas se a sequência possuir um valor especial de término (sentinela). O problema passa a ser determinar o número de crianças em uma sequência de idades que possui um valor sentinela igual a -1.\nPara esse novo problema, uma solução é apresentada no Algoritmo 3.\n\n\nAlgoritmo 3: Determinação do número de crianças em uma coleção de idades zero ou mais itens com sentinela (versão 1).\n\n\n\nEssa solução usa o enquanto para controlar a aparição do valor sentinela. Há uma primeira leitura antes da repetição e, caso já apareça o valor sentinela, não é feita nenhuma repetição e o valor da contagem é zero. Se o primeiro valor for uma idade, ela é verificada para a contagem. Antes de nova verificação no enquanto, o próximo valor da sequência é obtido e, logo em seguida, verificado na condição do enquanto.\nO Algoritmo 4 é outra solução para a sequência com sentinela usando repita.\n\n\nAlgoritmo 4: Determinação do número de crianças em uma coleção de idades zero ou mais itens com sentinela (versão 2).\n\n\n\nCom o uso da estrutura repita, obrigatoriamente os comandos internos serão executados pelo menos uma vez. Caso a sequência de idades esteja vazia, o valor obtido será o sentinela, o qual é desconsiderado no se e a repetição já se encerra no até que, o que resulta em \\(\\Id{contador}\\) igual a zero. Caso o valor não seja o sentinela, a idade é analisada e o contador incrementado se necessário, implicando em novo ciclo de repetição.\nA questão de contagem de idades pode, por exemplo, também ser aplicada a um problema para o qual a quantidade de idades a ser analisada seja predefinido. Supondo agora a contagem de crianças para uma coleção com quantidade fixa de 100 idades, a solução pode ser dada pelo Algoritmo 5. Como o valor é fixo, a estrutura para é empregada para a repetição.\n\n\nAlgoritmo 5: Determinação do número de crianças em uma coleção de 100 idades.\n\n\n\nComo outra possibilidade, o problema pode considerar uma sequência para a qual seja informada sua quantidade. Por exemplo, para uma sequência de 10 idades, a quantidade 10 é conhecida antes da repetição. O@alg-quantidade-criancas-sequencia-informada considera que o comprimento da sequência esteja disponível antes de cada idade.\n\n\nAlgoritmo 6: Determinação do número de crianças em uma coleção de idades com zero ou mais itens precedida pela quantidade de itens.\n\n\n\nNesse algoritmo, os requisitos são a quantidade e os valores das idades. Antes da repetição, o número de itens deve ser obtido (variável \\(\\Id{quantidade}\\)) e a repetição, usando um para, executa a obtenção e a análise de cada idade na quantidade de vezes informada.\nNas duas soluções que usam o para, a variável de controle da repetição (\\(i\\)) é irrelevante para a solução do problema, sendo usada exclusivamente como indicador para o número de execuções.\n\n\nSomas\nNo processamento de volumes de dados, os totais também são uma informação de interesse comumente usada. Por exemplo, nas transações de venda de um estabelecimento, saber o valor total de vendas em um dia pode ser relevante. Também são importantes os volumes de chuva ao longo de um dado período, obtido pela soma das precipitações diárias. Assim, somas são o tema desta seção.\nPara explorar somas em sequências, o princípio é similares ao das contagens da Seção 1.1.1, com o reuso de uma variável com a função de acumular valores. Por exemplo, as instruções seguintes ilustram uma forma de reuso para uma soma.\n\n\n\n\n\nEsta sequência de ações gradativamente calculam \\(12 + 18 + 31\\).\nO problema exemplo a ser resolvido agora envolve a apresentação das entradas e saídas de um caixa ao longo do dia. Cada transação feita é registrada por um valor em reais, sendo valores positivos indicativos de entrada de dinheiro no caixa e, em consequência, valores negativos, as saídas. Como transações com valor nulo não fazem sentido neste contexto, o valor R$0,00 é usado como sentinela para indicar o fim da sequência de valores de transações. O objetivo é apresentar o total de entradas e de saídas, além da diferença entre eles.\nUma solução para esse problema está descrita no Algoritmo 7.\n\n\nAlgoritmo 7: Cálculo do montante de entrada e de saída a partir de uma sequência de valores de transações (com sentinela).\n\n\n\nA estratégia de varredura dos valores das transações é o mesmo do Algoritmo 3, com a obtenção do primeiro valor antes do enquanto e a obtenção de cada sucessor no final, antes de nova verificação da condição.\nA iniciação dos somadores \\(\\Id{soma\\_entradas}\\) e \\(\\Id{soma\\_saídas}\\) é feita com zero. A cada transação, um ou outro tem seu valor aumentado pelo montante da transação atual.\n\n\nMínimos e máximos\nValores extremos são itens usualmente buscados em coleções de dados, como, por exemplo, a transação de maior valor no mercado imobiliário ou a idade mínima para um conjunto de pessoas.\nA estratégia por trás da determinação dos valores mínimo e máximo é simples. Na procura pelo valor mínimo, cada novo valor é comparado ao mínimo atual e, sendo menor, o mínimo atual é atualizado. Situação análoga ocorre com o valor máximo, substituído apenas quando encontrar um valor maior. Algoritmicamente, essa verificação para o valor mínimo pode ser escrita como indicado na sequência.\n\n\n\n\n\nUma questão que surge é sobre qual deve ser o valor inicial da variável quem mantém o mínimo ou o máximo. A resposta, naturalmente, é que a variável deve ser iniciada com um valor que garanta que as substituições ocorram corretamente.\n\nUma estratégia segura é sempre adotar o primeiro valor como o valor extremo, seja ele o mínimo ou o máximo, e depois verificar os demais itens.\nO problema para exemplificar a localização dos extremos é a determinação, para um coleção de idades, qual o mínimo e o máximo. As idades estão disponíveis em uma sequência precedida por sua quantidade e há pelo menos um valor na sequência.\n\n\nAlgoritmo 8: Determinação da idade mínima e máxima em uma coleção de idades precedida pelo número de itens.\n\n\n\nUma alternativa comum é iniciar com valores que certamente serão substituídos, como apresentado no Algoritmo 9.\n\n\nAlgoritmo 9: Determinação da idade mínima e máxima em uma coleção de idades precedida pelo número de itens.\n\n\n\nNesta solução, qualquer que seja a primeira idade, ela certamente será menor que \\(+\\infty\\) e maior que \\(-\\infty\\), forçando as substituições de \\(\\Id{idade}_{min}\\) e \\(\\Id{idade}_{max}\\). No caso de idades, as iniciações poderiam ser, respectivamente, com 200 anos (com uma boa folga) e -1, ambos valores fora do intervalo de idades aceitável.\n\n\nDerivações\nEm decorrência de contagens e somatórios, outros cálculos seguem diretamente, com médias e porcentagens.\n\nMédias\nO cálculo de uma média consiste na soma dos valores seguida da divisão pela quantidade. Na prática, é um somatório e uma contagem seguida do cálculo da razão entre eles.\nSupondo que o problema seja o processamento de uma sequência simples de pontuações, todas de 0 a 100, e se deseja a pontuação média. O Algoritmo 10 apresenta uma solução para o problema, considerando que a sequência de entrada contém pelo menos uma pontuação.\n\n\nAlgoritmo 10: Determinação da pontuação média para uma coleção de pontuações.\n\n\n\n\n\nPorcentagens\nPara porcentagens é preciso ter uma quantidade de ocorrências específicas e dividir esse valor pelo número total de ocorrências. Basicamente, contam-se as ocorrências específicas o e o total, realizando a divisão de um pelo outro na sequência.\nSupondo uma sequência de pontuações (de 0 a 100) e desejando-se saber a porcentagem das pontuações no intervalo [90, 100], uma solução algorítmica pode ser dada pelo pseudocódigo do Algoritmo 11.\n\n\nAlgoritmo 11: Determinação, para uma coleção de pontuações, a porcentagem de pontuações de 90 a 100."
  },
  {
    "objectID": "algoritmos/desenvolvimento-de-algoritmos-para-processamento-de-sequencias.html#footnotes",
    "href": "algoritmos/desenvolvimento-de-algoritmos-para-processamento-de-sequencias.html#footnotes",
    "title": "Desenvolvimento de algoritmos para processamento de sequências de dados",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nFaixa etária definida pelo “Estatuto da Criança e do Adolecente” (1990).↩︎"
  },
  {
    "objectID": "algoritmos/dados-compostos-registros.html",
    "href": "algoritmos/dados-compostos-registros.html",
    "title": "Algoritmos: dados compostos (registros)",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/dados-compostos-registros.html#conceito-de-estruturação-de-dados",
    "href": "algoritmos/dados-compostos-registros.html#conceito-de-estruturação-de-dados",
    "title": "Algoritmos: dados compostos (registros)",
    "section": "Conceito de estruturação de dados",
    "text": "Conceito de estruturação de dados"
  },
  {
    "objectID": "algoritmos/dados-compostos-registros.html#registros-e-campos",
    "href": "algoritmos/dados-compostos-registros.html#registros-e-campos",
    "title": "Algoritmos: dados compostos (registros)",
    "section": "Registros e campos",
    "text": "Registros e campos"
  },
  {
    "objectID": "algoritmos/dados-compostos-registros.html#representação-de-dados-compostos-em-algoritmos",
    "href": "algoritmos/dados-compostos-registros.html#representação-de-dados-compostos-em-algoritmos",
    "title": "Algoritmos: dados compostos (registros)",
    "section": "Representação de dados compostos em algoritmos",
    "text": "Representação de dados compostos em algoritmos\n\nAbstração alta\nAbstração baixa (notação .)"
  },
  {
    "objectID": "algoritmos/dados-compostos-registros.html#funções-com-registros",
    "href": "algoritmos/dados-compostos-registros.html#funções-com-registros",
    "title": "Algoritmos: dados compostos (registros)",
    "section": "Funções com registros",
    "text": "Funções com registros"
  },
  {
    "objectID": "algoritmos/desenvolvimento-com-modularizacao.html",
    "href": "algoritmos/desenvolvimento-com-modularizacao.html",
    "title": "Algoritmos: desenvolvimento com modularização",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/desenvolvimento-com-modularizacao.html#desenvolvimento-por-refinamentos-sucessivos",
    "href": "algoritmos/desenvolvimento-com-modularizacao.html#desenvolvimento-por-refinamentos-sucessivos",
    "title": "Algoritmos: desenvolvimento com modularização",
    "section": "Desenvolvimento por refinamentos sucessivos",
    "text": "Desenvolvimento por refinamentos sucessivos"
  },
  {
    "objectID": "algoritmos/desenvolvimento-com-modularizacao.html#estratégias-de-modularização",
    "href": "algoritmos/desenvolvimento-com-modularizacao.html#estratégias-de-modularização",
    "title": "Algoritmos: desenvolvimento com modularização",
    "section": "Estratégias de modularização",
    "text": "Estratégias de modularização"
  },
  {
    "objectID": "algoritmos/index.html",
    "href": "algoritmos/index.html",
    "title": "Noções de algoritmos",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Noções de algoritmos"
    ]
  },
  {
    "objectID": "algoritmos/index.html#características-gerais-dos-algoritmos",
    "href": "algoritmos/index.html#características-gerais-dos-algoritmos",
    "title": "Noções de algoritmos",
    "section": "Características gerais dos algoritmos",
    "text": "Características gerais dos algoritmos\nPor exemplo, as instruções de como higienizar uma máquina de lavar roupas são um algoritmo. Esse algoritmo parte do pressuposto de uma máquina de lavar para ser higienizada, descreve os passos para serem seguidos (deixar o cesto vazio, acrescentar a água sanitária, deixar em um ciclo específico por um determinado tempo) e atinge o resultado desejado, que é a máquina limpa.\nA montagem de uma estante comprada online também segue o algoritmo estabelecido no manual de montagem, tendo como objetivo partir de um conjunto de peças separadas e obter a estante montada e funcional. Os passos passam pela verificação da disponibilidade de todas as peças e ferramentas necessárias, montagem organizada das diversas partes e devidas finalizações.\nUm último (e clássico) exemplo é uma receita culinária, a qual parte dos ingredientes constituintes e chega a um bolo, um assado ou outro prato qualquer.\nTodos esses algoritmos possuem três elementos principais:\n\nA situação inicial;\nA sequência de passos que devem ser seguidos;\nA situação final.\n\n A situação inicial são as pré-condições, ou seja, o que tem haver antes da execução dos passos para que todas as ações possam ser seguidas de forma adequada. Os passos determinam as ações que devem ser executadas e uma ordem coerente para que aconteçam. As pós-condições caracterizam a situação final, ou seja, a completude do que o algoritmo se propôs a resolver.\nNa Tabela 1 são apresentados esses elementos para dois exemplos específicos, ilustrando-os de forma simplificada.\n\n\n\nTabela 1: Exemplos ilustrando os elementos (pré-condições, passos, pós-condições) para dois problemas específicos.\n\n\n\n\n\n\n\n\n\n\n\nCocção de um pão\nAtualização de um saldo bancário\n\n\n\n\nPré-condições\nDisponibilidade dos ingredientes e utensílios necessários\nO saldo anterior e todas as movimentações no período\n\n\nPassos\nPreparação da massa, descanso, crescimento, forno\nAtualização do saldo passando-se por cada movimentação individual\n\n\nPós-condições\nPão\nO saldo atualizado\n\n\n\n\n\n\n\n\n\n\n\n\nAlgoritmo\n\n\n\n Um algoritmo pode ser definido como uma sequência finita de passos que levam de uma situação inicial (pré-condições) a uma situação final (pós-condições) de forma bem definida. A partir desse conceito, é esperado que, a partir do mesmo estado inicial e seguidos os mesmos passos, o estado final seja atingido.\n\n\nEsta definição não se aplica, em particular, à receita do pão indicada na Tabela 1. O resultado tende a variar consideravelmente dependendo de uma variedade de situações não mencionadas, como o tipo e a qualidade da farinha, a temperatura ambiente que influencia no crescimento da massa e o forno usado, que pode aquecer mais ou menos que outro forno, por exemplo. Para se garantir um resultado sempre “igual”, todas essas variáveis deveriam entrar nas pré-condições. Felizmente, essas variações são toleradas no resultado final da receita, sendo até esperadas tais diferenças. As pré-condições e pós-condições podem, dependendo do caso, ter graus de especificidade variados.\nEssa variação de resultados, porém, não é tolerada na atualização do saldo bancário. Dado o mesmo saldo inicial e as mesmas movimentações, o resultado não pode ser diferente sob nenhuma hipótese. Tem que haver uma previsibilidade do resultado. Neste caso, pré e pós-condições são bastante determinísticas.\n\nOs algoritmos com resultados e passos mais maleáveis, que toleram certas variações no resultado final, enquadram-se como algoritmos gerais. Entre eles estão as receitas, instruções de montagem de móveis, orientações para se chegar a um destino com GPS ou instruções de como inserir um novo contato na agenda do telefone. Em todos eles, até a vivência e experiências pessoais de quem os executa podem ter influência no resultado. Há pessoas com ótima mão para fazer bolos, por exemplo.\nSe for pedido a um humano que converta 95 Fahrenheit para graus Celsius, ele pode usar seu smartphone para abrir uma ferramenta de busca, digitar “quanto é 95 farenheit em celsius” (sim, com o erro de digitação) e obter a resposta de 35oC. Ele poderia estar sem bateria e optado por usar um computador para fazer a busca; poderia também ter escolhido uma ferramenta de busca no lugar de outra; poderia até ter digitado o texto da consulta de diversas outras maneiras distintas. Esse humano poderia também ter boa memória e se lembrar da fórmula, além de ter facilidade para fazer contas de cabeça e dar o resultado sem nenhum outro recurso a não ser ele mesmo.",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Noções de algoritmos"
    ]
  },
  {
    "objectID": "algoritmos/index.html#algoritmos-computacionais",
    "href": "algoritmos/index.html#algoritmos-computacionais",
    "title": "Noções de algoritmos",
    "section": "Algoritmos computacionais",
    "text": "Algoritmos computacionais\nExiste uma classe particular de algoritmos para os quais há um maior rigor nos mais diversos aspectos e eles não podem depender da experiência ou interpretação de que os executa. Esses são os algoritmos escritos para serem executados, em última instância, por um sistema computacional (processador e memória eletrônicos) e, para tanto, têm que ser extremamente claros e precisos em cada instrução a ser executada, bem como possuem pré-condições e pós-condições bastantes específicas.\nCaso um sistema computacional, ou seja, um programa, deva realizar a mesma tarefa, ele tem que ter bem definidas todas as etapas. As pré-condições, por exemplo, definiriam que o valor deveria ser um número real, os passos indicariam o cálculo da conversão e qual seria a expressão usada e, finalmente, o resultado produzido como pós-condição estaria bem definido.\n\n\n\n\n\n\nAlgoritmos computacionais\n\n\n\n Um algoritmo computacional é aquele que define com clareza todas pré-condições e estabelece também claramente as pós-condições. Também define os passos de forma inequívoca e direta, sem margens para interpretações ou variações. Seu objetivo é ser executado em um sistema computacional.",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Noções de algoritmos"
    ]
  },
  {
    "objectID": "algoritmos/index.html#as-várias-formas-de-representar-algoritmos",
    "href": "algoritmos/index.html#as-várias-formas-de-representar-algoritmos",
    "title": "Noções de algoritmos",
    "section": "As várias formas de representar algoritmos",
    "text": "As várias formas de representar algoritmos\nExistem diversas maneiras de se representar um algoritmo. Para algoritmos gerais, podem ser usadas figuras ou instruções textuais, por exemplo. Na Figura 1 são mostradas duas alternativas com algoritmos para a limpeza de uma máquina de lavar roupas. As instruções não são as mesmas, mas o conceito de formas diferentes para que as instruções sejam apresentadas podem variar. Certamente, há um vídeo que também ensina esse procedimento.\n\n\n\n\n\n\n\n\n\n\n\n(a) Central de Ajuda Panasonic.1\n\n\n\n\n\n\n\n\n\n\n\n(b) Como limpar máquina de lavar.2\n\n\n\n\n\n\n\nFigura 1: Duas representações distintas para uma mesma tarefa: representação por figuras ilustrativas e textual.\n\n\n\nPara o caso dos algoritmos computacionais há duas formas mais usuais para representar a sequência de passos que resolvem um dado problema: fluxogramas e pseudocódigo. Naturalmente, há alternativas menos empregadas.\n\nFluxogramas\nOs fluxogramas são representações visuais com os passos que implementam cada algoritmo. Os símbolos (caixas) possuem formas específicas para cada função e setas as ligam indicando a ordem em que devem ser executadas. Na Figura 2 é apresentado um fluxograma para o cálculo das raízes reais de equação de segundo grau e apresentação de mensagens de erro nos casos adequados.\n\n\n\n\n\n\nFigura 2: Fluxograma para cálculo e apresentação das raízes reais de uma equação de segundo grau.\n\n\n\n\n\nPseudocódigo\nComo alternativa aos fluxogramas, é bastante comum o emprego do chamado pseudocódigo, o qual se assemelha a programas, mas é uma abstração da solução. O Algoritmo 1 é apresentado na forma de pseudocódigo.\nO Algoritmo 1 se refere à mesma solução lógica da Figura 2.\n\n\nAlgoritmo 1: Pseudocódigo para o cálculo e apresentação das raízes reais de uma equação de segundo grau.\n\n\n\n\n\nFluxogramas ou pseudocódigo?\nEmbora não sejam as únicas formas de representar algoritmos, fluxogramas e pseudocódigo são as mais usuais. A questão natural é qual deles escolher.\nOs fluxogramas são mais fáceis de serem entendidos, mesmo que por pessoas que não sejam da área de computação, pois apresentam com clareza suficiente fluxo de ações do algoritmo. Quando o nível de complexidade do problema aumenta, porém, os fluxogramas começam a ficar muito densos (muitas caixas e muitas conexões), prejudicando o entendimento. A manutenção dos fluxogramas também é um fator que demanda esforço, mesmo com ferramentas que auxiliem em sua construção. Em geral, fluxogramas possuem nível de abstração elevado, ou seja, simplificam e generalizam conceitos complexos.\nPor sua vez, o pseudocódigo é menos abstrato, dado que utiliza uma mistura de linguagem natural com conceitos computacionais para descrever os passos do algoritmo. Em decorrência, faz uso de uma estrutura e uma sintaxe com certa rigidez, uma vez que as instruções para cada ação devem ser exatas, sem ambiguidades ou margem para interpretações diferentes. Os pseudocódigos são descrições estruturadas de algoritmos, possuindo indicações de fluxo bastante rígidas.\nUm ponto importante dos pseudocódigos é seu uso frequente em livros e artigos científicos, representando soluções precisas para os problemas estudados.\nEste livro faz uso do pseudocódigo para a descrição dos algoritmos, uma vez que a precisão na descrição das soluções é importante.\n\nambiguidades\nestruturação\ncontrole de fluxo",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Noções de algoritmos"
    ]
  },
  {
    "objectID": "algoritmos/index.html#algoritmos-e-programas",
    "href": "algoritmos/index.html#algoritmos-e-programas",
    "title": "Noções de algoritmos",
    "section": "Algoritmos e programas",
    "text": "Algoritmos e programas\nO Algoritmo 2 é um algoritmo computacional simples com uma solução para a conversão de temperaturas entre duas escalas termométricas: de graus Celsius para Fahrenheit.\n\n\nAlgoritmo 2: Conversão de graus Celsius para Fahrenheit.\n\n\n\nPara exemplificar como esse algoritmo pode se tornar um programa, seguem exemplos de sua implementação em algumas linguagens distintas, sendo importante salientar a grande variação de formatos de comandos e da estrutura de cada linguagem.\nPascal:\n(*\nConversão de escalas termométricas, de graus Celsius para Fahrenheit\nRequer: a temperatura em graus Celsius\nAssegura: a temperatura em Fahrenheit\n*)\nprogram ConversaoTemperaturas;\nvar\n    Celsius, Fahrenheit: real;\nbegin\n    read(Celsius);\n    Fahrenheit := 9 / 5 * Celsius + 32;\n    write(Fahrenheit:5:2);\nend.\nPython:\n# Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n# Pré-condição: a temperatura em graus Celsius\n# Pós-condição: a temperatura em Fahrenheit\n\ncelsius = float(input())\nfahrenheit = 9 / 5 * celsius + 32\nprint(f\"{fahrenheit:.2f}\")\nC:\n/*\nConversão de escalas termométricas, de graus Celsius para Fahrenheit\nRequer: a temperatura em graus Celsius\nAssegura: a temperatura em Fahrenheit\n*/\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char entrada[160];\n\n    fgets(entrada, sizeof entrada, stdin);\n    double celsius;\n    sscanf(entrada, \"%ld\", &celsius);\n\n    double fahrenheit = (double)9 / 5 * celsius + 32;\n    printf(\"%.2f\", fahrenheit);\n\n    return 0;\n}\nR:\n# Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n# Pré-condição: a temperatura em graus Celsius\n# Pós-condição: a temperatura em Fahrenheit\n\ncelsius &lt;- as.numeric(readline(\"\"))\nfahrenheit &lt;- celsius * 9 / 5 + 32\ncat(fahrenheit, \"\\n\")\nJava:\n// Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n// Pré-condição: a temperatura em graus Celsius\n// Pós-condição: a temperatura em Fahrenheit\n\nimport java.util.Scanner;\n\npublic class ConversorTemperatura {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        double celsius = scanner.nextDouble();\n\n        double fahrenheit = celsius * 9 / 5 + 32;\n        System.out.println(fahrenheit);\n        \n        scanner.close();\n    }\n}\nAda:\n-- Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n-- Pré-condição: a temperatura em graus Celsius\n-- Pós-condição: a temperatura em Fahrenheit\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Conversor_Temperatura is\n   Celsius : Float;\n   Fahrenheit : Float;\n\nbegin\n   Get(Item =&gt; Celsius);\n   Fahrenheit := Celsius * 9.0 / 5.0 + 32.0;\n   Put_Line(Float'Image(Fahrenheit));\nend Conversor_Temperatura;\nLua:\n-- Conversão de escalas termométricas, de graus Celsius para Fahrenheit\n-- Pré-condição: a temperatura em graus Celsius\n-- Pós-condição: a temperatura em Fahrenheit\n\nlocal celsius = tonumber(io.read())\nlocal fahrenheit = celsius * 9 / 5 + 32\nprint(fahrenheit)\nExiste, claramente, uma distância entre a solução (algoritmo) e sua implementação (código da linguagem).\nO principal conceito por trás dos algoritmos é ter uma solução mais abstrata, a qual não se restringe aos detalhes que cada linguagem impõe e, entretanto, apresenta uma solução simples de entender e objetiva quanto a como o problema abordado é resolvido.",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Noções de algoritmos"
    ]
  },
  {
    "objectID": "algoritmos/index.html#footnotes",
    "href": "algoritmos/index.html#footnotes",
    "title": "Noções de algoritmos",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\n\nCentral de Ajuda da Panasonic: https://panasonic-br.zendesk.com/hc/pt-br/articles/360043470732-Como-realizar-a-higieniza%C3%A7%C3%A3o-da-minha-M%C3%A1quina-de-Lavar-roupas-Panasonic-.↩︎\nBuscapé: https://www.buscape.com.br/lavadora-roupas/conteudo/como-limpar-maquina-de-lavar.↩︎",
    "crumbs": [
      "Algoritmos",
      "Representação e uso de algoritmos",
      "Noções de algoritmos"
    ]
  },
  {
    "objectID": "algoritmos/recursividade.html",
    "href": "algoritmos/recursividade.html",
    "title": "algoritmos-recursividade.qmd",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)\n\nalgoritmos-recursividade.qmd"
  },
  {
    "objectID": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html",
    "href": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html",
    "title": "Algoritmos: desenvolvimento por refinamentos sucessivos",
    "section": "",
    "text": "\\(\\newcommand\\Id[1]{\\mbox{\\textit{#1}}}\\)"
  },
  {
    "objectID": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#níveis-de-abstração",
    "href": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#níveis-de-abstração",
    "title": "Algoritmos: desenvolvimento por refinamentos sucessivos",
    "section": "Níveis de abstração",
    "text": "Níveis de abstração"
  },
  {
    "objectID": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#correção-da-solução-em-qualquer-nível-de-abstração",
    "href": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#correção-da-solução-em-qualquer-nível-de-abstração",
    "title": "Algoritmos: desenvolvimento por refinamentos sucessivos",
    "section": "Correção da solução em qualquer nível de abstração",
    "text": "Correção da solução em qualquer nível de abstração"
  },
  {
    "objectID": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#refinamentos-sucessivos-top-down",
    "href": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#refinamentos-sucessivos-top-down",
    "title": "Algoritmos: desenvolvimento por refinamentos sucessivos",
    "section": "Refinamentos sucessivos (top-down)",
    "text": "Refinamentos sucessivos (top-down)"
  },
  {
    "objectID": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#exemplos",
    "href": "algoritmos/desenvolvimento-por-refinamentos-sucessivos.html#exemplos",
    "title": "Algoritmos: desenvolvimento por refinamentos sucessivos",
    "section": "Exemplos",
    "text": "Exemplos"
  }
]